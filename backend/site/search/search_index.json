{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sync Smart Home API Documentation","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#app.main","title":"<code>app.main</code>","text":"<p>This module initializes &amp; configures the FastAPI application</p> <p>It acts as a middleware between the front-end &amp; database, handling: - API route inclusion - CORS middleware for front-end communication - Database initialization &amp; application life-cycle management</p>"},{"location":"api/#app.main.RootResponse","title":"<code>app.main.RootResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the root endpoint</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Welcome message</p> Source code in <code>app/main.py</code> <pre><code>class RootResponse(BaseModel):\n    \"\"\"\n    Response model for the root endpoint\n\n    Attributes:\n        message (str): Welcome message\n    \"\"\"\n    message: str\n</code></pre>"},{"location":"api/#app.main.lifespan","title":"<code>app.main.lifespan(app_context)</code>  <code>async</code>","text":"<p>Defines application's lifespan event handler</p> <ul> <li>Initialization the database at startup</li> <li>Sets up application-wide state variables</li> <li>Logs startup &amp; shutdown events</li> </ul> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <code>FastAPI</code> <p>The FastAPI application instance</p> required <p>Yields:</p> Name Type Description <code>None</code> <p>Allows FastAPI to manage application life-cycle</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If database initialization fails</p> Source code in <code>app/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app_context: FastAPI):\n    \"\"\"\n    Defines application's lifespan event handler\n\n    - Initialization the database at startup\n    - Sets up application-wide state variables\n    - Logs startup &amp; shutdown events\n\n    Args:\n        app_context (FastAPI): The FastAPI application instance\n\n    Yields:\n        None: Allows FastAPI to manage application life-cycle\n\n    Raises:\n        Exception: If database initialization fails\n    \"\"\"\n    try:\n        await init_db()\n        app_context.state.custom_attribute = \"value\"    # Placeholder for future app-wide state\n        logger.info(\"Application startup complete.\")\n        yield\n    except Exception as e:\n        logger.error(\"Failed to initialize the database: %e.\")\n        raise e\n    finally:\n        logger.info(\"Application is shutting down.\")\n</code></pre>"},{"location":"api/#app.main.read_root","title":"<code>app.main.read_root()</code>","text":"<p>Root endpoint</p> <p>Returns:</p> Name Type Description <code>RootResponse</code> <code>RootResponse</code> <p>A welcome message for the API</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/\", response_model = RootResponse)\ndef read_root() -&gt; RootResponse:\n    \"\"\"\n    Root endpoint\n\n    Returns:\n        RootResponse: A welcome message for the API\n    \"\"\"\n    return RootResponse(message = \"Welcome to the Sync Smart Home.\")\n</code></pre>"},{"location":"api/#app.routes.user_routes","title":"<code>app.routes.user_routes</code>","text":"<p>This module defines user-related API routes for registration, authentication &amp; role-based access</p> <p>It includes: - User registration with hashed password storage - User authentication &amp; JWT token issuance - Admin dashboard access (restricted to users with the \"admin\" role)</p>"},{"location":"api/#app.routes.user_routes.get_admin_dashboard","title":"<code>app.routes.user_routes.get_admin_dashboard()</code>  <code>async</code>","text":"<p>Admin dashboard  endpoint (restricted access)</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A welcome message confirming admin access</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.get(\"/admin/dashboard\", dependencies = [Depends(role_required(\"admin\"))])\nasync def get_admin_dashboard():\n    \"\"\"\n    Admin dashboard  endpoint (restricted access)\n\n    Returns:\n        dict: A welcome message confirming admin access\n    \"\"\"\n    return {\"message\": \"Welcome, admin!\"}\n</code></pre>"},{"location":"api/#app.routes.user_routes.login","title":"<code>app.routes.user_routes.login(form_data=Depends())</code>  <code>async</code>","text":"<p>Authenticate user &amp; return a JWT token</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>OAuth2PasswordRequestForm</code> <p>User-provided login credentials</p> <code>Depends()</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the access token &amp; token type</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If the username or password is incorrect</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.post(\"/token\")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"\n    Authenticate user &amp; return a JWT token\n\n    Args:\n        form_data (OAuth2PasswordRequestForm): User-provided login credentials\n\n    Returns:\n        dict: A dictionary containing the access token &amp; token type\n\n    Raises:\n        HTTPException (400): If the username or password is incorrect\n    \"\"\"\n    user = users_collection.find_one({\"email\": form_data.username})\n    if not user or not verify_password(form_data.password, user[\"password_hash\"]):\n        raise HTTPException(status_code = 400, detail = \"Invalid username or password\")\n\n    access_token = create_access_token(\n        data = {\"sub\": user[\"email\"], \"role\": user.get(\"role\", \"user\")},\n        expires_delta = timedelta(minutes = 30)\n    )\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"api/#app.routes.user_routes.register_user","title":"<code>app.routes.user_routes.register_user(user)</code>  <code>async</code>","text":"<p>Register a new user in the database</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserCreate</code> <p>User registration data including email, password &amp; optional role</p> required <p>Returns:</p> Name Type Description <code>UserResponse</code> <p>The created user information excluding password</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If the email is already registered</p> <code>HTTPException(500)</code> <p>If there is an error inserted the user into the database</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.post(\"/register\", response_model = UserResponse)\nasync def register_user(user: UserCreate):\n    \"\"\"\n    Register a new user in the database\n\n    Args:\n        user (UserCreate): User registration data including email, password &amp; optional role\n\n    Returns:\n        UserResponse: The created user information excluding password\n\n    Raises:\n        HTTPException (400): If the email is already registered\n        HTTPException (500): If there is an error inserted the user into the database\n    \"\"\"\n    # Check if email exists already\n    if users_collection.find_one({\"email\": user.email}):\n        raise HTTPException(status_code = 400, detail = \"Registration failed, please try again.\")\n\n    # Prepare user data for insertion\n    user_data = {\n        \"email\": user.email,\n        \"password_hash\": hash_password(user.password),\n        \"is_verified\": False,\n        \"created_at\": datetime.now(timezone.utc),\n        \"updated_at\": datetime.now(timezone.utc),\n        \"role\": user.role or \"user\"\n    }\n\n    # Database user insert\n    try:\n        result = users_collection.insert_one(user_data)\n    except Exception as e:\n        raise HTTPException(status_code = 500, detail = f\"Failed to register user: {e}\") from e\n\n    return UserResponse(\n        id = str(result.inserted_id),\n        role = user_data[\"role\"],\n        email = user.email,\n        is_verified = False,\n        created_at = user_data[\"created_at\"]\n    )\n</code></pre>"},{"location":"api/#app.routes.data_routes","title":"<code>app.routes.data_routes</code>","text":"<p>This module defines API routes for managing &amp; retrieving energy consumption data</p> <p>It includes: - An endpoint for adding new energy data (admin-only access) - An endpoint for fetching aggregated energy consumption data with filtering options - An admin dashboard route (restricted to users with an \"admin\" role)</p>"},{"location":"api/#app.routes.data_routes.add_energy_data","title":"<code>app.routes.data_routes.add_energy_data(data)</code>  <code>async</code>","text":"<p>Add new energy consumption data to the database (admin-only)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EnergyData</code> <p>The energy data record to be added</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A confirmation message upon successfully insertion</p> Source code in <code>app/routes/data_routes.py</code> <pre><code>@router.post(\"/add\", dependencies = [Depends(role_required(\"admin\"))])\nasync def add_energy_data(data: EnergyData):\n    \"\"\"\n    Add new energy consumption data to the database (admin-only)\n\n    Args:\n        data (EnergyData): The energy data record to be added\n\n    Returns:\n        dict: A confirmation message upon successfully insertion\n    \"\"\"\n    energy_collection.insert_one(data.model_dump())       # Insert into MongoDB\n    return {\"message\": \"Energy data added successfully\"}\n</code></pre>"},{"location":"api/#app.routes.data_routes.get_admin_dashboard","title":"<code>app.routes.data_routes.get_admin_dashboard()</code>  <code>async</code>","text":"<p>Admin dashboard endpoint (restricted access)</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A welcome message confirming admin access</p> Source code in <code>app/routes/data_routes.py</code> <pre><code>@router.get(\"/admin/dashboard\", dependencies = [Depends(role_required(\"admin\"))])\nasync def get_admin_dashboard():\n    \"\"\"\n    Admin dashboard endpoint (restricted access)\n\n    Returns:\n        dict: A welcome message confirming admin access\n    \"\"\"\n    return {\"message\": \"Welcome, admin!\"}\n</code></pre>"},{"location":"api/#app.routes.data_routes.get_aggregated_data","title":"<code>app.routes.data_routes.get_aggregated_data(start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'), device_id=Query(None, description='Device ID filter'), location=Query(None, description='Location filter'), interval='day')</code>  <code>async</code>","text":"<p>Retrieve aggregated energy consumption data based on time interval &amp; filters</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[str]</code> <p>The start date for filtering (YYYY-MM-DD)</p> <code>Query(None, description='Start date (YYYY-MM-DD)')</code> <code>end_date</code> <code>Optional[str]</code> <p>The end date for filtering (YYYY-MM-DD)</p> <code>Query(None, description='End date (YYYY-MM-DD)')</code> <code>device_id</code> <code>Optional[str]</code> <p>The ID of the device to filter data</p> <code>Query(None, description='Device ID filter')</code> <code>location</code> <code>Optional[str]</code> <p>The location filter</p> <code>Query(None, description='Location filter')</code> <code>interval</code> <code>Literal['hour', 'day', 'week']</code> <p>The time interval for aggregation (defaults to \"day\")</p> <code>'day'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Aggregated energy consumption data grouped by the selected interval</p> Source code in <code>app/routes/data_routes.py</code> <pre><code>@router.get(\"/aggregate\")\nasync def get_aggregated_data(\n    start_date: Optional[str] = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n    end_date: Optional[str] = Query(None, description = \"End date (YYYY-MM-DD)\"),\n    device_id: Optional[str] = Query(None, description = \"Device ID filter\"),\n    location: Optional[str] = Query(None, description = \"Location filter\"),\n    interval: Literal[\"hour\", \"day\", \"week\"] = \"day\",\n):\n    \"\"\"\n    Retrieve aggregated energy consumption data based on time interval &amp; filters\n\n    Args:\n        start_date (Optional[str]): The start date for filtering (YYYY-MM-DD)\n        end_date (Optional[str]): The end date for filtering (YYYY-MM-DD)\n        device_id (Optional[str]): The ID of the device to filter data\n        location (Optional[str]): The location filter\n        interval (Literal[\"hour\", \"day\", \"week\"]): The time interval for aggregation (defaults to \"day\")\n\n    Returns:\n        dict: Aggregated energy consumption data grouped by the selected interval\n    \"\"\"\n    query = {}\n\n    if start_date and end_date:\n        query[\"timestamp\"] = {\n            \"$gte\": datetime.strptime(start_date, \"%Y-%m-%d\"),\n            \"$lte\": datetime.strptime(end_date, \"%Y-%m-%d\")\n        }\n    if device_id:\n        query[\"device_id\"] = device_id\n    if location:\n        query[\"location\"] = location\n\n    time_group = {\n        \"year\": {\"$year\": \"$timestamp\"},\n        \"month\": {\"$month\": \"$timestamp\"},\n        \"day\": {\"$dayOfMonth\": \"$timestamp\"}\n    }\n\n    if interval == \"hour\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"month\": {\"$month\": \"$timestamp\"},\n            \"day\": {\"$dayOfMonth\": \"$timestamp\"},\n            \"hour\": {\"$hour\": \"$timestamp\"}\n        }\n    elif interval == \"day\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"month\": {\"$month\": \"$timestamp\"},\n            \"day\": {\"$dayOfMonth\": \"$timestamp\"}\n        }\n    elif interval == \"week\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"week\": {\"$isoWeek\": \"$timestamp\"}\n        }\n\n    aggregation_pipeline = [\n        {\"$match\": query},\n        {\"$group\": {\n            \"_id\": {\n                \"device_id\": \"$device_id\",  # Group by device\n                **time_group                # Group by time interval\n            }, \"total_energy\": {\"$sum\": \"$energy_consumed\"}\n        }}\n    ]\n\n    result = list(energy_collection.aggregate(aggregation_pipeline))\n\n    return {\"aggregated_data\": result}\n</code></pre>"},{"location":"api/#app.routes.report_routes","title":"<code>app.routes.report_routes</code>","text":"<p>This module provides API endpoints for generating energy consumption reports</p> <p>It includes: - An endpoint to generate reports in CSV or PDF format, optionally filtered by a data range - Reports are stored in the <code>generated_reports</code> directory</p>"},{"location":"api/#app.routes.report_routes.generate_report","title":"<code>app.routes.report_routes.generate_report(format=Query('csv', enum=['csv', 'pdf']), start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'))</code>  <code>async</code>","text":"<p>Generate an energy consumption report in CSV or PDF format</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>The desired report format, either \"csv\" or \"pdf\"</p> <code>Query('csv', enum=['csv', 'pdf'])</code> <code>start_date</code> <code>str</code> <p>The start date for filtering data (YYYY-MM-DD)</p> <code>Query(None, description='Start date (YYYY-MM-DD)')</code> <code>end_date</code> <code>str</code> <p>The end date for filtering data (YYYY-MM-DD)</p> <code>Query(None, description='End date (YYYY-MM-DD)')</code> <p>Returns:</p> Name Type Description <code>FileResponse</code> <p>The generated report file</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If an invalid date format is provided</p> <code>HTTPException(404)</code> <p>If no energy data is available for the selected range</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.post(\"/report\", dependencies = [Depends(role_required(\"admin\"))])\nasync def generate_report(\n        format: str = Query(\"csv\", enum = [\"csv\", \"pdf\"]),\n        start_date: str = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n        end_date: str = Query(None, description = \"End date (YYYY-MM-DD)\")\n):\n    \"\"\"\n    Generate an energy consumption report in CSV or PDF format\n\n    Args:\n        format (str): The desired report format, either \"csv\" or \"pdf\"\n        start_date (str, optional): The start date for filtering data (YYYY-MM-DD)\n        end_date (str, optional): The end date for filtering data (YYYY-MM-DD)\n\n    Returns:\n        FileResponse: The generated report file\n\n    Raises:\n        HTTPException (400): If an invalid date format is provided\n        HTTPException (404): If no energy data is available for the selected range\n    \"\"\"\n    try:\n        energy_data = get_energy_data(start_date, end_date)\n    except ValueError as exc:\n        raise HTTPException(status_code = 400, detail = str(exc)) from exc\n\n    if not energy_data:\n        raise HTTPException(status_code = 404, detail = \"No energy data available for the selected range.\")\n\n    timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.{format}\"\n\n    if format == \"csv\":\n        # Convert data to a DataFrame &amp; format timestamps\n        df = pd.DataFrame(energy_data)\n        df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"]).dt.strftime(\"%Y-%m-%d %H:%M:%S\")  # Format timestamp\n        df.columns = [\"Device ID\", \"Timestamp\", \"Energy Consumed (kWh)\", \"Location\"]\n        df.to_csv(filename, index = False)\n    elif format == \"pdf\":\n        # Create a PDF report with a structure table\n        doc = SimpleDocTemplate(filename, pagesize=letter)\n        elements = []\n\n        # Prepare table data\n        data = [[\"Device ID\", \"Timestamp\", \"Energy Cosumed (kWh)\", \"Location\"]]\n        for entry in energy_data:\n            data.append([\n                entry.get(\"device_id\", \"N/A\"),\n                entry.get(\"timestamp\", \"\").strftime('%Y-%m-%d %H:%M:%S') if entry.get(\"timestamp\") else \"N/A\",\n                entry.get(\"energy_consumed\", \"N/A\"),\n                entry.get(\"location\", \"N/A\")\n            ])\n\n        # Create &amp; style table\n        table = Table(data)\n        table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, 0), 12),\n            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.whitesmoke, colors.lightgrey])\n        ]))\n\n        elements.append(table)\n        doc.build(elements)\n\n    return FileResponse(\n        path  = os.path.abspath(filename),\n        filename = os.path.basename(filename),\n        media_type = \"application/octet-stream\"\n    )\n</code></pre>"},{"location":"api/#app.models.user","title":"<code>app.models.user</code>","text":"<p>This model defines user-related data models for account creation &amp; response handling</p> <p>It includes: - <code>UserCreate</code>: A model for user registration input with email &amp; password validation - <code>UserResponse</code>: A model for returning user details in API responses</p>"},{"location":"api/#app.models.user.UserCreate","title":"<code>app.models.user.UserCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for user registration input</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>EmailStr</code> <p>The user's email address</p> <code>password</code> <code>str</code> <p>The user's password (validated for strength)</p> <code>role</code> <code>Optional[str]</code> <p>The user's role, defaulting to \"user\"</p> Source code in <code>app/models/user.py</code> <pre><code>class UserCreate(BaseModel):\n    '''\n    Pydantic model for user registration input\n\n    Attributes:\n        email (EmailStr): The user's email address\n        password (str): The user's password (validated for strength)\n        role (Optional[str]): The user's role, defaulting to \"user\"\n    '''\n    email: EmailStr\n    password: str\n    role: Optional[str] = \"user\"    # Default role\n\n    @field_validator(\"password\")\n    @classmethod\n    def validate_password(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the password to ensure it meets security requirements\n\n        Args:\n            value (str): The password provided by the user\n\n        Returns:\n            str: The validated password\n\n        Raises:\n            ValueError: If the password doesn't meet security requirements\n        \"\"\"\n        if len(value) &lt; 8:\n            raise ValueError(\"Password must be at least 8 characters long.\")\n        if not any(char.isdigit() for char in value):\n            raise ValueError(\"Password must contain at least 1 number.\")\n        if not any(char.isalpha() for char in value):\n            raise ValueError(\"Password must contain at least 1 letter.\")\n        if not any(char.islower() for char in value):\n            raise ValueError(\"Password must contain at least 1 lower letter.\")\n        if not any(char.isupper() for char in value):\n            raise ValueError(\"Password must contain at least 1 upper letter.\")\n        if not any(char in '!@#$%^&amp;*()_+-=[]{}|;\\':\",.&lt;&gt;?/' for char in value):\n            raise ValueError(\"Password must contain at least 1 special character.\")\n        return value\n\n    @field_validator(\"email\")\n    @classmethod\n    def validate_email(cls, value: EmailStr) -&gt; EmailStr:\n        \"\"\"\n        Validate the user's email address\n\n        Args:\n            value (EmailStr): The email address provided\n\n        Returns:\n            EmailStr: The validated email\n\n        Raises:\n            ValueError: If the email doesn't contain `@` or a valid domain\n        \"\"\"\n        if not \"@\" in value:\n            raise ValueError(\"Email must contain @.\")\n        if not \".\" in value.split(\"@\")[1]:\n            raise ValueError(\"Email must contain a dot.\")\n        return value\n</code></pre>"},{"location":"api/#app.models.user.UserCreate.validate_email","title":"<code>app.models.user.UserCreate.validate_email(value)</code>  <code>classmethod</code>","text":"<p>Validate the user's email address</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>EmailStr</code> <p>The email address provided</p> required <p>Returns:</p> Name Type Description <code>EmailStr</code> <code>EmailStr</code> <p>The validated email</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the email doesn't contain <code>@</code> or a valid domain</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"email\")\n@classmethod\ndef validate_email(cls, value: EmailStr) -&gt; EmailStr:\n    \"\"\"\n    Validate the user's email address\n\n    Args:\n        value (EmailStr): The email address provided\n\n    Returns:\n        EmailStr: The validated email\n\n    Raises:\n        ValueError: If the email doesn't contain `@` or a valid domain\n    \"\"\"\n    if not \"@\" in value:\n        raise ValueError(\"Email must contain @.\")\n    if not \".\" in value.split(\"@\")[1]:\n        raise ValueError(\"Email must contain a dot.\")\n    return value\n</code></pre>"},{"location":"api/#app.models.user.UserCreate.validate_password","title":"<code>app.models.user.UserCreate.validate_password(value)</code>  <code>classmethod</code>","text":"<p>Validate the password to ensure it meets security requirements</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The password provided by the user</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated password</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the password doesn't meet security requirements</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"password\")\n@classmethod\ndef validate_password(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the password to ensure it meets security requirements\n\n    Args:\n        value (str): The password provided by the user\n\n    Returns:\n        str: The validated password\n\n    Raises:\n        ValueError: If the password doesn't meet security requirements\n    \"\"\"\n    if len(value) &lt; 8:\n        raise ValueError(\"Password must be at least 8 characters long.\")\n    if not any(char.isdigit() for char in value):\n        raise ValueError(\"Password must contain at least 1 number.\")\n    if not any(char.isalpha() for char in value):\n        raise ValueError(\"Password must contain at least 1 letter.\")\n    if not any(char.islower() for char in value):\n        raise ValueError(\"Password must contain at least 1 lower letter.\")\n    if not any(char.isupper() for char in value):\n        raise ValueError(\"Password must contain at least 1 upper letter.\")\n    if not any(char in '!@#$%^&amp;*()_+-=[]{}|;\\':\",.&lt;&gt;?/' for char in value):\n        raise ValueError(\"Password must contain at least 1 special character.\")\n    return value\n</code></pre>"},{"location":"api/#app.models.user.UserResponse","title":"<code>app.models.user.UserResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for user response data</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the user</p> <code>role</code> <code>str</code> <p>The assigned role of the user</p> <code>email</code> <code>EmailStr</code> <p>The user's email address</p> <code>is_verified</code> <code>bool</code> <p>Indicates whether the user's email address is verified (defaults to False)</p> <code>created_at</code> <code>Optional[datetime]</code> <p>Timestamp of the user account creation</p> Source code in <code>app/models/user.py</code> <pre><code>class UserResponse(BaseModel):\n    \"\"\"\n    Pydantic model for user response data\n\n    Attributes:\n        id (str): Unique identifier for the user\n        role (str): The assigned role of the user\n        email (EmailStr): The user's email address\n        is_verified (bool): Indicates whether the user's email address is verified (defaults to False)\n        created_at (Optional[datetime]): Timestamp of the user account creation\n    \"\"\"\n    id: str\n    role: str\n    email: EmailStr\n    is_verified: bool = False\n    created_at: Optional[datetime]\n\n    model_config = ConfigDict(from_attributes = True)\n</code></pre>"},{"location":"api/#app.models.energy_data","title":"<code>app.models.energy_data</code>","text":"<p>This module defines the EnergyData model used for storing energy consumption records</p> <p>The model: - Represents energy consumption data for a specific device - Includes metadata such as timestamp &amp; location</p>"},{"location":"api/#app.models.energy_data.EnergyData","title":"<code>app.models.energy_data.EnergyData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing energy consumption data for a smart device</p> <p>Attributes:</p> Name Type Description <code>device_id</code> <code>str</code> <p>Unique identifier for the device</p> <code>timestamp</code> <code>datetime</code> <p>The date &amp; time of the recorded energy consumption</p> <code>energy_consumed</code> <code>float</code> <p>The amount of energy consumed in kilowatt-hours (kWh)</p> <code>location</code> <code>Optional[str]</code> <p>The optional physical location of the device</p> Source code in <code>app/models/energy_data.py</code> <pre><code>class EnergyData(BaseModel):\n    \"\"\"\n    Pydantic model representing energy consumption data for a smart device\n\n    Attributes:\n        device_id (str): Unique identifier for the device\n        timestamp (datetime): The date &amp; time of the recorded energy consumption\n        energy_consumed (float): The amount of energy consumed in kilowatt-hours (kWh)\n        location (Optional[str]): The optional physical location of the device\n    \"\"\"\n    device_id: str\n    timestamp: datetime\n    energy_consumed: float          # tracking in kWh (kilowatt hours)\n    location: Optional[str] = None\n</code></pre>"},{"location":"api/#app.db.database","title":"<code>app.db.database</code>","text":"<p>This module handles MongoDB database connections &amp; operations</p> <p>It provides: - Initialization of MongoDB collections &amp; indexes - Functions to fetch energy consumption data with optional filtering</p>"},{"location":"api/#app.db.database.get_energy_data","title":"<code>app.db.database.get_energy_data(start_date=None, end_date=None)</code>","text":"<p>Fetch energy data consumption from MongoDB with optional date filtering</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Start date in <code>YYYY-MM-DD</code> format</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date in <code>YYYY-MM-DD</code> format</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of energy consumption records</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided date format is incorrect</p> Source code in <code>app/db/database.py</code> <pre><code>def get_energy_data(start_date: str = None, end_date: str = None) -&gt; List[Dict]:\n    \"\"\"\n    Fetch energy data consumption from MongoDB with optional date filtering\n\n    Args:\n        start_date (str, optional): Start date in `YYYY-MM-DD` format\n        end_date (str, optional): End date in `YYYY-MM-DD` format\n\n    Returns:\n        List[Dict]: A list of energy consumption records\n\n    Raises:\n        ValueError: If the provided date format is incorrect\n    \"\"\"\n    query = {}\n\n    if start_date and end_date:\n        try:\n            start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n            end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n            query[\"timestamp\"] = {\"$gte\": start_dt, \"$lte\": end_dt}\n        except ValueError as exc:\n            raise ValueError(\"Invalid date format. Use `YYYY-MM-DD`.\") from exc\n\n    energy_data = list(energy_collection.find(query, {\"_id\": 0}))   # Exclude MongoDB _id field\n\n    return energy_data\n</code></pre>"},{"location":"api/#app.db.database.init_db","title":"<code>app.db.database.init_db()</code>  <code>async</code>","text":"<p>Initialize the database by creating necessary indexes</p> <p>This function ensures: - Unique email constraint for users - Indexes on <code>device_id</code> &amp; <code>timestamp</code> in the energy collection for optimized queries</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is an error during database initialization</p> Source code in <code>app/db/database.py</code> <pre><code>async def init_db():\n    \"\"\"\n    Initialize the database by creating necessary indexes\n\n    This function ensures:\n    - Unique email constraint for users\n    - Indexes on `device_id` &amp; `timestamp` in the energy collection for optimized queries\n\n    Raises:\n        RuntimeError: If there is an error during database initialization\n    \"\"\"\n    try:\n        # Create uniqueness of user emails\n        users_collection.create_index(\"email\", unique = True)\n\n        # Optimize queries by creating indexes on frequently queried fields\n        energy_collection.create_index(\"device_id\")\n        energy_collection.create_index(\"timestamp\")\n\n        print(\"Database initialized successfully.\")\n    except Exception as e:\n        raise RuntimeError(f\"Error during database initialization: {e}\") from e\n</code></pre>"},{"location":"api/#app.core.config","title":"<code>app.core.config</code>","text":""},{"location":"api/#app.core.security","title":"<code>app.core.security</code>","text":"<p>This module implements security features</p> <p>Features include: - Password hashing - JWT token creation &amp; verification - Role-based access control</p>"},{"location":"api/#app.core.security.create_access_token","title":"<code>app.core.security.create_access_token(data, expires_delta=None)</code>","text":"<p>Create a JWT token with an expiration time</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The payload to encode in the token</p> required <code>expires_delta</code> <code>Optional[timedelta]</code> <p>The expiration time delta Defaults to <code>ACCESS_TOKEN_EXPIRE_MINUTES</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The encoded JWT token</p> Source code in <code>app/core/security.py</code> <pre><code>def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"\n    Create a JWT token with an expiration time\n\n    Args:\n        data (dict): The payload to encode in the token\n        expires_delta (Optional[timedelta], optional): The expiration time delta\n            Defaults to `ACCESS_TOKEN_EXPIRE_MINUTES`\n\n    Returns:\n        str: The encoded JWT token\n    \"\"\"\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes = ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM)\n</code></pre>"},{"location":"api/#app.core.security.get_current_user","title":"<code>app.core.security.get_current_user(token=Depends(oauth2_scheme))</code>","text":"<p>Extract &amp; validate the current user's JWT token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The OAuth2 token obtained from authentication</p> <code>Depends(oauth2_scheme)</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The decoded token payload</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the token is invalid or missing required fields</p> Source code in <code>app/core/security.py</code> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)) -&gt; dict:\n    \"\"\"\n    Extract &amp; validate the current user's JWT token\n\n    Args:\n        token (str): The OAuth2 token obtained from authentication\n\n    Returns:\n        dict: The decoded token payload\n\n    Raises:\n        HTTPException: If the token is invalid or missing required fields\n    \"\"\"\n    payload = verify_access_token(token)\n    if not payload or \"role\" not in payload:\n        raise HTTPException(status_code = status.HTTP_401_UNAUTHORIZED, detail = \"Invalid token\")\n    return payload\n</code></pre>"},{"location":"api/#app.core.security.hash_password","title":"<code>app.core.security.hash_password(password)</code>","text":"<p>Hash a plain-text password using bcrypt</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to hash</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hashed password</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs during hashing</p> Source code in <code>app/core/security.py</code> <pre><code>def hash_password(password: str) -&gt; str:\n    \"\"\"\n    Hash a plain-text password using bcrypt\n\n    Args:\n        password (str): The password to hash\n\n    Returns:\n        str: The hashed password\n\n    Raises:\n        ValueError: If an error occurs during hashing\n    \"\"\"\n    try:\n        return pwd_context.hash(password)\n    except Exception as e:\n        raise ValueError(f\"Error hashing password: {e}\") from e\n</code></pre>"},{"location":"api/#app.core.security.needs_rehash","title":"<code>app.core.security.needs_rehash(hashed_password)</code>","text":"<p>Check if a stored hashed password required rehashing</p> <p>Parameters:</p> Name Type Description Default <code>hashed_password</code> <code>str</code> <p>The existing hashed password</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if rehashing is required &amp; False if otherwise</p> Source code in <code>app/core/security.py</code> <pre><code>def needs_rehash(hashed_password: str) -&gt; bool:\n    \"\"\"\n    Check if a stored hashed password required rehashing\n\n    Args:\n        hashed_password (str): The existing hashed password\n\n    Returns:\n        bool: True if rehashing is required &amp; False if otherwise\n    \"\"\"\n    return pwd_context.needs_update(hashed_password)\n</code></pre>"},{"location":"api/#app.core.security.role_required","title":"<code>app.core.security.role_required(required_role)</code>","text":"<p>Dependency function to check to enforce role-based access control</p> <p>Parameters:</p> Name Type Description Default <code>required_role</code> <code>str</code> <p>The required user role</p> required <p>Returns:</p> Name Type Description <code>function</code> <p>A dependency function that verifies the user's role</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user lacks the required role</p> Source code in <code>app/core/security.py</code> <pre><code>def role_required(required_role: str):\n    \"\"\"\n    Dependency function to check to enforce role-based access control\n\n    Args:\n        required_role (str): The required user role\n\n    Returns:\n        function: A dependency function that verifies the user's role\n\n    Raises:\n        HTTPException: If the user lacks the required role\n    \"\"\"\n    def role_checker(current_user: dict = Depends(get_current_user)):\n        if current_user.get(\"role\") != required_role:\n            raise HTTPException(\n                status_code = status.HTTP_403_FORBIDDEN,\n                detail = f\"Permission denied: {required_role} role required\"\n            )\n        return current_user\n    return role_checker\n</code></pre>"},{"location":"api/#app.core.security.verify_access_token","title":"<code>app.core.security.verify_access_token(token)</code>","text":"<p>Verify &amp; decode a JWT access token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token to verify</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: The decoded token payload if valid, otherwise None</p> Source code in <code>app/core/security.py</code> <pre><code>def verify_access_token(token: str) -&gt; Optional[dict]:\n    \"\"\"\n    Verify &amp; decode a JWT access token\n\n    Args:\n        token (str): The JWT token to verify\n\n    Returns:\n        Optional[dict]: The decoded token payload if valid, otherwise None\n    \"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms = [ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n</code></pre>"},{"location":"api/#app.core.security.verify_password","title":"<code>app.core.security.verify_password(plain_password, hashed_password)</code>","text":"<p>Verify a plain-text password against a hashed password</p> <p>Parameters:</p> Name Type Description Default <code>plain_password</code> <code>str</code> <p>The input password</p> required <code>hashed_password</code> <code>str</code> <p>The stored hashed password</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the password matches &amp; False if otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs during verification</p> Source code in <code>app/core/security.py</code> <pre><code>def verify_password(plain_password: str, hashed_password: str) -&gt; bool:\n    \"\"\"\n    Verify a plain-text password against a hashed password\n\n    Args:\n        plain_password (str): The input password\n        hashed_password (str): The stored hashed password\n\n    Returns:\n        bool: True if the password matches &amp; False if otherwise\n\n    Raises:\n        ValueError: If an error occurs during verification\n    \"\"\"\n    try:\n        return pwd_context.verify(plain_password, hashed_password)\n    except Exception as e:\n        raise ValueError(f\"Error verifying password: {e}\") from e\n</code></pre>"}]}