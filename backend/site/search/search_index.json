{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sync Smart Home API Documentation","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#app.main","title":"<code>app.main</code>","text":"<p>Main application entry point for the smart home API.</p>"},{"location":"api/#app.main.root","title":"<code>app.main.root()</code>  <code>async</code>","text":"<p>API health check endpoint.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/\")\nasync def root():\n    \"\"\"\n    API health check endpoint.\n    \"\"\"\n    return {\n        \"status\": \"online\",\n        \"message\": \"Sync Smart Home API is running\",\n        \"version\": \"1.0.0\"\n    }\n</code></pre>"},{"location":"api/#app.main.startup_event","title":"<code>app.main.startup_event()</code>","text":"<p>Initialize database on startup.</p> Source code in <code>app/main.py</code> <pre><code>@app.on_event(\"startup\")\ndef startup_event():\n    \"\"\"Initialize database on startup.\"\"\"\n    init_db()\n\n    # Create reports directory if it doesn't exist\n    import os\n    from app.utils.report.report_generator import REPORTS_DIR\n    os.makedirs(REPORTS_DIR, exist_ok=True)\n</code></pre>"},{"location":"api/#app.generate_report","title":"<code>app.generate_report</code>","text":"<p>CLI script to generate energy reports directly from the command line.</p>"},{"location":"api/#app.generate_report.get_user_devices","title":"<code>app.generate_report.get_user_devices(user_id)</code>","text":"<p>Get all devices for a user.</p> Source code in <code>app/generate_report.py</code> <pre><code>def get_user_devices(user_id):\n    \"\"\"Get all devices for a user.\"\"\"\n    devices = list(d_c.find({\"user_id\": user_id}))\n    return devices\n</code></pre>"},{"location":"api/#app.generate_report.main","title":"<code>app.generate_report.main()</code>","text":"<p>Generate a report based on command line arguments.</p> Source code in <code>app/generate_report.py</code> <pre><code>def main():\n    \"\"\"Generate a report based on command line arguments.\"\"\"\n    args = parse_args()\n\n    # Validate user\n    user = validate_user_id(args.user_id)\n    print(f\"Generating report for user: {user.get('username', user.get('email', 'Unknown'))}\")\n\n    # Determine date range\n    if args.historical:\n        # Use March 2024 dates where we know data exists\n        end_date = datetime(2024, 3, 19)  # Latest record date\n        start_date = end_date - timedelta(days=args.days)\n        print(\"Using historical data period (March 2024)\")\n    else:\n        # Use current dates\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=args.days)\n        print(\"Using current date period\")\n\n    start_date_str = start_date.strftime(\"%Y-%m-%d\")\n    end_date_str = end_date.strftime(\"%Y-%m-%d\")\n    print(f\"Date range: {start_date_str} to {end_date_str}\")\n\n    # Get device IDs if not specified\n    device_ids = args.device_ids\n    if not device_ids:\n        devices = get_user_devices(args.user_id)\n        device_ids = [device[\"id\"] for device in devices]\n        print(f\"Using all devices ({len(device_ids)}) for the user\")\n    else:\n        print(f\"Using specified devices: {', '.join(device_ids)}\")\n\n    # Create a title if not specified\n    title = args.title\n    if not title:\n        title = f\"Energy Report ({start_date_str} to {end_date_str})\"\n\n    # Generate a UUID for the report\n    report_uuid = str(uuid.uuid4())\n\n    # Create report object\n    report_db = ReportDB(\n        id=report_uuid,\n        user_id=args.user_id,\n        title=title,\n        format=args.format.lower(),\n        report_type=args.report_type,\n        start_date=start_date_str,\n        end_date=end_date_str,\n        device_ids=device_ids,\n        status=\"pending\"\n    )\n\n    # Create report in database\n    print(\"Creating report record...\")\n    mongo_id = ReportService.create_report(report_db)\n    print(f\"Report record created with MongoDB ID: {mongo_id}\")\n    print(f\"Report UUID: {report_uuid}\")\n\n    # Generate the report using the UUID we assigned\n    print(\"Generating report...\")\n    success, file_path, error = ReportService.generate_report(report_uuid)\n\n    if success and file_path:\n        print(f\"Report successfully generated!\")\n        print(f\"Report file: {file_path}\")\n    else:\n        print(f\"Error generating report: {error}\")\n</code></pre>"},{"location":"api/#app.generate_report.parse_args","title":"<code>app.generate_report.parse_args()</code>","text":"<p>Parse command line arguments.</p> Source code in <code>app/generate_report.py</code> <pre><code>def parse_args():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Generate energy usage reports\")\n\n    parser.add_argument(\"--user_id\", required=True, help=\"User ID to generate report for\")\n    parser.add_argument(\"--format\", choices=[\"pdf\", \"csv\"], default=\"pdf\", help=\"Report format\")\n    parser.add_argument(\"--days\", type=int, default=30, help=\"Number of days to include in report\")\n    parser.add_argument(\"--title\", help=\"Report title\")\n    parser.add_argument(\"--device_ids\", nargs=\"+\", help=\"Specific device IDs to include (space-separated)\")\n    parser.add_argument(\"--report_type\", default=\"energy\", help=\"Report type (default: energy)\")\n    parser.add_argument(\"--historical\", action=\"store_true\", help=\"Use historical data (March 2024)\")\n\n    return parser.parse_args()\n</code></pre>"},{"location":"api/#app.generate_report.validate_user_id","title":"<code>app.generate_report.validate_user_id(user_id)</code>","text":"<p>Check if the user exists in the database.</p> Source code in <code>app/generate_report.py</code> <pre><code>def validate_user_id(user_id):\n    \"\"\"Check if the user exists in the database.\"\"\"\n    user = u_c.find_one({\"id\": user_id})\n    if not user:\n        print(f\"Error: User with ID {user_id} not found.\")\n        sys.exit(1)\n    return user\n</code></pre>"},{"location":"api/#app.data_util","title":"<code>app.data_util</code>","text":"<p>Utility to check for usage data and optionally generate test data.</p>"},{"location":"api/#app.data_util.check_usage_data","title":"<code>app.data_util.check_usage_data(user_id, days=30)</code>","text":"<p>Check if usage data exists for a user's devices.</p> Source code in <code>app/data_util.py</code> <pre><code>def check_usage_data(user_id, days=30):\n    \"\"\"Check if usage data exists for a user's devices.\"\"\"\n    # Get devices for the user\n    devices = list(d_c.find({\"user_id\": user_id}))\n    device_ids = [device[\"id\"] for device in devices]\n\n    if not device_ids:\n        print(f\"No devices found for user {user_id}\")\n        return False\n\n    print(f\"Found {len(device_ids)} devices for user {user_id}\")\n\n    # Check for usage data within the specified time range\n    end_date = datetime.now()\n    start_date = end_date - timedelta(days=days)\n\n    query = {\n        \"device_id\": {\"$in\": device_ids},\n        \"timestamp\": {\n            \"$gte\": start_date,\n            \"$lte\": end_date\n        }\n    }\n\n    count = us_c.count_documents(query)\n\n    if count &gt; 0:\n        print(f\"Found {count} usage records in the last {days} days\")\n        return True\n    else:\n        print(f\"No usage records found in the last {days} days\")\n        # Check if there's any usage data at all for these devices\n        all_time_count = us_c.count_documents({\"device_id\": {\"$in\": device_ids}})\n        if all_time_count &gt; 0:\n            print(f\"Found {all_time_count} usage records for these devices across all time\")\n            # Show the earliest and latest records\n            earliest = us_c.find({\"device_id\": {\"$in\": device_ids}}).sort(\"timestamp\", 1).limit(1)\n            latest = us_c.find({\"device_id\": {\"$in\": device_ids}}).sort(\"timestamp\", -1).limit(1)\n\n            earliest_list = list(earliest)\n            latest_list = list(latest)\n\n            if earliest_list:\n                print(f\"Earliest record: {earliest_list[0].get('timestamp')}\")\n            if latest_list:\n                print(f\"Latest record: {latest_list[0].get('timestamp')}\")\n        else:\n            print(\"No usage records found for these devices at all\")\n        return False\n</code></pre>"},{"location":"api/#app.data_util.generate_test_data","title":"<code>app.data_util.generate_test_data(user_id, days=30, records_per_device=5)</code>","text":"<p>Generate test usage data for a user's devices.</p> Source code in <code>app/data_util.py</code> <pre><code>def generate_test_data(user_id, days=30, records_per_device=5):\n    \"\"\"Generate test usage data for a user's devices.\"\"\"\n    # Get devices for the user\n    devices = list(d_c.find({\"user_id\": user_id}))\n\n    if not devices:\n        print(f\"No devices found for user {user_id}\")\n        return False\n\n    print(f\"Generating test data for {len(devices)} devices\")\n\n    # Generate data\n    end_date = datetime.now()\n    start_date = end_date - timedelta(days=days)\n\n    generated_count = 0\n\n    for device in devices:\n        device_id = device[\"id\"]\n        device_name = device.get(\"name\", \"Unknown Device\")\n\n        for _ in range(records_per_device):\n            # Generate a random timestamp in the date range\n            random_days = random.randint(0, days)\n            timestamp = end_date - timedelta(days=random_days)\n\n            # Generate random energy consumption (0.1 to 5.0 kWh)\n            energy_consumed = round(random.uniform(0.1, 5.0), 2)\n\n            # Generate random duration (10 to 480 minutes)\n            duration = random.randint(10, 480)\n\n            # Create usage record\n            usage_record = {\n                \"id\": str(uuid.uuid4()),\n                \"device_id\": device_id,\n                \"timestamp\": timestamp,\n                \"energy_consumed\": energy_consumed,\n                \"duration\": duration,\n                \"status\": random.choice([\"active\", \"idle\"]),\n                \"metrics\": {\n                    \"temperature\": round(random.uniform(18, 28), 1) if random.random() &gt; 0.5 else None,\n                    \"brightness\": random.randint(10, 100) if \"light\" in device_name.lower() else None,\n                    \"usage_minutes\": duration\n                },\n                \"created\": timestamp\n            }\n\n            # Insert into the database\n            us_c.insert_one(usage_record)\n            generated_count += 1\n\n    print(f\"Generated {generated_count} test usage records\")\n    return True\n</code></pre>"},{"location":"api/#app.inspect_data","title":"<code>app.inspect_data</code>","text":"<p>Script to inspect and fix usage data for generating reports.</p>"},{"location":"api/#app.inspect_data.inspect_usage_data","title":"<code>app.inspect_data.inspect_usage_data(user_id, start_date, end_date)</code>","text":"<p>Inspect usage data for a user in a specific date range.</p> Source code in <code>app/inspect_data.py</code> <pre><code>def inspect_usage_data(user_id, start_date, end_date):\n    \"\"\"Inspect usage data for a user in a specific date range.\"\"\"\n    # Get devices for the user\n    devices = list(d_c.find({\"user_id\": user_id}))\n    device_ids = [device[\"id\"] for device in devices]\n\n    if not device_ids:\n        print(f\"No devices found for user {user_id}\")\n        return\n\n    # Build query\n    query = {\n        \"device_id\": {\"$in\": device_ids},\n        \"timestamp\": {\n            \"$gte\": start_date,\n            \"$lte\": end_date\n        }\n    }\n\n    # Fetch the records\n    records = list(us_c.find(query))\n    print(f\"Found {len(records)} records in the date range\")\n\n    # Check for missing fields\n    fields_to_check = [\"energy_consumed\", \"duration\", \"status\", \"metrics\"]\n    missing_data = {}\n\n    for field in fields_to_check:\n        missing_data[field] = 0\n\n    for record in records:\n        for field in fields_to_check:\n            if field not in record or record[field] is None:\n                missing_data[field] += 1\n\n    print(\"\\nMissing fields summary:\")\n    for field, count in missing_data.items():\n        if count &gt; 0:\n            print(f\"- {field}: Missing in {count} records ({count/len(records)*100:.1f}%)\")\n\n    # Show a few example records\n    if records:\n        print(\"\\nSample record structure:\")\n        for key, value in records[0].items():\n            print(f\"- {key}: {type(value).__name__} = {value}\")\n\n    # Check for None values in energy_consumed\n    none_energy = [r for r in records if \"energy_consumed\" not in r or r[\"energy_consumed\"] is None]\n    if none_energy:\n        print(f\"\\nFound {len(none_energy)} records with None energy_consumed values\")\n        print(\"Would you like to fix these records? (y/n)\")\n        response = input().strip().lower()\n\n        if response == 'y':\n            for record in none_energy:\n                # Update with default value\n                us_c.update_one(\n                    {\"_id\": record[\"_id\"]},\n                    {\"$set\": {\"energy_consumed\": 0.0}}\n                )\n            print(f\"Fixed {len(none_energy)} records\")\n\n    # Return the records for additional processing\n    return records\n</code></pre>"},{"location":"api/#app.patched_report_generator","title":"<code>app.patched_report_generator</code>","text":"<p>Patched version of report generator that handles None values.</p>"},{"location":"api/#app.patched_report_generator.fetch_energy_data","title":"<code>app.patched_report_generator.fetch_energy_data(user_id, start_date, end_date, device_ids=None)</code>","text":"<p>Patched version of fetch_energy_data that handles None values.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def fetch_energy_data(user_id, start_date, end_date, device_ids=None):\n    \"\"\"\n    Patched version of fetch_energy_data that handles None values.\n    \"\"\"\n    # Build the query\n    query = {}\n\n    # Filter by device IDs\n    if device_ids:\n        query[\"device_id\"] = {\"$in\": device_ids}\n    else:\n        # Get all devices owned by the user\n        user_devices = list(d_c.find({\"user_id\": user_id}))\n        if not user_devices:\n            return []\n\n        user_device_ids = [device[\"id\"] for device in user_devices]\n        if user_device_ids:\n            query[\"device_id\"] = {\"$in\": user_device_ids}\n        else:\n            return []\n\n    # Add date range filter\n    if start_date or end_date:\n        timestamp_query = {}\n        if start_date:\n            timestamp_query[\"$gte\"] = start_date\n        if end_date:\n            timestamp_query[\"$lte\"] = end_date\n\n        if timestamp_query:\n            query[\"timestamp\"] = timestamp_query\n\n    # Execute the query\n    print(f\"Query: {query}\")\n    cursor = us_c.find(query).sort(\"timestamp\", 1)\n    print(f\"Cursor type: {type(cursor)}\")\n    usage_data = list(cursor)\n    print(f\"Usage data type: {type(usage_data)}, length: {len(usage_data)}\")\n\n    # Fix missing or None values\n    for i, record in enumerate(usage_data):\n        # Fill in missing energy_consumed with zeros\n        if \"energy_consumed\" not in record or record[\"energy_consumed\"] is None:\n            print(f\"Fixing record {i}: Adding default energy_consumed = 0.0\")\n            record[\"energy_consumed\"] = 0.0\n\n        # Convert timestamp to ISO format if it's a datetime object\n        if \"timestamp\" in record and isinstance(record[\"timestamp\"], datetime):\n            record[\"timestamp\"] = record[\"timestamp\"].isoformat()\n\n    # Enhance usage data with device information\n    enhanced_data = []\n    for record in usage_data:\n        # Get device info\n        device_id = record.get(\"device_id\")\n        device = d_c.find_one({\"id\": device_id})\n\n        # Create enhanced record with location\n        enhanced_record = {\n            \"timestamp\": record.get(\"timestamp\"),\n            \"device_id\": device_id,\n            \"energy_consumed\": record.get(\"energy_consumed\", 0.0),  # Default to 0 if missing\n            \"location\": device.get(\"room_id\") if device else \"Unknown\"\n        }\n\n        enhanced_data.append(enhanced_record)\n\n    return enhanced_data\n</code></pre>"},{"location":"api/#app.patched_report_generator.fetch_user_data","title":"<code>app.patched_report_generator.fetch_user_data(user_id)</code>","text":"<p>Fetch user data for report personalization.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def fetch_user_data(user_id):\n    \"\"\"Fetch user data for report personalization.\"\"\"\n    user = u_c.find_one({\"id\": user_id})\n\n    if not user:\n        return {}\n\n    return {\n        \"email\": user.get(\"email\"),\n        \"username\": user.get(\"username\")\n    }\n</code></pre>"},{"location":"api/#app.patched_report_generator.generate_energy_report","title":"<code>app.patched_report_generator.generate_energy_report(energy_data, user_data=None, format='pdf', start_date=None, end_date=None)</code>","text":"<p>Patched version that handles the path to the report generator.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def generate_energy_report(energy_data, user_data=None, format=\"pdf\", start_date=None, end_date=None):\n    \"\"\"\n    Patched version that handles the path to the report generator.\n    \"\"\"\n    from app.utils.report.report_generator import generate_energy_report as gen_report\n\n    # Print some debug info\n    print(f\"Generating {format} report with {len(energy_data)} records\")\n    if len(energy_data) &gt; 0:\n        sample = energy_data[0]\n        print(f\"Sample record: {sample}\")\n\n    # Call the original function\n    try:\n        report_path = gen_report(\n            energy_data=energy_data,\n            user_data=user_data,\n            format=format.lower(),\n            start_date=start_date,\n            end_date=end_date\n        )\n        return report_path\n    except Exception as e:\n        traceback.print_exc()\n        print(f\"Error in report generation: {e}\")\n        return None\n</code></pre>"},{"location":"api/#app.patched_report_generator.generate_report","title":"<code>app.patched_report_generator.generate_report(report_id)</code>","text":"<p>Patched version of generate_report that uses our fixed functions.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def generate_report(report_id):\n    \"\"\"\n    Patched version of generate_report that uses our fixed functions.\n    \"\"\"\n    # Get report data\n    report_data = r_c.find_one({\"id\": report_id})\n    if not report_data:\n        return False, None, \"Report not found\"\n\n    try:\n        # Update status to generating\n        r_c.update_one(\n            {\"id\": report_id},\n            {\"$set\": {\"status\": \"generating\", \"updated\": datetime.utcnow()}}\n        )\n\n        # Fetch energy data with our patched function\n        start_date = None\n        end_date = None\n\n        if report_data.get(\"start_date\"):\n            start_date = datetime.strptime(report_data[\"start_date\"], \"%Y-%m-%d\")\n        if report_data.get(\"end_date\"):\n            end_date = datetime.strptime(report_data[\"end_date\"], \"%Y-%m-%d\") + timedelta(days=1) - timedelta(seconds=1)\n\n        energy_data = fetch_energy_data(\n            user_id=report_data[\"user_id\"],\n            start_date=start_date,\n            end_date=end_date,\n            device_ids=report_data.get(\"device_ids\")\n        )\n\n        if not energy_data:\n            error_msg = \"No energy data found for the specified criteria\"\n            r_c.update_one(\n                {\"id\": report_id},\n                {\"$set\": {\"status\": \"failed\", \"error_message\": error_msg, \"updated\": datetime.utcnow()}}\n            )\n            return False, None, error_msg\n\n        # Fetch user data for personalization\n        user_data = fetch_user_data(report_data[\"user_id\"])\n\n        # Generate the report with our patched function\n        report_path = generate_energy_report(\n            energy_data=energy_data,\n            user_data=user_data,\n            format=report_data[\"format\"].lower(),\n            start_date=report_data.get(\"start_date\"),\n            end_date=report_data.get(\"end_date\")\n        )\n\n        if not report_path:\n            error_msg = \"Failed to generate report file\"\n            r_c.update_one(\n                {\"id\": report_id},\n                {\"$set\": {\"status\": \"failed\", \"error_message\": error_msg, \"updated\": datetime.utcnow()}}\n            )\n            return False, None, error_msg\n\n        # Update the report record with success status\n        r_c.update_one(\n            {\"id\": report_id},\n            {\"$set\": {\n                \"status\": \"completed\",\n                \"file_path\": report_path,\n                \"completed\": datetime.utcnow(),\n                \"updated\": datetime.utcnow()\n            }}\n        )\n\n        return True, report_path, None\n\n    except Exception as e:\n        # Update the report record with failure status\n        error_message = str(e)\n        r_c.update_one(\n            {\"id\": report_id},\n            {\"$set\": {\"status\": \"failed\", \"error_message\": error_message, \"updated\": datetime.utcnow()}}\n        )\n\n        return False, None, error_message\n</code></pre>"},{"location":"api/#app.patched_report_generator.get_user_devices","title":"<code>app.patched_report_generator.get_user_devices(user_id)</code>","text":"<p>Get all devices for a user.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def get_user_devices(user_id):\n    \"\"\"Get all devices for a user.\"\"\"\n    devices = list(d_c.find({\"user_id\": user_id}))\n    return devices\n</code></pre>"},{"location":"api/#app.patched_report_generator.main","title":"<code>app.patched_report_generator.main()</code>","text":"<p>Patched report generation script.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def main():\n    \"\"\"Patched report generation script.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Generate energy usage reports\")\n\n    parser.add_argument(\"--user_id\", required=True, help=\"User ID to generate report for\")\n    parser.add_argument(\"--format\", choices=[\"pdf\", \"csv\"], default=\"pdf\", help=\"Report format\")\n    parser.add_argument(\"--days\", type=int, default=30, help=\"Number of days to include in report\")\n    parser.add_argument(\"--title\", help=\"Report title\")\n    parser.add_argument(\"--device_ids\", nargs=\"+\", help=\"Specific device IDs to include (space-separated)\")\n    parser.add_argument(\"--report_type\", default=\"energy\", help=\"Report type (default: energy)\")\n    parser.add_argument(\"--historical\", action=\"store_true\", help=\"Use historical data (March 2024)\")\n\n    args = parse_args = parser.parse_args()\n\n    # Validate user\n    user = validate_user_id(args.user_id)\n    print(f\"Generating report for user: {user.get('username', user.get('email', 'Unknown'))}\")\n\n    # Determine date range\n    if args.historical:\n        # Use March 2024 dates where we know data exists\n        end_date = datetime(2024, 3, 19)  # Latest record date\n        start_date = end_date - timedelta(days=args.days)\n        print(\"Using historical data period (March 2024)\")\n    else:\n        # Use current dates\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=args.days)\n        print(\"Using current date period\")\n\n    start_date_str = start_date.strftime(\"%Y-%m-%d\")\n    end_date_str = end_date.strftime(\"%Y-%m-%d\")\n    print(f\"Date range: {start_date_str} to {end_date_str}\")\n\n    # Get device IDs if not specified\n    device_ids = args.device_ids\n    if not device_ids:\n        devices = get_user_devices(args.user_id)\n        device_ids = [device[\"id\"] for device in devices]\n        print(f\"Using all devices ({len(device_ids)}) for the user\")\n    else:\n        print(f\"Using specified devices: {', '.join(device_ids)}\")\n\n    # Create a title if not specified\n    title = args.title\n    if not title:\n        title = f\"Energy Report ({start_date_str} to {end_date_str})\"\n\n    # Generate a UUID for the report\n    report_uuid = str(uuid.uuid4())\n\n    # Create report object\n    report_db = ReportDB(\n        id=report_uuid,\n        user_id=args.user_id,\n        title=title,\n        format=args.format.lower(),\n        report_type=args.report_type,\n        start_date=start_date_str,\n        end_date=end_date_str,\n        device_ids=device_ids,\n        status=\"pending\"\n    )\n\n    # Create report in database\n    print(\"Creating report record...\")\n    result = r_c.insert_one(report_db.model_dump())\n    print(f\"Report record created with MongoDB ID: {result.inserted_id}\")\n    print(f\"Report UUID: {report_uuid}\")\n\n    # Generate the report using the UUID we assigned\n    print(\"Generating report...\")\n    success, file_path, error = generate_report(report_uuid)\n\n    if success and file_path:\n        print(f\"Report successfully generated!\")\n        print(f\"Report file: {file_path}\")\n    else:\n        print(f\"Error generating report: {error}\")\n</code></pre>"},{"location":"api/#app.patched_report_generator.validate_user_id","title":"<code>app.patched_report_generator.validate_user_id(user_id)</code>","text":"<p>Check if the user exists in the database.</p> Source code in <code>app/patched_report_generator.py</code> <pre><code>def validate_user_id(user_id):\n    \"\"\"Check if the user exists in the database.\"\"\"\n    user = u_c.find_one({\"id\": user_id})\n    if not user:\n        print(f\"Error: User with ID {user_id} not found.\")\n        sys.exit(1)\n    return user\n</code></pre>"},{"location":"api/#app.core.auth","title":"<code>app.core.auth</code>","text":"<p>Authentication dependencies for FastAPI.</p>"},{"location":"api/#app.core.auth.get_current_user","title":"<code>app.core.auth.get_current_user(credentials=Depends(security))</code>  <code>async</code>","text":"<p>Get the currently authenticated user.</p> <p>Uses HTTP Basic Authentication to validate the user.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>HTTPBasicCredentials</code> <p>The HTTP Basic credentials from the request</p> <code>Depends(security)</code> <p>Returns:</p> Name Type Description <code>UserDB</code> <code>UserDB</code> <p>The authenticated user</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If authentication fails</p> Source code in <code>app/core/auth.py</code> <pre><code>async def get_current_user(credentials: HTTPBasicCredentials = Depends(security)) -&gt; UserDB:\n    \"\"\"\n    Get the currently authenticated user.\n\n    Uses HTTP Basic Authentication to validate the user.\n\n    Args:\n        credentials: The HTTP Basic credentials from the request\n\n    Returns:\n        UserDB: The authenticated user\n\n    Raises:\n        HTTPException: If authentication fails\n    \"\"\"\n    auth_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Invalid username or password\",\n        headers={\"WWW-Authenticate\": \"Basic\"},\n    )\n\n    # Try to find user by username\n    user = u_c.find_one({\"username\": credentials.username})\n\n    # If not found, try by email\n    if not user:\n        user = u_c.find_one({\"email\": credentials.username})\n\n    # Check credentials\n    if not user or not verify_password(credentials.password, user[\"hashed_password\"]):\n        raise auth_exception\n\n    # Check if user is active\n    if not user.get(\"active\", True):  # Default to active if not specified\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Inactive user account\",\n            headers={\"WWW-Authenticate\": \"Basic\"},\n        )\n\n    return UserDB(**user)\n</code></pre>"},{"location":"api/#app.core.password","title":"<code>app.core.password</code>","text":"<p>Implements password security features.</p>"},{"location":"api/#app.core.password.hash_password","title":"<code>app.core.password.hash_password(p)</code>","text":"<p>Hashes a password.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>str</code> <p>Password to hash.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hashed password.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password fails to hash.</p> Source code in <code>app/core/password.py</code> <pre><code>def hash_password(p: str) -&gt; str:\n    \"\"\"\n    Hashes a password.\n\n    Args:\n        p (str): Password to hash.\n\n    Returns:\n        str: Hashed password.\n\n    Raises:\n        ValueError: If password fails to hash.\n    \"\"\"\n    try:\n        return pc.hash(p)\n    except Exception as e:\n        raise ValueError(f\"Error hashing password: {e}\") from e\n</code></pre>"},{"location":"api/#app.core.password.verify_password","title":"<code>app.core.password.verify_password(p, h)</code>","text":"<p>Matches plain-text password with the hashed password.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>str</code> <p>Plain-text password.</p> required <code>h</code> <code>str</code> <p>Hashed password.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>(True: Passwords match); (False: Passwords don't match).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If passwords fail to compare.</p> Source code in <code>app/core/password.py</code> <pre><code>def verify_password(p: str, h: str) -&gt; bool:\n    \"\"\"\n    Matches plain-text password with the hashed password.\n\n    Args:\n        p (str): Plain-text password.\n        h (str): Hashed password.\n\n    Returns:\n        bool: (True: Passwords match); (False: Passwords don't match).\n\n    Raises:\n        ValueError: If passwords fail to compare.\n    \"\"\"\n    try:\n        return pc.verify(p, h)\n    except Exception as e:\n        raise ValueError(f\"Error verifying password: {e}\") from e\n</code></pre>"},{"location":"api/#app.core.password.verify_role","title":"<code>app.core.password.verify_role(u, r)</code>","text":"<p>Enforces correct user role for access.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>User's current role.</p> required <code>r</code> <code>str</code> <p>Required user role.</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If user lacks the required role.</p> Source code in <code>app/core/password.py</code> <pre><code>def verify_role(u: str, r: str):\n    \"\"\"\n    Enforces correct user role for access.\n\n    Args:\n        u (str): User's current role.\n        r (str): Required user role.\n\n    Raises:\n        HTTPException: If user lacks the required role.\n    \"\"\"\n    if u != r:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=f\"Permission denied. {r} role is required for access.\"\n        )\n\n    return True\n</code></pre>"},{"location":"api/#app.db.data","title":"<code>app.db.data</code>","text":"<p>Handles MongoDB database connections &amp; operations.</p>"},{"location":"api/#app.db.data.init_db","title":"<code>app.db.data.init_db()</code>","text":"<p>Initialize MongoDB database &amp; creates indexes.</p> Source code in <code>app/db/data.py</code> <pre><code>def init_db():\n    \"\"\"\n    Initialize MongoDB database &amp; creates indexes.\n    \"\"\"\n    # User collection\n    u_c.create_index(\"id\", unique=True)     # Unique identification\n    u_c.create_index(\"email\", unique=True)  # Unique email address\n    u_c.create_index(\"username\")            # General username\n\n    # Profile collection\n    p_c.create_index(\"id\", unique=True)         # Unique identification\n    p_c.create_index(\"user_id\", unique=True)    # Unique user identification\n\n    # Device collection\n    d_c.create_index(\"id\", unique=True)             # Device identification\n    d_c.create_index(\"user_id\")                     # User identification\n    d_c.create_index([(\"type\", 1), (\"user_id\", 1)]) # Filter type through user identification\n\n    # Room collection\n    r_c.create_index(\"id\", unique=True)     # Unique identification\n    r_c.create_index(\"user_id\")             # User identification\n    r_c.create_index(\"home_id\")             # Home identification\n\n    # Usage collection\n    us_c.create_index(\"id\", unique=True)                     # Unique identification\n    us_c.create_index(\"device_id\")                           # Device identification\n    us_c.create_index(\"timestamp\")                           # Usage log\n    us_c.create_index([(\"device_id\", 1), (\"timestamp\", -1)])  # Filter log by device identification\n\n    # Automation collection\n    a_c.create_index(\"id\", unique=True)     # Unique identification\n    a_c.create_index(\"user_id\")             # User identification\n    a_c.create_index(\"device_id\")           # User identification\n\n    # Notification collection\n    n_c.create_index(\"id\", unique=True)                                 # Unique identification\n    n_c.create_index(\"user_id\")                                         # User identification\n    n_c.create_index([(\"user_id\", 1), (\"read\", 1), (\"timestamp\", -1)])  # Filter notification read by device &amp; time\n\n    # Access Management collection\n    am_c.create_index(\"id\", unique=True)                        # Unique identification\n    am_c.create_index(\"owner_id\")                               # Owner identification\n    am_c.create_index(\"resource_id\")                            # Resource identification\n    am_c.create_index([(\"owner_id\", 1), (\"resource_id\", 1)])    # Filters resource by its owner\n\n    # Goal collection\n    g_c.create_index(\"id\", unique=True)                 # Unique identification\n    g_c.create_index(\"user_id\")                         # User identification\n    g_c.create_index(\"type\")                            # Type of goal\n    g_c.create_index([(\"user_id\", 1), (\"type\", 1)])     # Filters types of goals by user identification\n\n    # Analytics collection\n    an_c.create_index(\"id\", unique=True)                    # Unique identification\n    an_c.create_index(\"user_id\")                            # User identification\n    an_c.create_index(\"device_id\")                          # Device identification\n    an_c.create_index([(\"user_id\", 1), (\"timestamp\", -1)])  # Filters user identification by timestamp\n\n    # Suggestion collection\n    s_c.create_index(\"id\", unique=True)                                     # Unique identification\n    s_c.create_index(\"user_id\")                                             # User identification\n    s_c.create_index([(\"user_id\", 1), (\"status\", 1), (\"timestamp\", -1)])    # Filters user identification with status by timestamp\n\n    print(\"Database initialized with indexes.\")\n</code></pre>"},{"location":"api/#app.models.access_management","title":"<code>app.models.access_management</code>","text":"<p>Models for access management validation.</p>"},{"location":"api/#app.models.access_management.AccessLevel","title":"<code>app.models.access_management.AccessLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for access permission levels.</p> Source code in <code>app/models/access_management.py</code> <pre><code>class AccessLevel(str, Enum):\n    \"\"\"\n    Enum for access permission levels.\n    \"\"\"\n    READ = \"read\"\n    CONTROL = \"control\"\n    MANAGE = \"manage\"\n    ADMIN = \"admin\"\n</code></pre>"},{"location":"api/#app.models.access_management.AccessManagementDB","title":"<code>app.models.access_management.AccessManagementDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing access management data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier.</p> <code>owner_id</code> <code>str</code> <p>ID of the user who owns the resource.</p> <code>resource_id</code> <code>str</code> <p>ID of the resource being shared.</p> <code>resource_type</code> <code>ResourceType</code> <p>Type of resource being shared.</p> <code>user_id</code> <code>str</code> <p>ID of the user granted access.</p> <code>access_level</code> <code>AccessLevel</code> <p>Level of access granted.</p> <code>created</code> <code>datetime</code> <p>When the access was granted.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the access was last updated.</p> <code>expires_at</code> <code>Optional[datetime]</code> <p>When the access expires.</p> <code>active</code> <code>bool</code> <p>Whether this access grant is currently active.</p> <code>note</code> <code>Optional[str]</code> <p>Optional note about this access grant.</p> Source code in <code>app/models/access_management.py</code> <pre><code>class AccessManagementDB(BaseModel):\n    \"\"\"\n    Internal model representing access management data in the database.\n\n    Attributes:\n        id (str): Unique identifier.\n        owner_id (str): ID of the user who owns the resource.\n        resource_id (str): ID of the resource being shared.\n        resource_type (ResourceType): Type of resource being shared.\n        user_id (str): ID of the user granted access.\n        access_level (AccessLevel): Level of access granted.\n        created (datetime): When the access was granted.\n        updated (Optional[datetime]): When the access was last updated.\n        expires_at (Optional[datetime]): When the access expires.\n        active (bool): Whether this access grant is currently active.\n        note (Optional[str]): Optional note about this access grant.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    owner_id: str\n    resource_id: str\n    resource_type: ResourceType\n    user_id: str\n    access_level: AccessLevel\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n    expires_at: Optional[datetime] = None\n    active: bool = True\n    note: Optional[str] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.access_management.AccessManagementResponse","title":"<code>app.models.access_management.AccessManagementResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for access management data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier.</p> <code>owner_id</code> <code>str</code> <p>ID of the user who owns the resource.</p> <code>resource_id</code> <code>str</code> <p>ID of the resource being shared.</p> <code>resource_type</code> <code>ResourceType</code> <p>Type of resource being shared.</p> <code>user_id</code> <code>str</code> <p>ID of the user granted access.</p> <code>access_level</code> <code>AccessLevel</code> <p>Level of access granted.</p> <code>created</code> <code>datetime</code> <p>When the access was granted.</p> <code>expires_at</code> <code>Optional[datetime]</code> <p>When the access expires.</p> <code>active</code> <code>bool</code> <p>Whether this access grant is currently active.</p> Source code in <code>app/models/access_management.py</code> <pre><code>class AccessManagementResponse(BaseModel):\n    \"\"\"\n    Model for access management data returned in API responses.\n\n    Attributes:\n        id (str): Unique identifier.\n        owner_id (str): ID of the user who owns the resource.\n        resource_id (str): ID of the resource being shared.\n        resource_type (ResourceType): Type of resource being shared.\n        user_id (str): ID of the user granted access.\n        access_level (AccessLevel): Level of access granted.\n        created (datetime): When the access was granted.\n        expires_at (Optional[datetime]): When the access expires.\n        active (bool): Whether this access grant is currently active.\n    \"\"\"\n    id: str\n    owner_id: str\n    resource_id: str\n    resource_type: ResourceType\n    user_id: str\n    access_level: AccessLevel\n    created: datetime\n    expires_at: Optional[datetime] = None\n    active: bool\n    note: Optional[str] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.access_management.AccessManagementUpdate","title":"<code>app.models.access_management.AccessManagementUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating access management entries.</p> <p>Attributes:</p> Name Type Description <code>access_level</code> <code>Optional[AccessLevel]</code> <p>Updated access level.</p> <code>expires_at</code> <code>Optional[datetime]</code> <p>Updated expiration time.</p> <code>active</code> <code>Optional[bool]</code> <p>Updated active status.</p> <code>note</code> <code>Optional[str]</code> <p>Updated note.</p> Source code in <code>app/models/access_management.py</code> <pre><code>class AccessManagementUpdate(BaseModel):\n    \"\"\"\n    Model for updating access management entries.\n\n    Attributes:\n        access_level (Optional[AccessLevel]): Updated access level.\n        expires_at (Optional[datetime]): Updated expiration time.\n        active (Optional[bool]): Updated active status.\n        note (Optional[str]): Updated note.\n    \"\"\"\n    access_level: Optional[AccessLevel] = None\n    expires_at: Optional[datetime] = None\n    active: Optional[bool] = None\n    note: Optional[str] = None\n\n    @field_validator(\"note\")\n    @classmethod\n    def validate_note(cls, n: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate note length.\n\n        Arguments:\n            n (Optional[str]): Note to validate.\n\n        Returns:\n            Optional[str]: Validated note.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if n is not None and len(n) &gt; 200:\n            raise ValueError(\"Note must be less than 200 characters long.\")\n\n        return n\n</code></pre>"},{"location":"api/#app.models.access_management.AccessManagementUpdate.validate_note","title":"<code>app.models.access_management.AccessManagementUpdate.validate_note(n)</code>  <code>classmethod</code>","text":"<p>Validate note length.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Optional[str]</code> <p>Note to validate.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated note.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>app/models/access_management.py</code> <pre><code>@field_validator(\"note\")\n@classmethod\ndef validate_note(cls, n: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate note length.\n\n    Arguments:\n        n (Optional[str]): Note to validate.\n\n    Returns:\n        Optional[str]: Validated note.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if n is not None and len(n) &gt; 200:\n        raise ValueError(\"Note must be less than 200 characters long.\")\n\n    return n\n</code></pre>"},{"location":"api/#app.models.access_management.CreateAccessManagement","title":"<code>app.models.access_management.CreateAccessManagement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for creating access management entries.</p> <p>Attributes:</p> Name Type Description <code>owner_id</code> <code>str</code> <p>ID of the user who owns the resource.</p> <code>resource_id</code> <code>str</code> <p>ID of the resource being shared.</p> <code>resource_type</code> <code>ResourceType</code> <p>Type of resource being shared.</p> <code>user_ids</code> <code>List[str]</code> <p>List of user IDs to grant access to.</p> <code>access_level</code> <code>AccessLevel</code> <p>Level of access to grant.</p> <code>expires_at</code> <code>Optional[datetime]</code> <p>When the access expires (optional).</p> <code>note</code> <code>Optional[str]</code> <p>Optional note about this access grant.</p> Source code in <code>app/models/access_management.py</code> <pre><code>class CreateAccessManagement(BaseModel):\n    \"\"\"\n    Model for creating access management entries.\n\n    Attributes:\n        owner_id (str): ID of the user who owns the resource.\n        resource_id (str): ID of the resource being shared.\n        resource_type (ResourceType): Type of resource being shared.\n        user_ids (List[str]): List of user IDs to grant access to.\n        access_level (AccessLevel): Level of access to grant.\n        expires_at (Optional[datetime]): When the access expires (optional).\n        note (Optional[str]): Optional note about this access grant.\n    \"\"\"\n    owner_id: str\n    resource_id: str\n    resource_type: ResourceType\n    user_ids: List[str]\n    access_level: AccessLevel\n    expires_at: Optional[datetime] = None\n    note: Optional[str] = None\n\n    @field_validator(\"note\")\n    @classmethod\n    def validate_note(cls, n: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate note length.\n\n        Arguments:\n            n (Optional[str]): Note to validate.\n\n        Returns:\n            Optional[str]: Validated note.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if n is not None and len(n) &gt; 200:\n            raise ValueError(\"Note must be less than 200 characters long.\")\n\n        return n\n\n    @field_validator(\"user_ids\")\n    @classmethod\n    def validate_user_ids(cls, u: List[str]) -&gt; List[str]:\n        \"\"\"\n        Validate user IDs list.\n\n        Arguments:\n            u (List[str]): List of user IDs.\n\n        Returns:\n            List[str]: Validated list of user IDs.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if not u:\n            raise ValueError(\"At least one user ID must be provided.\")\n        if len(u) &gt; 50:\n            raise ValueError(\"Cannot share with more than 50 users at once.\")\n\n        return u\n</code></pre>"},{"location":"api/#app.models.access_management.CreateAccessManagement.validate_note","title":"<code>app.models.access_management.CreateAccessManagement.validate_note(n)</code>  <code>classmethod</code>","text":"<p>Validate note length.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Optional[str]</code> <p>Note to validate.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated note.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>app/models/access_management.py</code> <pre><code>@field_validator(\"note\")\n@classmethod\ndef validate_note(cls, n: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate note length.\n\n    Arguments:\n        n (Optional[str]): Note to validate.\n\n    Returns:\n        Optional[str]: Validated note.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if n is not None and len(n) &gt; 200:\n        raise ValueError(\"Note must be less than 200 characters long.\")\n\n    return n\n</code></pre>"},{"location":"api/#app.models.access_management.CreateAccessManagement.validate_user_ids","title":"<code>app.models.access_management.CreateAccessManagement.validate_user_ids(u)</code>  <code>classmethod</code>","text":"<p>Validate user IDs list.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>List[str]</code> <p>List of user IDs.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Validated list of user IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>app/models/access_management.py</code> <pre><code>@field_validator(\"user_ids\")\n@classmethod\ndef validate_user_ids(cls, u: List[str]) -&gt; List[str]:\n    \"\"\"\n    Validate user IDs list.\n\n    Arguments:\n        u (List[str]): List of user IDs.\n\n    Returns:\n        List[str]: Validated list of user IDs.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if not u:\n        raise ValueError(\"At least one user ID must be provided.\")\n    if len(u) &gt; 50:\n        raise ValueError(\"Cannot share with more than 50 users at once.\")\n\n    return u\n</code></pre>"},{"location":"api/#app.models.access_management.ResourceType","title":"<code>app.models.access_management.ResourceType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for supported resource types in the system.</p> Source code in <code>app/models/access_management.py</code> <pre><code>class ResourceType(str, Enum):\n    \"\"\"\n    Enum for supported resource types in the system.\n    \"\"\"\n    DEVICE = \"device\"\n    ROOM = \"room\"\n    HOME = \"home\"\n    AUTOMATION = \"automation\"\n</code></pre>"},{"location":"api/#app.models.analytics","title":"<code>app.models.analytics</code>","text":"<p>Models for analytics validation and storage.</p>"},{"location":"api/#app.models.analytics.AnalyticsDB","title":"<code>app.models.analytics.AnalyticsDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing analytics data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique analytics identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user the analytics belongs to.</p> <code>device_id</code> <code>str</code> <p>ID of the device generating the analytics.</p> <code>data_type</code> <code>str</code> <p>Type of analytics data.</p> <code>metrics</code> <code>Dict[str, Any]</code> <p>The actual metrics being stored.</p> <code>tags</code> <code>List[str]</code> <p>Tags for categorizing analytics data.</p> <code>timestamp</code> <code>datetime</code> <p>When the analytics data was recorded.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the analytics data was last updated.</p> Source code in <code>app/models/analytics.py</code> <pre><code>class AnalyticsDB(BaseModel):\n    \"\"\"\n    Internal model representing analytics data in the database.\n\n    Attributes:\n        id (str): Unique analytics identifier.\n        user_id (str): ID of the user the analytics belongs to.\n        device_id (str): ID of the device generating the analytics.\n        data_type (str): Type of analytics data.\n        metrics (Dict[str, Any]): The actual metrics being stored.\n        tags (List[str]): Tags for categorizing analytics data.\n        timestamp (datetime): When the analytics data was recorded.\n        updated (Optional[datetime]): When the analytics data was last updated.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    device_id: str\n    data_type: str\n    metrics: Dict[str, Any]\n    tags: List[str] = []\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.analytics.AnalyticsQuery","title":"<code>app.models.analytics.AnalyticsQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for querying analytics data with filters.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>Optional[str]</code> <p>Filter by user ID.</p> <code>device_id</code> <code>Optional[str]</code> <p>Filter by device ID.</p> <code>data_type</code> <code>Optional[str]</code> <p>Filter by data type.</p> <code>start_time</code> <code>Optional[datetime]</code> <p>Filter by start timestamp.</p> <code>end_time</code> <code>Optional[datetime]</code> <p>Filter by end timestamp.</p> <code>tags</code> <code>Optional[List[str]]</code> <p>Filter by tags.</p> Source code in <code>app/models/analytics.py</code> <pre><code>class AnalyticsQuery(BaseModel):\n    \"\"\"\n    Model for querying analytics data with filters.\n\n    Attributes:\n        user_id (Optional[str]): Filter by user ID.\n        device_id (Optional[str]): Filter by device ID.\n        data_type (Optional[str]): Filter by data type.\n        start_time (Optional[datetime]): Filter by start timestamp.\n        end_time (Optional[datetime]): Filter by end timestamp.\n        tags (Optional[List[str]]): Filter by tags.\n    \"\"\"\n    user_id: Optional[str] = None\n    device_id: Optional[str] = None\n    data_type: Optional[str] = None\n    start_time: Optional[datetime] = None\n    end_time: Optional[datetime] = None\n    tags: Optional[List[str]] = None\n\n    @field_validator(\"start_time\", \"end_time\")\n    @classmethod\n    def validate_time_range(cls, v: Optional[datetime], info) -&gt; Optional[datetime]:\n        \"\"\"\n        Validate that start_time comes before end_time if both are provided.\n\n        Note: This validation only runs after all fields are populated, so it\n        needs to be called separately after instantiation.\n        \"\"\"\n        return v\n\n    def validate_time_range_post_init(self):\n        \"\"\"\n        Validate that start_time comes before end_time if both are provided.\n        Call this after instantiating the model.\n        \"\"\"\n        if self.start_time and self.end_time and self.start_time &gt; self.end_time:\n            raise ValueError(\"start_time must be before end_time\")\n</code></pre>"},{"location":"api/#app.models.analytics.AnalyticsQuery.validate_time_range","title":"<code>app.models.analytics.AnalyticsQuery.validate_time_range(v, info)</code>  <code>classmethod</code>","text":"<p>Validate that start_time comes before end_time if both are provided.</p> <p>Note: This validation only runs after all fields are populated, so it needs to be called separately after instantiation.</p> Source code in <code>app/models/analytics.py</code> <pre><code>@field_validator(\"start_time\", \"end_time\")\n@classmethod\ndef validate_time_range(cls, v: Optional[datetime], info) -&gt; Optional[datetime]:\n    \"\"\"\n    Validate that start_time comes before end_time if both are provided.\n\n    Note: This validation only runs after all fields are populated, so it\n    needs to be called separately after instantiation.\n    \"\"\"\n    return v\n</code></pre>"},{"location":"api/#app.models.analytics.AnalyticsQuery.validate_time_range_post_init","title":"<code>app.models.analytics.AnalyticsQuery.validate_time_range_post_init()</code>","text":"<p>Validate that start_time comes before end_time if both are provided. Call this after instantiating the model.</p> Source code in <code>app/models/analytics.py</code> <pre><code>def validate_time_range_post_init(self):\n    \"\"\"\n    Validate that start_time comes before end_time if both are provided.\n    Call this after instantiating the model.\n    \"\"\"\n    if self.start_time and self.end_time and self.start_time &gt; self.end_time:\n        raise ValueError(\"start_time must be before end_time\")\n</code></pre>"},{"location":"api/#app.models.analytics.AnalyticsResponse","title":"<code>app.models.analytics.AnalyticsResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for analytics data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique analytics identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user the analytics belongs to.</p> <code>device_id</code> <code>str</code> <p>ID of the device generating the analytics.</p> <code>data_type</code> <code>str</code> <p>Type of analytics data.</p> <code>metrics</code> <code>Dict[str, Any]</code> <p>The actual metrics being stored.</p> <code>tags</code> <code>List[str]</code> <p>Tags for categorizing analytics data.</p> <code>timestamp</code> <code>datetime</code> <p>When the analytics data was recorded.</p> Source code in <code>app/models/analytics.py</code> <pre><code>class AnalyticsResponse(BaseModel):\n    \"\"\"\n    Model for analytics data returned in API responses.\n\n    Attributes:\n        id (str): Unique analytics identifier.\n        user_id (str): ID of the user the analytics belongs to.\n        device_id (str): ID of the device generating the analytics.\n        data_type (str): Type of analytics data.\n        metrics (Dict[str, Any]): The actual metrics being stored.\n        tags (List[str]): Tags for categorizing analytics data.\n        timestamp (datetime): When the analytics data was recorded.\n    \"\"\"\n    id: str\n    user_id: str\n    device_id: str\n    data_type: str\n    metrics: Dict[str, Any]\n    tags: List[str]\n    timestamp: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.analytics.AnalyticsUpdate","title":"<code>app.models.analytics.AnalyticsUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating analytics information.</p> <p>Attributes:</p> Name Type Description <code>metrics</code> <code>Optional[Dict[str, Any]]</code> <p>Updated metrics.</p> <code>tags</code> <code>Optional[List[str]]</code> <p>Updated tags for categorizing analytics data.</p> Source code in <code>app/models/analytics.py</code> <pre><code>class AnalyticsUpdate(BaseModel):\n    \"\"\"\n    Model for updating analytics information.\n\n    Attributes:\n        metrics (Optional[Dict[str, Any]]): Updated metrics.\n        tags (Optional[List[str]]): Updated tags for categorizing analytics data.\n    \"\"\"\n    metrics: Optional[Dict[str, Any]] = None\n    tags: Optional[List[str]] = None\n\n    @field_validator(\"tags\")\n    @classmethod\n    def validate_tags(cls, v: Optional[List[str]]) -&gt; Optional[List[str]]:\n        \"\"\"\n        Validate tags.\n\n        Arguments:\n            v (Optional[List[str]]): Tags to be validated.\n\n        Returns:\n            Optional[List[str]]: Validated tags.\n\n        Raises:\n            ValueError: If tags contain empty strings.\n        \"\"\"\n        if v is not None:\n            if any(not tag.strip() for tag in v):\n                raise ValueError(\"Tags cannot contain empty strings.\")\n            return [tag.strip() for tag in v]\n        return v\n</code></pre>"},{"location":"api/#app.models.analytics.AnalyticsUpdate.validate_tags","title":"<code>app.models.analytics.AnalyticsUpdate.validate_tags(v)</code>  <code>classmethod</code>","text":"<p>Validate tags.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[List[str]]</code> <p>Tags to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>Optional[List[str]]: Validated tags.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If tags contain empty strings.</p> Source code in <code>app/models/analytics.py</code> <pre><code>@field_validator(\"tags\")\n@classmethod\ndef validate_tags(cls, v: Optional[List[str]]) -&gt; Optional[List[str]]:\n    \"\"\"\n    Validate tags.\n\n    Arguments:\n        v (Optional[List[str]]): Tags to be validated.\n\n    Returns:\n        Optional[List[str]]: Validated tags.\n\n    Raises:\n        ValueError: If tags contain empty strings.\n    \"\"\"\n    if v is not None:\n        if any(not tag.strip() for tag in v):\n            raise ValueError(\"Tags cannot contain empty strings.\")\n        return [tag.strip() for tag in v]\n    return v\n</code></pre>"},{"location":"api/#app.models.analytics.CreateAnalytics","title":"<code>app.models.analytics.CreateAnalytics</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for analytics data input.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>ID of the user the analytics belongs to.</p> <code>device_id</code> <code>str</code> <p>ID of the device generating the analytics.</p> <code>data_type</code> <code>str</code> <p>Type of analytics data (energy, usage, temperature, etc.).</p> <code>metrics</code> <code>Dict[str, Any]</code> <p>The actual metrics being stored.</p> <code>tags</code> <code>List[str]</code> <p>Optional tags for categorizing analytics data.</p> Source code in <code>app/models/analytics.py</code> <pre><code>class CreateAnalytics(BaseModel):\n    \"\"\"\n    Model for analytics data input.\n\n    Attributes:\n        user_id (str): ID of the user the analytics belongs to.\n        device_id (str): ID of the device generating the analytics.\n        data_type (str): Type of analytics data (energy, usage, temperature, etc.).\n        metrics (Dict[str, Any]): The actual metrics being stored.\n        tags (List[str]): Optional tags for categorizing analytics data.\n    \"\"\"\n    user_id: str\n    device_id: str\n    data_type: str\n    metrics: Dict[str, Any]\n    tags: Optional[List[str]] = []\n\n    @field_validator(\"user_id\", \"device_id\")\n    @classmethod\n    def validate_id(cls, v: str) -&gt; str:\n        \"\"\"\n        Validate ID fields.\n\n        Arguments:\n            v (str): ID to be validated.\n\n        Returns:\n            str: Validated ID.\n\n        Raises:\n            ValueError: If ID is empty or doesn't match UUID format.\n        \"\"\"\n        if not v:\n            raise ValueError(\"ID cannot be empty.\")\n\n        # Try to parse as UUID to ensure valid format\n        try:\n            uuid.UUID(v)\n        except ValueError as exc:\n            raise ValueError(\"ID must be a valid UUID format.\") from exc\n\n        return v\n\n    @field_validator(\"data_type\")\n    @classmethod\n    def validate_data_type(cls, v: str) -&gt; str:\n        \"\"\"\n        Validate data_type field.\n\n        Arguments:\n            v (str): data_type to be validated.\n\n        Returns:\n            str: Validated data_type.\n\n        Raises:\n            ValueError: If data_type is empty or invalid.\n        \"\"\"\n        valid_types = [\"energy\", \"usage\", \"temperature\", \"humidity\", \"motion\", \"light\", \"other\"]\n        if not v:\n            raise ValueError(\"Data type cannot be empty.\")\n\n        if v.lower() not in valid_types:\n            raise ValueError(f\"Data type must be one of: {', '.join(valid_types)}\")\n\n        return v.lower()\n</code></pre>"},{"location":"api/#app.models.analytics.CreateAnalytics.validate_data_type","title":"<code>app.models.analytics.CreateAnalytics.validate_data_type(v)</code>  <code>classmethod</code>","text":"<p>Validate data_type field.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>data_type to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated data_type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data_type is empty or invalid.</p> Source code in <code>app/models/analytics.py</code> <pre><code>@field_validator(\"data_type\")\n@classmethod\ndef validate_data_type(cls, v: str) -&gt; str:\n    \"\"\"\n    Validate data_type field.\n\n    Arguments:\n        v (str): data_type to be validated.\n\n    Returns:\n        str: Validated data_type.\n\n    Raises:\n        ValueError: If data_type is empty or invalid.\n    \"\"\"\n    valid_types = [\"energy\", \"usage\", \"temperature\", \"humidity\", \"motion\", \"light\", \"other\"]\n    if not v:\n        raise ValueError(\"Data type cannot be empty.\")\n\n    if v.lower() not in valid_types:\n        raise ValueError(f\"Data type must be one of: {', '.join(valid_types)}\")\n\n    return v.lower()\n</code></pre>"},{"location":"api/#app.models.analytics.CreateAnalytics.validate_id","title":"<code>app.models.analytics.CreateAnalytics.validate_id(v)</code>  <code>classmethod</code>","text":"<p>Validate ID fields.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>ID to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If ID is empty or doesn't match UUID format.</p> Source code in <code>app/models/analytics.py</code> <pre><code>@field_validator(\"user_id\", \"device_id\")\n@classmethod\ndef validate_id(cls, v: str) -&gt; str:\n    \"\"\"\n    Validate ID fields.\n\n    Arguments:\n        v (str): ID to be validated.\n\n    Returns:\n        str: Validated ID.\n\n    Raises:\n        ValueError: If ID is empty or doesn't match UUID format.\n    \"\"\"\n    if not v:\n        raise ValueError(\"ID cannot be empty.\")\n\n    # Try to parse as UUID to ensure valid format\n    try:\n        uuid.UUID(v)\n    except ValueError as exc:\n        raise ValueError(\"ID must be a valid UUID format.\") from exc\n\n    return v\n</code></pre>"},{"location":"api/#app.models.automation","title":"<code>app.models.automation</code>","text":"<p>Models for automation validation.</p>"},{"location":"api/#app.models.automation.ActionType","title":"<code>app.models.automation.ActionType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for different types of automation actions.</p> Source code in <code>app/models/automation.py</code> <pre><code>class ActionType(str, Enum):\n    \"\"\"\n    Enum for different types of automation actions.\n    \"\"\"\n    DEVICE_CONTROL = \"device_control\"\n    NOTIFICATION = \"notification\"\n    SCENE_ACTIVATION = \"scene_activation\"\n    ENERGY_MANAGEMENT = \"energy_management\"\n</code></pre>"},{"location":"api/#app.models.automation.AutomationDB","title":"<code>app.models.automation.AutomationDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing automation data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique automation identifier.</p> <code>name</code> <code>str</code> <p>Name of the automation.</p> <code>description</code> <code>str</code> <p>Description of what the automation does.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns this automation.</p> <code>device_id</code> <code>str</code> <p>ID of the device associated with this automation.</p> <code>enabled</code> <code>bool</code> <p>Whether the automation is enabled.</p> <code>trigger_type</code> <code>TriggerType</code> <p>Type of trigger for this automation.</p> <code>trigger_data</code> <code>Dict</code> <p>Configuration data for the trigger.</p> <code>action_type</code> <code>ActionType</code> <p>Type of action for this automation.</p> <code>action_data</code> <code>Dict</code> <p>Configuration data for the action.</p> <code>conditions</code> <code>Optional[List[Dict]]</code> <p>Optional conditions that must be met.</p> <code>created</code> <code>datetime</code> <p>When the automation was created.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the automation was last updated.</p> <code>last_triggered</code> <code>Optional[datetime]</code> <p>When the automation was last triggered.</p> <code>execution_count</code> <code>int</code> <p>Number of times the automation has executed.</p> Source code in <code>app/models/automation.py</code> <pre><code>class AutomationDB(BaseModel):\n    \"\"\"\n    Internal model representing automation data in the database.\n\n    Attributes:\n        id (str): Unique automation identifier.\n        name (str): Name of the automation.\n        description (str): Description of what the automation does.\n        user_id (str): ID of the user who owns this automation.\n        device_id (str): ID of the device associated with this automation.\n        enabled (bool): Whether the automation is enabled.\n        trigger_type (TriggerType): Type of trigger for this automation.\n        trigger_data (Dict): Configuration data for the trigger.\n        action_type (ActionType): Type of action for this automation.\n        action_data (Dict): Configuration data for the action.\n        conditions (Optional[List[Dict]]): Optional conditions that must be met.\n        created (datetime): When the automation was created.\n        updated (Optional[datetime]): When the automation was last updated.\n        last_triggered (Optional[datetime]): When the automation was last triggered.\n        execution_count (int): Number of times the automation has executed.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    name: str\n    description: str\n    user_id: str\n    device_id: str\n    enabled: bool = True\n    trigger_type: TriggerType\n    trigger_data: Dict[str, Any]\n    action_type: ActionType\n    action_data: Dict[str, Any]\n    conditions: Optional[List[Dict[str, Any]]] = None\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n    last_triggered: Optional[datetime] = None\n    execution_count: int = 0\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.automation.AutomationDetailResponse","title":"<code>app.models.automation.AutomationDetailResponse</code>","text":"<p>               Bases: <code>AutomationResponse</code></p> <p>Detailed model for automation data returned in API responses. Extends AutomationResponse to include configuration details.</p> Additional Attributes <p>trigger_data (Dict): Configuration data for the trigger. action_data (Dict): Configuration data for the action. conditions (Optional[List[Dict]]): Optional conditions that must be met. updated (Optional[datetime]): When the automation was last updated.</p> Source code in <code>app/models/automation.py</code> <pre><code>class AutomationDetailResponse(AutomationResponse):\n    \"\"\"\n    Detailed model for automation data returned in API responses.\n    Extends AutomationResponse to include configuration details.\n\n    Additional Attributes:\n        trigger_data (Dict): Configuration data for the trigger.\n        action_data (Dict): Configuration data for the action.\n        conditions (Optional[List[Dict]]): Optional conditions that must be met.\n        updated (Optional[datetime]): When the automation was last updated.\n    \"\"\"\n    trigger_data: Dict[str, Any]\n    action_data: Dict[str, Any]\n    conditions: Optional[List[Dict[str, Any]]] = None\n    updated: Optional[datetime] = None\n</code></pre>"},{"location":"api/#app.models.automation.AutomationResponse","title":"<code>app.models.automation.AutomationResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for automation data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique automation identifier.</p> <code>name</code> <code>str</code> <p>Name of the automation.</p> <code>description</code> <code>str</code> <p>Description of what the automation does.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns this automation.</p> <code>device_id</code> <code>str</code> <p>ID of the device associated with this automation.</p> <code>enabled</code> <code>bool</code> <p>Whether the automation is enabled.</p> <code>trigger_type</code> <code>TriggerType</code> <p>Type of trigger for this automation.</p> <code>action_type</code> <code>ActionType</code> <p>Type of action for this automation.</p> <code>created</code> <code>datetime</code> <p>When the automation was created.</p> <code>last_triggered</code> <code>Optional[datetime]</code> <p>When the automation was last triggered.</p> <code>execution_count</code> <code>int</code> <p>Number of times the automation has executed.</p> Source code in <code>app/models/automation.py</code> <pre><code>class AutomationResponse(BaseModel):\n    \"\"\"\n    Model for automation data returned in API responses.\n\n    Attributes:\n        id (str): Unique automation identifier.\n        name (str): Name of the automation.\n        description (str): Description of what the automation does.\n        user_id (str): ID of the user who owns this automation.\n        device_id (str): ID of the device associated with this automation.\n        enabled (bool): Whether the automation is enabled.\n        trigger_type (TriggerType): Type of trigger for this automation.\n        action_type (ActionType): Type of action for this automation.\n        created (datetime): When the automation was created.\n        last_triggered (Optional[datetime]): When the automation was last triggered.\n        execution_count (int): Number of times the automation has executed.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    user_id: str\n    device_id: str\n    enabled: bool\n    trigger_type: TriggerType\n    action_type: ActionType\n    created: datetime\n    last_triggered: Optional[datetime] = None\n    execution_count: int\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.automation.AutomationUpdate","title":"<code>app.models.automation.AutomationUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating automation information.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Updated name of the automation.</p> <code>description</code> <code>Optional[str]</code> <p>Updated description.</p> <code>enabled</code> <code>Optional[bool]</code> <p>Updated enabled status.</p> <code>trigger_type</code> <code>Optional[TriggerType]</code> <p>Updated trigger type.</p> <code>trigger_data</code> <code>Optional[Dict]</code> <p>Updated trigger configuration.</p> <code>action_type</code> <code>Optional[ActionType]</code> <p>Updated action type.</p> <code>action_data</code> <code>Optional[Dict]</code> <p>Updated action configuration.</p> <code>conditions</code> <code>Optional[List[Dict]]</code> <p>Updated conditions.</p> Source code in <code>app/models/automation.py</code> <pre><code>class AutomationUpdate(BaseModel):\n    \"\"\"\n    Model for updating automation information.\n\n    Attributes:\n        name (Optional[str]): Updated name of the automation.\n        description (Optional[str]): Updated description.\n        enabled (Optional[bool]): Updated enabled status.\n        trigger_type (Optional[TriggerType]): Updated trigger type.\n        trigger_data (Optional[Dict]): Updated trigger configuration.\n        action_type (Optional[ActionType]): Updated action type.\n        action_data (Optional[Dict]): Updated action configuration.\n        conditions (Optional[List[Dict]]): Updated conditions.\n    \"\"\"\n    name: Optional[str] = None\n    description: Optional[str] = None\n    enabled: Optional[bool] = None\n    trigger_type: Optional[TriggerType] = None\n    trigger_data: Optional[Dict[str, Any]] = None\n    action_type: Optional[ActionType] = None\n    action_data: Optional[Dict[str, Any]] = None\n    conditions: Optional[List[Dict[str, Any]]] = None\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, v: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate automation name.\n\n        Arguments:\n            v (Optional[str]): Name to be validated.\n\n        Returns:\n            Optional[str]: Validated name.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(v, str):\n            if len(v) &lt; 3:\n                raise ValueError(\"Automation name must be at least 3 characters long.\")\n            if len(v) &gt; 50:\n                raise ValueError(\"Automation name must be less than 50 characters long.\")\n\n        return v\n\n    @field_validator(\"description\")\n    @classmethod\n    def validate_description(cls, v: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate automation description.\n\n        Arguments:\n            v (Optional[str]): Description to be validated.\n\n        Returns:\n            Optional[str]: Validated description.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(v, str) and len(v) &gt; 500:\n            raise ValueError(\"Automation description must be less than 500 characters long.\")\n\n        return v\n</code></pre>"},{"location":"api/#app.models.automation.AutomationUpdate.validate_description","title":"<code>app.models.automation.AutomationUpdate.validate_description(v)</code>  <code>classmethod</code>","text":"<p>Validate automation description.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[str]</code> <p>Description to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated description.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/automation.py</code> <pre><code>@field_validator(\"description\")\n@classmethod\ndef validate_description(cls, v: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate automation description.\n\n    Arguments:\n        v (Optional[str]): Description to be validated.\n\n    Returns:\n        Optional[str]: Validated description.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(v, str) and len(v) &gt; 500:\n        raise ValueError(\"Automation description must be less than 500 characters long.\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.automation.AutomationUpdate.validate_name","title":"<code>app.models.automation.AutomationUpdate.validate_name(v)</code>  <code>classmethod</code>","text":"<p>Validate automation name.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[str]</code> <p>Name to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/automation.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, v: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate automation name.\n\n    Arguments:\n        v (Optional[str]): Name to be validated.\n\n    Returns:\n        Optional[str]: Validated name.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(v, str):\n        if len(v) &lt; 3:\n            raise ValueError(\"Automation name must be at least 3 characters long.\")\n        if len(v) &gt; 50:\n            raise ValueError(\"Automation name must be less than 50 characters long.\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.automation.CreateAutomation","title":"<code>app.models.automation.CreateAutomation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for automation creation input.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the automation.</p> <code>description</code> <code>str</code> <p>Description of what the automation does.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns this automation.</p> <code>device_id</code> <code>str</code> <p>ID of the device associated with this automation.</p> <code>enabled</code> <code>bool</code> <p>Whether the automation is enabled.</p> <code>trigger_type</code> <code>TriggerType</code> <p>Type of trigger for this automation.</p> <code>trigger_data</code> <code>Dict</code> <p>Configuration data for the trigger.</p> <code>action_type</code> <code>ActionType</code> <p>Type of action for this automation.</p> <code>action_data</code> <code>Dict</code> <p>Configuration data for the action.</p> <code>conditions</code> <code>Optional[List[Dict]]</code> <p>Optional conditions that must be met.</p> Source code in <code>app/models/automation.py</code> <pre><code>class CreateAutomation(BaseModel):\n    \"\"\"\n    Model for automation creation input.\n\n    Attributes:\n        name (str): Name of the automation.\n        description (str): Description of what the automation does.\n        user_id (str): ID of the user who owns this automation.\n        device_id (str): ID of the device associated with this automation.\n        enabled (bool): Whether the automation is enabled.\n        trigger_type (TriggerType): Type of trigger for this automation.\n        trigger_data (Dict): Configuration data for the trigger.\n        action_type (ActionType): Type of action for this automation.\n        action_data (Dict): Configuration data for the action.\n        conditions (Optional[List[Dict]]): Optional conditions that must be met.\n    \"\"\"\n    name: str\n    description: str\n    user_id: str\n    device_id: str  \n    enabled: bool = True\n    trigger_type: TriggerType\n    trigger_data: Dict[str, Any]\n    action_type: ActionType\n    action_data: Dict[str, Any]\n    conditions: Optional[List[Dict[str, Any]]] = None\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, v: str) -&gt; str:\n        \"\"\"\n        Validate automation name.\n\n        Arguments:\n            v (str): Name to be validated.\n\n        Returns:\n            str: Validated name.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(v) &lt; 3:\n            raise ValueError(\"Automation name must be at least 3 characters long.\")\n        if len(v) &gt; 50:\n            raise ValueError(\"Automation name must be less than 50 characters long.\")\n\n        return v\n\n    @field_validator(\"description\")\n    @classmethod\n    def validate_description(cls, v: str) -&gt; str:\n        \"\"\"\n        Validate automation description.\n\n        Arguments:\n            v (str): Description to be validated.\n\n        Returns:\n            str: Validated description.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(v) &gt; 500:\n            raise ValueError(\"Automation description must be less than 500 characters long.\")\n\n        return v\n</code></pre>"},{"location":"api/#app.models.automation.CreateAutomation.validate_description","title":"<code>app.models.automation.CreateAutomation.validate_description(v)</code>  <code>classmethod</code>","text":"<p>Validate automation description.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Description to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated description.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/automation.py</code> <pre><code>@field_validator(\"description\")\n@classmethod\ndef validate_description(cls, v: str) -&gt; str:\n    \"\"\"\n    Validate automation description.\n\n    Arguments:\n        v (str): Description to be validated.\n\n    Returns:\n        str: Validated description.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(v) &gt; 500:\n        raise ValueError(\"Automation description must be less than 500 characters long.\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.automation.CreateAutomation.validate_name","title":"<code>app.models.automation.CreateAutomation.validate_name(v)</code>  <code>classmethod</code>","text":"<p>Validate automation name.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Name to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/automation.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, v: str) -&gt; str:\n    \"\"\"\n    Validate automation name.\n\n    Arguments:\n        v (str): Name to be validated.\n\n    Returns:\n        str: Validated name.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(v) &lt; 3:\n        raise ValueError(\"Automation name must be at least 3 characters long.\")\n    if len(v) &gt; 50:\n        raise ValueError(\"Automation name must be less than 50 characters long.\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.automation.TriggerType","title":"<code>app.models.automation.TriggerType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for different types of automation triggers.</p> Source code in <code>app/models/automation.py</code> <pre><code>class TriggerType(str, Enum):\n    \"\"\"\n    Enum for different types of automation triggers.\n    \"\"\"\n    TIME = \"time\"\n    SENSOR = \"sensor\"\n    MANUAL = \"manual\"\n    DEVICE_STATE = \"device_state\"\n    LOCATION = \"location\"\n    WEATHER = \"weather\"\n</code></pre>"},{"location":"api/#app.models.device","title":"<code>app.models.device</code>","text":"<p>Model for device validation &amp; storage.</p>"},{"location":"api/#app.models.device.CreateDevice","title":"<code>app.models.device.CreateDevice</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for device registration input.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name.</p> <code>type</code> <code>DeviceType</code> <p>Type of device.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns the device.</p> <code>room_id</code> <code>Optional[str]</code> <p>ID of the room where the device is located.</p> <code>ip_address</code> <code>Optional[str]</code> <p>Device IP address.</p> <code>mac_address</code> <code>Optional[str]</code> <p>Device MAC address.</p> <code>manufacturer</code> <code>Optional[str]</code> <p>Device manufacturer.</p> <code>model</code> <code>Optional[str]</code> <p>Device model.</p> <code>firmware_version</code> <code>Optional[str]</code> <p>Current firmware version.</p> <code>settings</code> <code>Optional[Dict]</code> <p>Device-specific settings.</p> Source code in <code>app/models/device.py</code> <pre><code>class CreateDevice(BaseModel):\n    \"\"\"\n    Model for device registration input.\n\n    Attributes:\n        name (str): Device name.\n        type (DeviceType): Type of device.\n        user_id (str): ID of the user who owns the device.\n        room_id (Optional[str]): ID of the room where the device is located.\n        ip_address (Optional[str]): Device IP address.\n        mac_address (Optional[str]): Device MAC address.\n        manufacturer (Optional[str]): Device manufacturer.\n        model (Optional[str]): Device model.\n        firmware_version (Optional[str]): Current firmware version.\n        settings (Optional[Dict]): Device-specific settings.\n    \"\"\"\n    name: str\n    type: DeviceType\n    user_id: str\n    room_id: Optional[str] = None\n    ip_address: Optional[str] = None\n    mac_address: Optional[str] = None\n    manufacturer: Optional[str] = None\n    model: Optional[str] = None\n    firmware_version: Optional[str] = None\n    settings: Optional[Dict[str, Any]] = None\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, n: str) -&gt; str:\n        \"\"\"\n        Validate device name according to requirements.\n\n        Args:\n            name (str): Device name to be validated.\n\n        Returns:\n            str: Validated device name.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(n) &lt; 1:\n            raise ValueError(\"Device name can't be empty.\")\n        if len(n) &gt; 100:\n            raise ValueError(\"Device name must be less than 100 characters long.\")\n\n        return n\n</code></pre>"},{"location":"api/#app.models.device.CreateDevice.validate_name","title":"<code>app.models.device.CreateDevice.validate_name(n)</code>  <code>classmethod</code>","text":"<p>Validate device name according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Device name to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated device name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/device.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, n: str) -&gt; str:\n    \"\"\"\n    Validate device name according to requirements.\n\n    Args:\n        name (str): Device name to be validated.\n\n    Returns:\n        str: Validated device name.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(n) &lt; 1:\n        raise ValueError(\"Device name can't be empty.\")\n    if len(n) &gt; 100:\n        raise ValueError(\"Device name must be less than 100 characters long.\")\n\n    return n\n</code></pre>"},{"location":"api/#app.models.device.DeviceDB","title":"<code>app.models.device.DeviceDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing device data in the database</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique device identifier.</p> <code>name</code> <code>str</code> <p>Device name.</p> <code>type</code> <code>DeviceType</code> <p>Type of device.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns the device.</p> <code>room_id</code> <code>Optional[str]</code> <p>ID of the room where the device is located.</p> <code>ip_address</code> <code>Optional[str]</code> <p>Device IP address.</p> <code>mac_address</code> <code>Optional[str]</code> <p>Device MAC address.</p> <code>manufacturer</code> <code>Optional[str]</code> <p>Device manufacturer.</p> <code>model</code> <code>Optional[str]</code> <p>Device model.</p> <code>firmware_version</code> <code>Optional[str]</code> <p>Current firmware version.</p> <code>settings</code> <code>Optional[Dict]</code> <p>Device-specific settings.</p> <code>status</code> <code>DeviceStatus</code> <p>Current device status.</p> <code>last_online</code> <code>Optional[datetime]</code> <p>When the device was last seen online.</p> <code>created</code> <code>datetime</code> <p>When the device was added to the system.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the device data was last updated.</p> <code>capabilities</code> <code>List[str]</code> <p>List of device capabilities/features.</p> Source code in <code>app/models/device.py</code> <pre><code>class DeviceDB(BaseModel):\n    \"\"\"\n    Internal model representing device data in the database\n\n    Attributes:\n        id (str): Unique device identifier.\n        name (str): Device name.\n        type (DeviceType): Type of device.\n        user_id (str): ID of the user who owns the device.\n        room_id (Optional[str]): ID of the room where the device is located.\n        ip_address (Optional[str]): Device IP address.\n        mac_address (Optional[str]): Device MAC address.\n        manufacturer (Optional[str]): Device manufacturer.\n        model (Optional[str]): Device model.\n        firmware_version (Optional[str]): Current firmware version.\n        settings (Optional[Dict]): Device-specific settings.\n        status (DeviceStatus): Current device status.\n        last_online (Optional[datetime]): When the device was last seen online.\n        created (datetime): When the device was added to the system.\n        updated (Optional[datetime]): When the device data was last updated.\n        capabilities (List[str]): List of device capabilities/features.\n    \"\"\"\n    id: str\n    name: str\n    type: DeviceType\n    user_id: str\n    room_id: Optional[str] = None\n    ip_address: Optional[str] = None\n    mac_address: Optional[str] = None\n    manufacturer: Optional[str] = None\n    model: Optional[str] = None\n    firmware_version: Optional[str] = None\n    settings: Optional[Dict[str, Any]] = None\n    status: DeviceStatus = DeviceStatus.OFFLINE\n    last_online: Optional[datetime] = None\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n    capabilities: List[str] = []\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.device.DeviceResponse","title":"<code>app.models.device.DeviceResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for device data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique device identifier.</p> <code>name</code> <code>str</code> <p>Device name.</p> <code>type</code> <code>DeviceType</code> <p>Type of device.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns the device.</p> <code>room_id</code> <code>Optional[str]</code> <p>ID of the room where the device is located.</p> <code>manufacturer</code> <code>Optional[str]</code> <p>Device manufacturer.</p> <code>model</code> <code>Optional[str]</code> <p>Device model.</p> <code>status</code> <code>DeviceStatus</code> <p>Current device status.</p> <code>last_online</code> <code>Optional[datetime]</code> <p>When the device was last seen online.</p> <code>created</code> <code>datetime</code> <p>When the device was added to the system.</p> <code>capabilities</code> <code>List[str]</code> <p>List of device capabilities/features.</p> Source code in <code>app/models/device.py</code> <pre><code>class DeviceResponse(BaseModel):\n    \"\"\"\n    Model for device data returned in API responses.\n\n    Attributes:\n        id (str): Unique device identifier.\n        name (str): Device name.\n        type (DeviceType): Type of device.\n        user_id (str): ID of the user who owns the device.\n        room_id (Optional[str]): ID of the room where the device is located.\n        manufacturer (Optional[str]): Device manufacturer.\n        model (Optional[str]): Device model.\n        status (DeviceStatus): Current device status.\n        last_online (Optional[datetime]): When the device was last seen online.\n        created (datetime): When the device was added to the system.\n        capabilities (List[str]): List of device capabilities/features.\n    \"\"\"\n    id: str\n    name: str\n    type: DeviceType\n    user_id: str\n    room_id: Optional[str] = None\n    manufacturer: Optional[str] = None\n    model: Optional[str] = None\n    status: DeviceStatus\n    last_online: Optional[datetime] = None\n    created: datetime\n    capabilities: List[str] = []\n</code></pre>"},{"location":"api/#app.models.device.DeviceStatus","title":"<code>app.models.device.DeviceStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible device statuses.</p> Source code in <code>app/models/device.py</code> <pre><code>class DeviceStatus(str, Enum):\n    \"\"\"\n    Enumeration of possible device statuses.\n    \"\"\"\n    ONLINE = \"online\"\n    OFFLINE = \"offline\"\n    ERROR = \"error\"\n    MAINTENANCE = \"maintenance\"\n</code></pre>"},{"location":"api/#app.models.device.DeviceType","title":"<code>app.models.device.DeviceType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of supported device types.</p> Source code in <code>app/models/device.py</code> <pre><code>class DeviceType(str, Enum):\n    \"\"\"\n    Enumeration of supported device types.\n    \"\"\"\n    LIGHT = \"light\"\n    THERMOSTAT = \"thermostat\"\n    LOCK = \"lock\"\n    CAMERA = \"camera\"\n    SENSOR = \"sensor\"\n    SWITCH = \"switch\"\n    OUTLET = \"outlet\"\n    SPEAKER = \"speaker\"\n    OTHER = \"other\"\n</code></pre>"},{"location":"api/#app.models.device.DeviceUpdate","title":"<code>app.models.device.DeviceUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating device information.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Updated device name.</p> <code>room_id</code> <code>Optional[str]</code> <p>Updated room location.</p> <code>ip_address</code> <code>Optional[str]</code> <p>Updated IP address.</p> <code>firmware_version</code> <code>Optional[str]</code> <p>Updated firmware version.</p> <code>settings</code> <code>Optional[Dict]</code> <p>Updated device settings.</p> <code>status</code> <code>Optional[DeviceStatus]</code> <p>Updated device status.</p> Source code in <code>app/models/device.py</code> <pre><code>class DeviceUpdate(BaseModel):\n    \"\"\"\n    Model for updating device information.\n\n    Attributes:\n        name (Optional[str]): Updated device name.\n        room_id (Optional[str]): Updated room location.\n        ip_address (Optional[str]): Updated IP address.\n        firmware_version (Optional[str]): Updated firmware version.\n        settings (Optional[Dict]): Updated device settings.\n        status (Optional[DeviceStatus]): Updated device status.\n    \"\"\"\n    name: Optional[str] = None\n    room_id: Optional[str] = None\n    ip_address: Optional[str] = None\n    firmware_version: Optional[str] = None\n    settings: Optional[Dict[str, Any]] = None\n    status: Optional[DeviceStatus] = None\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, n: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate device name according to requirements.\n\n        Args:\n            n (Optional[str]): Device name to be validated.\n\n        Returns: \n            Optional[str]: Validated device name.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if n is None:\n            return None\n\n        if len(n) &lt; 1:\n            raise ValueError(\"Device name can't be empty.\")\n        if len(n) &gt; 100:\n            raise ValueError(\"Device name must be less than 100 characters long.\")\n\n        return n\n</code></pre>"},{"location":"api/#app.models.device.DeviceUpdate.validate_name","title":"<code>app.models.device.DeviceUpdate.validate_name(n)</code>  <code>classmethod</code>","text":"<p>Validate device name according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Optional[str]</code> <p>Device name to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated device name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/device.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, n: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate device name according to requirements.\n\n    Args:\n        n (Optional[str]): Device name to be validated.\n\n    Returns: \n        Optional[str]: Validated device name.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if n is None:\n        return None\n\n    if len(n) &lt; 1:\n        raise ValueError(\"Device name can't be empty.\")\n    if len(n) &gt; 100:\n        raise ValueError(\"Device name must be less than 100 characters long.\")\n\n    return n\n</code></pre>"},{"location":"api/#app.models.goal","title":"<code>app.models.goal</code>","text":"<p>Models for energy goal validation and storage.</p>"},{"location":"api/#app.models.goal.CreateEnergyGoal","title":"<code>app.models.goal.CreateEnergyGoal</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for energy goal creation input.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>ID of the user who owns the goal.</p> <code>title</code> <code>str</code> <p>Title of the goal.</p> <code>description</code> <code>str</code> <p>Detailed description of the goal.</p> <code>type</code> <code>GoalType</code> <p>Type of energy goal.</p> <code>target_value</code> <code>float</code> <p>Target value for the goal (e.g., kWh to save).</p> <code>timeframe</code> <code>GoalTimeframe</code> <p>Timeframe for the goal.</p> <code>start_date</code> <code>datetime</code> <p>When the goal starts.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>When the goal ends (required for CUSTOM timeframe).</p> <code>related_devices</code> <code>Optional[List[str]]</code> <p>List of device IDs this goal applies to.</p> Source code in <code>app/models/goal.py</code> <pre><code>class CreateEnergyGoal(BaseModel):\n    \"\"\"\n    Model for energy goal creation input.\n\n    Attributes:\n        user_id (str): ID of the user who owns the goal.\n        title (str): Title of the goal.\n        description (str): Detailed description of the goal.\n        type (GoalType): Type of energy goal.\n        target_value (float): Target value for the goal (e.g., kWh to save).\n        timeframe (GoalTimeframe): Timeframe for the goal.\n        start_date (datetime): When the goal starts.\n        end_date (Optional[datetime]): When the goal ends (required for CUSTOM timeframe).\n        related_devices (Optional[List[str]]): List of device IDs this goal applies to.\n    \"\"\"\n    user_id: str\n    title: str\n    description: str\n    type: GoalType\n    target_value: float\n    timeframe: GoalTimeframe\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    related_devices: Optional[List[str]] = None\n\n    @field_validator(\"title\")\n    @classmethod\n    def validate_title(cls, t: str) -&gt; str:\n        \"\"\"\n        Validate the goal title.\n\n        Arguments:\n            t (str): Title to be validated.\n\n        Returns:\n            str: Validated title.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(t) &lt; 3:\n            raise ValueError(\"Title must be at least 3 characters long.\")\n        if len(t) &gt; 100:\n            raise ValueError(\"Title must be less than 100 characters long.\")\n        return t\n\n    @field_validator(\"description\")\n    @classmethod\n    def validate_description(cls, d: str) -&gt; str:\n        \"\"\"\n        Validate the goal description.\n\n        Arguments:\n            d (str): Description to be validated.\n\n        Returns:\n            str: Validated description.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(d) &lt; 10:\n            raise ValueError(\"Description must be at least 10 characters long.\")\n        if len(d) &gt; 500:\n            raise ValueError(\"Description must be less than 500 characters long.\")\n        return d\n\n    @field_validator(\"target_value\")\n    @classmethod\n    def validate_target_value(cls, v: float) -&gt; float:\n        \"\"\"\n        Validate the target value.\n\n        Arguments:\n            v (float): Target value to be validated.\n\n        Returns:\n            float: Validated target value.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if v &lt;= 0:\n            raise ValueError(\"Target value must be greater than 0.\")\n        return v\n\n    @field_validator(\"end_date\")\n    @classmethod\n    def validate_end_date(cls, end: Optional[datetime], values: dict) -&gt; Optional[datetime]:\n        \"\"\"\n        Validate the end date based on timeframe and start date.\n\n        Arguments:\n            end (Optional[datetime]): End date to be validated.\n            values (dict): Previously validated values.\n\n        Returns:\n            Optional[datetime]: Validated end date.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        timeframe = values.data.get(\"timeframe\")\n        start_date = values.data.get(\"start_date\")\n\n        if timeframe == GoalTimeframe.CUSTOM and end is None:\n            raise ValueError(\"End date is required for custom timeframe.\")\n\n        if end is not None and start_date is not None and end &lt;= start_date:\n            raise ValueError(\"End date must be after start date.\")\n\n        return end\n</code></pre>"},{"location":"api/#app.models.goal.CreateEnergyGoal.validate_description","title":"<code>app.models.goal.CreateEnergyGoal.validate_description(d)</code>  <code>classmethod</code>","text":"<p>Validate the goal description.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>str</code> <p>Description to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated description.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"description\")\n@classmethod\ndef validate_description(cls, d: str) -&gt; str:\n    \"\"\"\n    Validate the goal description.\n\n    Arguments:\n        d (str): Description to be validated.\n\n    Returns:\n        str: Validated description.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(d) &lt; 10:\n        raise ValueError(\"Description must be at least 10 characters long.\")\n    if len(d) &gt; 500:\n        raise ValueError(\"Description must be less than 500 characters long.\")\n    return d\n</code></pre>"},{"location":"api/#app.models.goal.CreateEnergyGoal.validate_end_date","title":"<code>app.models.goal.CreateEnergyGoal.validate_end_date(end, values)</code>  <code>classmethod</code>","text":"<p>Validate the end date based on timeframe and start date.</p> <p>Parameters:</p> Name Type Description Default <code>end</code> <code>Optional[datetime]</code> <p>End date to be validated.</p> required <code>values</code> <code>dict</code> <p>Previously validated values.</p> required <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Optional[datetime]: Validated end date.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"end_date\")\n@classmethod\ndef validate_end_date(cls, end: Optional[datetime], values: dict) -&gt; Optional[datetime]:\n    \"\"\"\n    Validate the end date based on timeframe and start date.\n\n    Arguments:\n        end (Optional[datetime]): End date to be validated.\n        values (dict): Previously validated values.\n\n    Returns:\n        Optional[datetime]: Validated end date.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    timeframe = values.data.get(\"timeframe\")\n    start_date = values.data.get(\"start_date\")\n\n    if timeframe == GoalTimeframe.CUSTOM and end is None:\n        raise ValueError(\"End date is required for custom timeframe.\")\n\n    if end is not None and start_date is not None and end &lt;= start_date:\n        raise ValueError(\"End date must be after start date.\")\n\n    return end\n</code></pre>"},{"location":"api/#app.models.goal.CreateEnergyGoal.validate_target_value","title":"<code>app.models.goal.CreateEnergyGoal.validate_target_value(v)</code>  <code>classmethod</code>","text":"<p>Validate the target value.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>float</code> <p>Target value to be validated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Validated target value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"target_value\")\n@classmethod\ndef validate_target_value(cls, v: float) -&gt; float:\n    \"\"\"\n    Validate the target value.\n\n    Arguments:\n        v (float): Target value to be validated.\n\n    Returns:\n        float: Validated target value.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if v &lt;= 0:\n        raise ValueError(\"Target value must be greater than 0.\")\n    return v\n</code></pre>"},{"location":"api/#app.models.goal.CreateEnergyGoal.validate_title","title":"<code>app.models.goal.CreateEnergyGoal.validate_title(t)</code>  <code>classmethod</code>","text":"<p>Validate the goal title.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>Title to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated title.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef validate_title(cls, t: str) -&gt; str:\n    \"\"\"\n    Validate the goal title.\n\n    Arguments:\n        t (str): Title to be validated.\n\n    Returns:\n        str: Validated title.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(t) &lt; 3:\n        raise ValueError(\"Title must be at least 3 characters long.\")\n    if len(t) &gt; 100:\n        raise ValueError(\"Title must be less than 100 characters long.\")\n    return t\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalDB","title":"<code>app.models.goal.EnergyGoalDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing energy goal data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique goal identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns the goal.</p> <code>title</code> <code>str</code> <p>Title of the goal.</p> <code>description</code> <code>str</code> <p>Detailed description of the goal.</p> <code>type</code> <code>GoalType</code> <p>Type of energy goal.</p> <code>target_value</code> <code>float</code> <p>Target value for the goal (e.g., kWh to save).</p> <code>current_value</code> <code>float</code> <p>Current progress value.</p> <code>progress_percentage</code> <code>float</code> <p>Percentage of goal completion.</p> <code>timeframe</code> <code>GoalTimeframe</code> <p>Timeframe for the goal.</p> <code>start_date</code> <code>datetime</code> <p>When the goal starts.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>When the goal ends.</p> <code>status</code> <code>GoalStatus</code> <p>Current status of the goal.</p> <code>related_devices</code> <code>List[str]</code> <p>List of device IDs this goal applies to.</p> <code>created</code> <code>datetime</code> <p>When the goal was created.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the goal was last updated.</p> Source code in <code>app/models/goal.py</code> <pre><code>class EnergyGoalDB(BaseModel):\n    \"\"\"\n    Internal model representing energy goal data in the database.\n\n    Attributes:\n        id (str): Unique goal identifier.\n        user_id (str): ID of the user who owns the goal.\n        title (str): Title of the goal.\n        description (str): Detailed description of the goal.\n        type (GoalType): Type of energy goal.\n        target_value (float): Target value for the goal (e.g., kWh to save).\n        current_value (float): Current progress value.\n        progress_percentage (float): Percentage of goal completion.\n        timeframe (GoalTimeframe): Timeframe for the goal.\n        start_date (datetime): When the goal starts.\n        end_date (Optional[datetime]): When the goal ends.\n        status (GoalStatus): Current status of the goal.\n        related_devices (List[str]): List of device IDs this goal applies to.\n        created (datetime): When the goal was created.\n        updated (Optional[datetime]): When the goal was last updated.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    title: str\n    description: str\n    type: GoalType\n    target_value: float\n    current_value: float = 0.0\n    progress_percentage: float = 0.0\n    timeframe: GoalTimeframe\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    status: GoalStatus = GoalStatus.ACTIVE\n    related_devices: List[str] = Field(default_factory=list)\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalProgressUpdate","title":"<code>app.models.goal.EnergyGoalProgressUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model specifically for updating goal progress.</p> <p>Attributes:</p> Name Type Description <code>current_value</code> <code>float</code> <p>New current value for the goal.</p> Source code in <code>app/models/goal.py</code> <pre><code>class EnergyGoalProgressUpdate(BaseModel):\n    \"\"\"\n    Model specifically for updating goal progress.\n\n    Attributes:\n        current_value (float): New current value for the goal.\n    \"\"\"\n    current_value: float\n\n    @field_validator(\"current_value\")\n    @classmethod\n    def validate_current_value(cls, v: float) -&gt; float:\n        \"\"\"\n        Validate the current value.\n\n        Arguments:\n            v (float): Current value to be validated.\n\n        Returns:\n            float: Validated current value.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if v &lt; 0:\n            raise ValueError(\"Current value cannot be negative.\")\n        return v\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalProgressUpdate.validate_current_value","title":"<code>app.models.goal.EnergyGoalProgressUpdate.validate_current_value(v)</code>  <code>classmethod</code>","text":"<p>Validate the current value.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>float</code> <p>Current value to be validated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Validated current value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"current_value\")\n@classmethod\ndef validate_current_value(cls, v: float) -&gt; float:\n    \"\"\"\n    Validate the current value.\n\n    Arguments:\n        v (float): Current value to be validated.\n\n    Returns:\n        float: Validated current value.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if v &lt; 0:\n        raise ValueError(\"Current value cannot be negative.\")\n    return v\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalResponse","title":"<code>app.models.goal.EnergyGoalResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for energy goal data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique goal identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns the goal.</p> <code>title</code> <code>str</code> <p>Title of the goal.</p> <code>description</code> <code>str</code> <p>Detailed description of the goal.</p> <code>type</code> <code>GoalType</code> <p>Type of energy goal.</p> <code>target_value</code> <code>float</code> <p>Target value for the goal.</p> <code>current_value</code> <code>float</code> <p>Current progress value.</p> <code>progress_percentage</code> <code>float</code> <p>Percentage of goal completion.</p> <code>timeframe</code> <code>GoalTimeframe</code> <p>Timeframe for the goal.</p> <code>start_date</code> <code>datetime</code> <p>When the goal starts.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>When the goal ends.</p> <code>status</code> <code>GoalStatus</code> <p>Current status of the goal.</p> <code>related_devices</code> <code>List[str]</code> <p>List of device IDs this goal applies to.</p> <code>created</code> <code>datetime</code> <p>When the goal was created.</p> Source code in <code>app/models/goal.py</code> <pre><code>class EnergyGoalResponse(BaseModel):\n    \"\"\"\n    Model for energy goal data returned in API responses.\n\n    Attributes:\n        id (str): Unique goal identifier.\n        user_id (str): ID of the user who owns the goal.\n        title (str): Title of the goal.\n        description (str): Detailed description of the goal.\n        type (GoalType): Type of energy goal.\n        target_value (float): Target value for the goal.\n        current_value (float): Current progress value.\n        progress_percentage (float): Percentage of goal completion.\n        timeframe (GoalTimeframe): Timeframe for the goal.\n        start_date (datetime): When the goal starts.\n        end_date (Optional[datetime]): When the goal ends.\n        status (GoalStatus): Current status of the goal.\n        related_devices (List[str]): List of device IDs this goal applies to.\n        created (datetime): When the goal was created.\n    \"\"\"\n    id: str\n    user_id: str\n    title: str\n    description: str\n    type: str\n    target_value: float\n    current_value: float\n    progress_percentage: float\n    timeframe: str\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    status: str\n    related_devices: List[str]\n    created: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalUpdate","title":"<code>app.models.goal.EnergyGoalUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating energy goal information.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>Optional[str]</code> <p>Updated title of the goal.</p> <code>description</code> <code>Optional[str]</code> <p>Updated description of the goal.</p> <code>target_value</code> <code>Optional[float]</code> <p>Updated target value.</p> <code>current_value</code> <code>Optional[float]</code> <p>Updated current value.</p> <code>status</code> <code>Optional[GoalStatus]</code> <p>Updated goal status.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>Updated end date.</p> <code>related_devices</code> <code>Optional[List[str]]</code> <p>Updated list of related devices.</p> Source code in <code>app/models/goal.py</code> <pre><code>class EnergyGoalUpdate(BaseModel):\n    \"\"\"\n    Model for updating energy goal information.\n\n    Attributes:\n        title (Optional[str]): Updated title of the goal.\n        description (Optional[str]): Updated description of the goal.\n        target_value (Optional[float]): Updated target value.\n        current_value (Optional[float]): Updated current value.\n        status (Optional[GoalStatus]): Updated goal status.\n        end_date (Optional[datetime]): Updated end date.\n        related_devices (Optional[List[str]]): Updated list of related devices.\n    \"\"\"\n    title: Optional[str] = None\n    description: Optional[str] = None\n    target_value: Optional[float] = None\n    current_value: Optional[float] = None\n    status: Optional[GoalStatus] = None\n    end_date: Optional[datetime] = None\n    related_devices: Optional[List[str]] = None\n\n    @field_validator(\"title\")\n    @classmethod\n    def validate_title(cls, t: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate the goal title.\n\n        Arguments:\n            t (Optional[str]): Title to be validated.\n\n        Returns:\n            Optional[str]: Validated title.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(t, str):\n            if len(t) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters long.\")\n            if len(t) &gt; 100:\n                raise ValueError(\"Title must be less than 100 characters long.\")\n        return t\n\n    @field_validator(\"description\")\n    @classmethod\n    def validate_description(cls, d: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate the goal description.\n\n        Arguments:\n            d (Optional[str]): Description to be validated.\n\n        Returns:\n            Optional[str]: Validated description.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(d, str):\n            if len(d) &lt; 10:\n                raise ValueError(\"Description must be at least 10 characters long.\")\n            if len(d) &gt; 500:\n                raise ValueError(\"Description must be less than 500 characters long.\")\n        return d\n\n    @field_validator(\"target_value\")\n    @classmethod\n    def validate_target_value(cls, v: Optional[float]) -&gt; Optional[float]:\n        \"\"\"\n        Validate the target value.\n\n        Arguments:\n            v (Optional[float]): Target value to be validated.\n\n        Returns:\n            Optional[float]: Validated target value.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if v is not None and v &lt;= 0:\n            raise ValueError(\"Target value must be greater than 0.\")\n        return v\n\n    @field_validator(\"current_value\")\n    @classmethod\n    def validate_current_value(cls, v: Optional[float]) -&gt; Optional[float]:\n        \"\"\"\n        Validate the current value.\n\n        Arguments:\n            v (Optional[float]): Current value to be validated.\n\n        Returns:\n            Optional[float]: Validated current value.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if v is not None and v &lt; 0:\n            raise ValueError(\"Current value cannot be negative.\")\n        return v\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalUpdate.validate_current_value","title":"<code>app.models.goal.EnergyGoalUpdate.validate_current_value(v)</code>  <code>classmethod</code>","text":"<p>Validate the current value.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[float]</code> <p>Current value to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: Validated current value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"current_value\")\n@classmethod\ndef validate_current_value(cls, v: Optional[float]) -&gt; Optional[float]:\n    \"\"\"\n    Validate the current value.\n\n    Arguments:\n        v (Optional[float]): Current value to be validated.\n\n    Returns:\n        Optional[float]: Validated current value.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if v is not None and v &lt; 0:\n        raise ValueError(\"Current value cannot be negative.\")\n    return v\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalUpdate.validate_description","title":"<code>app.models.goal.EnergyGoalUpdate.validate_description(d)</code>  <code>classmethod</code>","text":"<p>Validate the goal description.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Optional[str]</code> <p>Description to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated description.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"description\")\n@classmethod\ndef validate_description(cls, d: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate the goal description.\n\n    Arguments:\n        d (Optional[str]): Description to be validated.\n\n    Returns:\n        Optional[str]: Validated description.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(d, str):\n        if len(d) &lt; 10:\n            raise ValueError(\"Description must be at least 10 characters long.\")\n        if len(d) &gt; 500:\n            raise ValueError(\"Description must be less than 500 characters long.\")\n    return d\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalUpdate.validate_target_value","title":"<code>app.models.goal.EnergyGoalUpdate.validate_target_value(v)</code>  <code>classmethod</code>","text":"<p>Validate the target value.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[float]</code> <p>Target value to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: Validated target value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"target_value\")\n@classmethod\ndef validate_target_value(cls, v: Optional[float]) -&gt; Optional[float]:\n    \"\"\"\n    Validate the target value.\n\n    Arguments:\n        v (Optional[float]): Target value to be validated.\n\n    Returns:\n        Optional[float]: Validated target value.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if v is not None and v &lt;= 0:\n        raise ValueError(\"Target value must be greater than 0.\")\n    return v\n</code></pre>"},{"location":"api/#app.models.goal.EnergyGoalUpdate.validate_title","title":"<code>app.models.goal.EnergyGoalUpdate.validate_title(t)</code>  <code>classmethod</code>","text":"<p>Validate the goal title.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Optional[str]</code> <p>Title to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated title.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/goal.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef validate_title(cls, t: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate the goal title.\n\n    Arguments:\n        t (Optional[str]): Title to be validated.\n\n    Returns:\n        Optional[str]: Validated title.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(t, str):\n        if len(t) &lt; 3:\n            raise ValueError(\"Title must be at least 3 characters long.\")\n        if len(t) &gt; 100:\n            raise ValueError(\"Title must be less than 100 characters long.\")\n    return t\n</code></pre>"},{"location":"api/#app.models.goal.GoalStatus","title":"<code>app.models.goal.GoalStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of goal statuses.</p> Source code in <code>app/models/goal.py</code> <pre><code>class GoalStatus(str, Enum):\n    \"\"\"\n    Enumeration of goal statuses.\n    \"\"\"\n    ACTIVE = \"active\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    PAUSED = \"paused\"\n</code></pre>"},{"location":"api/#app.models.goal.GoalTimeframe","title":"<code>app.models.goal.GoalTimeframe</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of goal timeframes.</p> Source code in <code>app/models/goal.py</code> <pre><code>class GoalTimeframe(str, Enum):\n    \"\"\"\n    Enumeration of goal timeframes.\n    \"\"\"\n    DAILY = \"daily\"\n    WEEKLY = \"weekly\"\n    MONTHLY = \"monthly\"\n    YEARLY = \"yearly\"\n    CUSTOM = \"custom\"\n</code></pre>"},{"location":"api/#app.models.goal.GoalType","title":"<code>app.models.goal.GoalType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of supported goal types.</p> Source code in <code>app/models/goal.py</code> <pre><code>class GoalType(str, Enum):\n    \"\"\"\n    Enumeration of supported goal types.\n    \"\"\"\n    ENERGY_SAVING = \"energy_saving\"\n    CONSUMPTION_LIMIT = \"consumption_limit\"\n    USAGE_REDUCTION = \"usage_reduction\"\n    PEAK_AVOIDANCE = \"peak_avoidance\"\n    RENEWABLE_USAGE = \"renewable_usage\"\n</code></pre>"},{"location":"api/#app.models.notification","title":"<code>app.models.notification</code>","text":"<p>Models for notification validation.</p>"},{"location":"api/#app.models.notification.CreateNotification","title":"<code>app.models.notification.CreateNotification</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for notification creation input.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>ID of the user to whom the notification belongs.</p> <code>title</code> <code>str</code> <p>Title of the notification.</p> <code>message</code> <code>str</code> <p>Content of the notification.</p> <code>type</code> <code>str</code> <p>Type of notification (e.g., alert, info, warning).</p> <code>priority</code> <code>str</code> <p>Priority level of the notification.</p> <code>source</code> <code>str</code> <p>Source of the notification (e.g., device, system).</p> <code>source_id</code> <code>Optional[str]</code> <p>ID of the source entity (if applicable).</p> Source code in <code>app/models/notification.py</code> <pre><code>class CreateNotification(BaseModel):\n    \"\"\"\n    Model for notification creation input.\n\n    Attributes:\n        user_id (str): ID of the user to whom the notification belongs.\n        title (str): Title of the notification.\n        message (str): Content of the notification.\n        type (str): Type of notification (e.g., alert, info, warning).\n        priority (str): Priority level of the notification.\n        source (str): Source of the notification (e.g., device, system).\n        source_id (Optional[str]): ID of the source entity (if applicable).\n    \"\"\"\n    user_id: str\n    title: str\n    message: str\n    type: Literal[\"alert\", \"info\", \"warning\", \"success\"] = \"info\"\n    priority: Literal[\"low\", \"medium\", \"high\"] = \"medium\"\n    source: Literal[\"device\", \"system\", \"automation\", \"goal\", \"security\"] = \"system\"\n    source_id: Optional[str] = None\n\n    @field_validator(\"title\")\n    @classmethod\n    def validate_title(cls, title: str) -&gt; str:\n        \"\"\"\n        Validate the notification title.\n\n        Arguments:\n            title (str): Title to be validated.\n\n        Returns:\n            str: Validated title.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(title) &lt; 3:\n            raise ValueError(\"Title must be at least 3 characters long.\")\n        if len(title) &gt; 100:\n            raise ValueError(\"Title must be less than 100 characters long.\")\n        return title\n\n    @field_validator(\"message\")\n    @classmethod\n    def validate_message(cls, message: str) -&gt; str:\n        \"\"\"\n        Validate the notification message.\n\n        Arguments:\n            message (str): Message to be validated.\n\n        Returns:\n            str: Validated message.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(message) &lt; 5:\n            raise ValueError(\"Message must be at least 5 characters long.\")\n        if len(message) &gt; 1000:\n            raise ValueError(\"Message must be less than 1000 characters long.\")\n        return message\n\n    @field_validator(\"user_id\")\n    @classmethod\n    def validate_user_id(cls, user_id: str) -&gt; str:\n        \"\"\"\n        Validate user_id format.\n\n        Arguments:\n            user_id (str): User ID to be validated.\n\n        Returns:\n            str: Validated user ID.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        try:\n            uuid.UUID(user_id)\n        except ValueError as v:\n            raise ValueError(\"User ID must be a valid UUID.\") from v\n        return user_id\n</code></pre>"},{"location":"api/#app.models.notification.CreateNotification.validate_message","title":"<code>app.models.notification.CreateNotification.validate_message(message)</code>  <code>classmethod</code>","text":"<p>Validate the notification message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/notification.py</code> <pre><code>@field_validator(\"message\")\n@classmethod\ndef validate_message(cls, message: str) -&gt; str:\n    \"\"\"\n    Validate the notification message.\n\n    Arguments:\n        message (str): Message to be validated.\n\n    Returns:\n        str: Validated message.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(message) &lt; 5:\n        raise ValueError(\"Message must be at least 5 characters long.\")\n    if len(message) &gt; 1000:\n        raise ValueError(\"Message must be less than 1000 characters long.\")\n    return message\n</code></pre>"},{"location":"api/#app.models.notification.CreateNotification.validate_title","title":"<code>app.models.notification.CreateNotification.validate_title(title)</code>  <code>classmethod</code>","text":"<p>Validate the notification title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated title.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/notification.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef validate_title(cls, title: str) -&gt; str:\n    \"\"\"\n    Validate the notification title.\n\n    Arguments:\n        title (str): Title to be validated.\n\n    Returns:\n        str: Validated title.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(title) &lt; 3:\n        raise ValueError(\"Title must be at least 3 characters long.\")\n    if len(title) &gt; 100:\n        raise ValueError(\"Title must be less than 100 characters long.\")\n    return title\n</code></pre>"},{"location":"api/#app.models.notification.CreateNotification.validate_user_id","title":"<code>app.models.notification.CreateNotification.validate_user_id(user_id)</code>  <code>classmethod</code>","text":"<p>Validate user_id format.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated user ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/notification.py</code> <pre><code>@field_validator(\"user_id\")\n@classmethod\ndef validate_user_id(cls, user_id: str) -&gt; str:\n    \"\"\"\n    Validate user_id format.\n\n    Arguments:\n        user_id (str): User ID to be validated.\n\n    Returns:\n        str: Validated user ID.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    try:\n        uuid.UUID(user_id)\n    except ValueError as v:\n        raise ValueError(\"User ID must be a valid UUID.\") from v\n    return user_id\n</code></pre>"},{"location":"api/#app.models.notification.NotificationBulkUpdate","title":"<code>app.models.notification.NotificationBulkUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for bulk updating notifications.</p> <p>Attributes:</p> Name Type Description <code>notification_ids</code> <code>list[str]</code> <p>List of notification IDs to update.</p> <code>read</code> <code>bool</code> <p>New read status for all specified notifications.</p> Source code in <code>app/models/notification.py</code> <pre><code>class NotificationBulkUpdate(BaseModel):\n    \"\"\"\n    Model for bulk updating notifications.\n\n    Attributes:\n        notification_ids (list[str]): List of notification IDs to update.\n        read (bool): New read status for all specified notifications.\n    \"\"\"\n    notification_ids: list[str]\n    read: bool = True\n\n    @field_validator(\"notification_ids\")\n    @classmethod\n    def validate_notification_ids(cls, notification_ids: list[str]) -&gt; list[str]:\n        \"\"\"\n        Validate notification IDs format and ensure the list is not empty.\n\n        Arguments:\n            notification_ids (list[str]): List of notification IDs to be validated.\n\n        Returns:\n            list[str]: Validated list of notification IDs.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if not notification_ids:\n            raise ValueError(\"At least one notification ID must be provided.\")\n\n        for notification_id in notification_ids:\n            try:\n                uuid.UUID(notification_id)\n            except ValueError:\n                raise ValueError(f\"Notification ID {notification_id} must be a valid UUID.\")\n\n        return notification_ids\n</code></pre>"},{"location":"api/#app.models.notification.NotificationBulkUpdate.validate_notification_ids","title":"<code>app.models.notification.NotificationBulkUpdate.validate_notification_ids(notification_ids)</code>  <code>classmethod</code>","text":"<p>Validate notification IDs format and ensure the list is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>notification_ids</code> <code>list[str]</code> <p>List of notification IDs to be validated.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Validated list of notification IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/notification.py</code> <pre><code>@field_validator(\"notification_ids\")\n@classmethod\ndef validate_notification_ids(cls, notification_ids: list[str]) -&gt; list[str]:\n    \"\"\"\n    Validate notification IDs format and ensure the list is not empty.\n\n    Arguments:\n        notification_ids (list[str]): List of notification IDs to be validated.\n\n    Returns:\n        list[str]: Validated list of notification IDs.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if not notification_ids:\n        raise ValueError(\"At least one notification ID must be provided.\")\n\n    for notification_id in notification_ids:\n        try:\n            uuid.UUID(notification_id)\n        except ValueError:\n            raise ValueError(f\"Notification ID {notification_id} must be a valid UUID.\")\n\n    return notification_ids\n</code></pre>"},{"location":"api/#app.models.notification.NotificationDB","title":"<code>app.models.notification.NotificationDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing notification data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique notification identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user to whom the notification belongs.</p> <code>title</code> <code>str</code> <p>Title of the notification.</p> <code>message</code> <code>str</code> <p>Content of the notification.</p> <code>type</code> <code>str</code> <p>Type of notification.</p> <code>priority</code> <code>str</code> <p>Priority level of the notification.</p> <code>source</code> <code>str</code> <p>Source of the notification.</p> <code>source_id</code> <code>Optional[str]</code> <p>ID of the source entity (if applicable).</p> <code>read</code> <code>bool</code> <p>Whether the notification has been read.</p> <code>timestamp</code> <code>datetime</code> <p>When the notification was created.</p> <code>read_timestamp</code> <code>Optional[datetime]</code> <p>When the notification was read.</p> Source code in <code>app/models/notification.py</code> <pre><code>class NotificationDB(BaseModel):\n    \"\"\"\n    Internal model representing notification data in the database.\n\n    Attributes:\n        id (str): Unique notification identifier.\n        user_id (str): ID of the user to whom the notification belongs.\n        title (str): Title of the notification.\n        message (str): Content of the notification.\n        type (str): Type of notification.\n        priority (str): Priority level of the notification.\n        source (str): Source of the notification.\n        source_id (Optional[str]): ID of the source entity (if applicable).\n        read (bool): Whether the notification has been read.\n        timestamp (datetime): When the notification was created.\n        read_timestamp (Optional[datetime]): When the notification was read.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    title: str\n    message: str\n    type: str\n    priority: str\n    source: str\n    source_id: Optional[str] = None\n    read: bool = False\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    read_timestamp: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.notification.NotificationResponse","title":"<code>app.models.notification.NotificationResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for notification data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique notification identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user to whom the notification belongs.</p> <code>title</code> <code>str</code> <p>Title of the notification.</p> <code>message</code> <code>str</code> <p>Content of the notification.</p> <code>type</code> <code>str</code> <p>Type of notification.</p> <code>priority</code> <code>str</code> <p>Priority level of the notification.</p> <code>source</code> <code>str</code> <p>Source of the notification.</p> <code>source_id</code> <code>Optional[str]</code> <p>ID of the source entity (if applicable).</p> <code>read</code> <code>bool</code> <p>Whether the notification has been read.</p> <code>timestamp</code> <code>datetime</code> <p>When the notification was created.</p> <code>read_timestamp</code> <code>Optional[datetime]</code> <p>When the notification was read.</p> Source code in <code>app/models/notification.py</code> <pre><code>class NotificationResponse(BaseModel):\n    \"\"\"\n    Model for notification data returned in API responses.\n\n    Attributes:\n        id (str): Unique notification identifier.\n        user_id (str): ID of the user to whom the notification belongs.\n        title (str): Title of the notification.\n        message (str): Content of the notification.\n        type (str): Type of notification.\n        priority (str): Priority level of the notification.\n        source (str): Source of the notification.\n        source_id (Optional[str]): ID of the source entity (if applicable).\n        read (bool): Whether the notification has been read.\n        timestamp (datetime): When the notification was created.\n        read_timestamp (Optional[datetime]): When the notification was read.\n    \"\"\"\n    id: str\n    user_id: str\n    title: str\n    message: str\n    type: str\n    priority: str\n    source: str\n    source_id: Optional[str] = None\n    read: bool\n    timestamp: datetime\n    read_timestamp: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.notification.NotificationUpdate","title":"<code>app.models.notification.NotificationUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating notification information.</p> <p>Attributes:</p> Name Type Description <code>read</code> <code>Optional[bool]</code> <p>Updated read status.</p> <code>read_timestamp</code> <code>Optional[datetime]</code> <p>Updated read timestamp.</p> Source code in <code>app/models/notification.py</code> <pre><code>class NotificationUpdate(BaseModel):\n    \"\"\"\n    Model for updating notification information.\n\n    Attributes:\n        read (Optional[bool]): Updated read status.\n        read_timestamp (Optional[datetime]): Updated read timestamp.\n    \"\"\"\n    read: Optional[bool] = None\n    read_timestamp: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.profile","title":"<code>app.models.profile</code>","text":"<p>Model for user profile validation &amp; handling.</p>"},{"location":"api/#app.models.profile.CreateProfile","title":"<code>app.models.profile.CreateProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for creating a new user profile.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>User identification.</p> <code>first_name</code> <code>str</code> <p>User's first name.</p> <code>last_name</code> <code>str</code> <p>User's last name.</p> <code>display_name</code> <code>Optional[str]</code> <p>User's display name.</p> <code>avatar</code> <code>Optional[str]</code> <p>URL to user's avatar image.</p> <code>phone_number</code> <code>Optional[str]</code> <p>User's phone number.</p> <code>timezone</code> <code>str</code> <p>User's timezone, defaults to UTC.</p> <code>temperature_unit</code> <code>str</code> <p>Preferred temperature unit (C/F).</p> <code>dark_mode</code> <code>bool</code> <p>UI theme preference.</p> Source code in <code>app/models/profile.py</code> <pre><code>class CreateProfile(BaseModel):\n    \"\"\"\n    Model for creating a new user profile.\n\n    Attributes:\n        user_id (str): User identification.\n        first_name (str): User's first name.\n        last_name (str): User's last name.\n        display_name (Optional[str]): User's display name.\n        avatar (Optional[str]): URL to user's avatar image.\n        phone_number (Optional[str]): User's phone number.\n        timezone (str): User's timezone, defaults to UTC.\n        temperature_unit (str): Preferred temperature unit (C/F).\n        dark_mode (bool): UI theme preference.\n    \"\"\"\n    user_id: str\n    first_name: str\n    last_name: str\n    display_name: Optional[str] = None\n    avatar: Optional[str] = None\n    phone_number: Optional[str] = None\n    timezone: str = \"UTC\"\n    temperature_unit: str = \"C\"\n    dark_mode: bool = False\n\n    @field_validator(\"temperature_unit\")\n    @classmethod\n    def validate_temp_unit(cls, u: str) -&gt; str:\n        \"\"\"\n        Validate temperature unit is either C(elsius) or F(ahrenheit).\n\n        Args:\n            u (str): Temperature unit.\n\n        Raises:\n            ValueError: Value must either be C or F.\n        \"\"\"\n        if u not in [\"C\", \"F\"]:\n            raise ValueError(\"Temperature unit must be either `C` or `F`.\")\n\n        return u\n\n    @field_validator(\"timezone\")\n    @classmethod\n    def validate_timezone(cls, t: str) -&gt; str:\n        \"\"\"\n        Basic timezone validation.\n\n        Args:\n            t (str): User's timezone.\n\n        Raises:\n            ValueError: User's timezone isn't valid.\n        \"\"\"\n        if not t:\n            raise ValueError(\"Timezone can't be empty.\")\n\n        return t\n</code></pre>"},{"location":"api/#app.models.profile.CreateProfile.validate_temp_unit","title":"<code>app.models.profile.CreateProfile.validate_temp_unit(u)</code>  <code>classmethod</code>","text":"<p>Validate temperature unit is either C(elsius) or F(ahrenheit).</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Temperature unit.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Value must either be C or F.</p> Source code in <code>app/models/profile.py</code> <pre><code>@field_validator(\"temperature_unit\")\n@classmethod\ndef validate_temp_unit(cls, u: str) -&gt; str:\n    \"\"\"\n    Validate temperature unit is either C(elsius) or F(ahrenheit).\n\n    Args:\n        u (str): Temperature unit.\n\n    Raises:\n        ValueError: Value must either be C or F.\n    \"\"\"\n    if u not in [\"C\", \"F\"]:\n        raise ValueError(\"Temperature unit must be either `C` or `F`.\")\n\n    return u\n</code></pre>"},{"location":"api/#app.models.profile.CreateProfile.validate_timezone","title":"<code>app.models.profile.CreateProfile.validate_timezone(t)</code>  <code>classmethod</code>","text":"<p>Basic timezone validation.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>User's timezone.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>User's timezone isn't valid.</p> Source code in <code>app/models/profile.py</code> <pre><code>@field_validator(\"timezone\")\n@classmethod\ndef validate_timezone(cls, t: str) -&gt; str:\n    \"\"\"\n    Basic timezone validation.\n\n    Args:\n        t (str): User's timezone.\n\n    Raises:\n        ValueError: User's timezone isn't valid.\n    \"\"\"\n    if not t:\n        raise ValueError(\"Timezone can't be empty.\")\n\n    return t\n</code></pre>"},{"location":"api/#app.models.profile.ProfileDB","title":"<code>app.models.profile.ProfileDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing profile data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique profile identifier.</p> <code>user_id</code> <code>str</code> <p>Unique associated user ID.</p> <code>first_name</code> <code>str</code> <p>User's first name.</p> <code>last_name</code> <code>str</code> <p>User's last name.</p> <code>display_name</code> <code>Optional[str]</code> <p>User's display name.</p> <code>avatar</code> <code>Optional[str]</code> <p>URL to user's avatar image.</p> <code>phone_number</code> <code>Optional[str]</code> <p>User's phone number.</p> <code>timezone</code> <code>str</code> <p>User's timezone, defaults to UTC.</p> <code>temperature_unit</code> <code>str</code> <p>Preferred temperature unit (C/F).</p> <code>dark_mode</code> <code>bool</code> <p>UI theme preference.</p> <code>favorite_devices</code> <code>List[str]</code> <p>IDs of favorite devices.</p> <code>created</code> <code>datetime</code> <p>Profile creation timestamp.</p> <code>updated</code> <code>Optional[datetime]</code> <p>Last update timestamp.</p> Source code in <code>app/models/profile.py</code> <pre><code>class ProfileDB(BaseModel):\n    \"\"\"\n    Internal model representing profile data in the database.\n\n    Attributes:\n        id (str): Unique profile identifier.\n        user_id (str): Unique associated user ID.\n        first_name (str): User's first name.\n        last_name (str): User's last name.\n        display_name (Optional[str]): User's display name.\n        avatar (Optional[str]): URL to user's avatar image.\n        phone_number (Optional[str]): User's phone number.\n        timezone (str): User's timezone, defaults to UTC.\n        temperature_unit (str): Preferred temperature unit (C/F).\n        dark_mode (bool): UI theme preference.\n        favorite_devices (List[str]): IDs of favorite devices.\n        created (datetime): Profile creation timestamp.\n        updated (Optional[datetime]): Last update timestamp.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    first_name: str\n    last_name: str\n    display_name: Optional[str] = None\n    avatar: Optional[str] = None\n    phone_number: Optional[str] = None\n    timezone: str = \"UTC\"\n    temperature_unit: str = \"C\"\n    dark_mode: bool = False\n    favorite_devices: List[str] = Field(default_factory=list)\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.profile.ProfileResponse","title":"<code>app.models.profile.ProfileResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for profile data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique profile identifier.</p> <code>user_id</code> <code>str</code> <p>Associated user ID.</p> <code>first_name</code> <code>str</code> <p>User's first name.</p> <code>last_name</code> <code>str</code> <p>User's last name.</p> <code>display_name</code> <code>Optional[str]</code> <p>User's display name.</p> <code>avatar</code> <code>Optional[str]</code> <p>URL to user's avatar image.</p> <code>timezone</code> <code>str</code> <p>User's timezone.</p> <code>temperature_unit</code> <code>str</code> <p>Preferred temperature unit.</p> <code>dark_mode</code> <code>bool</code> <p>UI theme preference.</p> <code>favorite_devices</code> <code>List[str]</code> <p>IDs of favorite devices.</p> Source code in <code>app/models/profile.py</code> <pre><code>class ProfileResponse(BaseModel):\n    \"\"\"\n    Model for profile data returned in API responses.\n\n    Attributes:\n        id (str): Unique profile identifier.\n        user_id (str): Associated user ID.\n        first_name (str): User's first name.\n        last_name (str): User's last name.\n        display_name (Optional[str]): User's display name.\n        avatar (Optional[str]): URL to user's avatar image.\n        timezone (str): User's timezone.\n        temperature_unit (str): Preferred temperature unit.\n        dark_mode (bool): UI theme preference.\n        favorite_devices (List[str]): IDs of favorite devices.\n    \"\"\"\n    id: str\n    user_id: str\n    first_name: str\n    last_name: str\n    display_name: Optional[str] = None\n    avatar: Optional[str] = None\n    timezone: str\n    temperature_unit: str\n    dark_mode: bool\n    favorite_devices: List[str] = []\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.profile.ProfileUpdate","title":"<code>app.models.profile.ProfileUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating profile information.</p> <p>All fields are optional since updates may only change some fields.</p> <p>Attributes:</p> Name Type Description <code>first_name</code> <code>Optional[str]</code> <p>User's first name.</p> <code>last_name</code> <code>Optional[str]</code> <p>User's last name.</p> <code>display_name</code> <code>Optional[str]</code> <p>User's display name.</p> <code>avatar</code> <code>Optional[str]</code> <p>URL to user's avatar image.</p> <code>phone_number</code> <code>Optional[str]</code> <p>User's phone number.</p> <code>timezone</code> <code>Optional[str]</code> <p>User's timezone.</p> <code>temperature_unit</code> <code>Optional[str]</code> <p>Preferred temperature unit.</p> <code>dark_mode</code> <code>Optional[bool]</code> <p>UI theme preference.</p> <code>favorite_devices</code> <code>Optional[List[str]]</code> <p>IDs of favorite devices.</p> Source code in <code>app/models/profile.py</code> <pre><code>class ProfileUpdate(BaseModel):\n    \"\"\"\n    Model for updating profile information.\n\n    All fields are optional since updates may only change some fields.\n\n    Attributes:\n        first_name (Optional[str]): User's first name.\n        last_name (Optional[str]): User's last name.\n        display_name (Optional[str]): User's display name.\n        avatar (Optional[str]): URL to user's avatar image.\n        phone_number (Optional[str]): User's phone number.\n        timezone (Optional[str]): User's timezone.\n        temperature_unit (Optional[str]): Preferred temperature unit.\n        dark_mode (Optional[bool]): UI theme preference.\n        favorite_devices (Optional[List[str]]): IDs of favorite devices.\n    \"\"\"\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    display_name: Optional[str] = None\n    avatar: Optional[str] = None\n    phone_number: Optional[str] = None\n    timezone: Optional[str] = None\n    temperature_unit: Optional[str] = None\n    dark_mode: Optional[bool] = None\n    favorite_devices: Optional[List[str]] = None\n\n    @field_validator(\"temperature_unit\")\n    @classmethod\n    def validate_temp_unit(cls, u: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate temperature unit is getting C or F if provided.\n\n        Args:\n            u (Optional[str]): Temperature unit.\n\n        Raises:\n            ValueError: If temperature unit isn't valid.\n        \"\"\"\n        if u is not None and u not in [\"C\", \"F\"]:\n            raise ValueError(\"Temperature unit must either be `C` or `F`.\")\n\n        return u\n\n    @field_validator(\"timezone\")\n    @classmethod\n    def validate_timezone(cls, t: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Basic timezone validation if provided.\n\n        Args:\n            t (Optional[str]): User's timezone.\n\n        Raises:\n            ValueError: If timezone isn't valid.\n        \"\"\"\n        if t == \"\":\n            raise ValueError(\"Timezone can't be an empty string\")\n\n        return t\n</code></pre>"},{"location":"api/#app.models.profile.ProfileUpdate.validate_temp_unit","title":"<code>app.models.profile.ProfileUpdate.validate_temp_unit(u)</code>  <code>classmethod</code>","text":"<p>Validate temperature unit is getting C or F if provided.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[str]</code> <p>Temperature unit.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If temperature unit isn't valid.</p> Source code in <code>app/models/profile.py</code> <pre><code>@field_validator(\"temperature_unit\")\n@classmethod\ndef validate_temp_unit(cls, u: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate temperature unit is getting C or F if provided.\n\n    Args:\n        u (Optional[str]): Temperature unit.\n\n    Raises:\n        ValueError: If temperature unit isn't valid.\n    \"\"\"\n    if u is not None and u not in [\"C\", \"F\"]:\n        raise ValueError(\"Temperature unit must either be `C` or `F`.\")\n\n    return u\n</code></pre>"},{"location":"api/#app.models.profile.ProfileUpdate.validate_timezone","title":"<code>app.models.profile.ProfileUpdate.validate_timezone(t)</code>  <code>classmethod</code>","text":"<p>Basic timezone validation if provided.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Optional[str]</code> <p>User's timezone.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If timezone isn't valid.</p> Source code in <code>app/models/profile.py</code> <pre><code>@field_validator(\"timezone\")\n@classmethod\ndef validate_timezone(cls, t: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Basic timezone validation if provided.\n\n    Args:\n        t (Optional[str]): User's timezone.\n\n    Raises:\n        ValueError: If timezone isn't valid.\n    \"\"\"\n    if t == \"\":\n        raise ValueError(\"Timezone can't be an empty string\")\n\n    return t\n</code></pre>"},{"location":"api/#app.models.report","title":"<code>app.models.report</code>","text":"<p>Models for report generation and storage.</p>"},{"location":"api/#app.models.report.CreateReportRequest","title":"<code>app.models.report.CreateReportRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for report generation request.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>ID of the user requesting the report.</p> <code>title</code> <code>Optional[str]</code> <p>Optional title for the report.</p> <code>format</code> <code>ReportFormat</code> <p>Desired report format.</p> <code>start_date</code> <code>Optional[str]</code> <p>Optional start date in YYYY-MM-DD format.</p> <code>end_date</code> <code>Optional[str]</code> <p>Optional end date in YYYY-MM-DD format.</p> <code>device_ids</code> <code>Optional[List[str]]</code> <p>Optional list of device IDs to include.</p> <code>report_type</code> <code>Optional[str]</code> <p>Type of report (e.g., \"energy\", \"usage\", \"anomaly\").</p> Source code in <code>app/models/report.py</code> <pre><code>class CreateReportRequest(BaseModel):\n    \"\"\"\n    Model for report generation request.\n\n    Attributes:\n        user_id (str): ID of the user requesting the report.\n        title (Optional[str]): Optional title for the report.\n        format (ReportFormat): Desired report format.\n        start_date (Optional[str]): Optional start date in YYYY-MM-DD format.\n        end_date (Optional[str]): Optional end date in YYYY-MM-DD format.\n        device_ids (Optional[List[str]]): Optional list of device IDs to include.\n        report_type (Optional[str]): Type of report (e.g., \"energy\", \"usage\", \"anomaly\").\n    \"\"\"\n    user_id: str\n    title: Optional[str] = None\n    format: ReportFormat = ReportFormat.PDF\n    start_date: Optional[str] = None\n    end_date: Optional[str] = None\n    device_ids: Optional[List[str]] = None\n    report_type: str = \"energy\"\n\n    @field_validator(\"title\")\n    @classmethod\n    def validate_title(cls, title: Optional[str]) -&gt; Optional[str]:\n        \"\"\"Validate report title.\"\"\"\n        if title is not None:\n            if len(title) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters long\")\n            if len(title) &gt; 100:\n                raise ValueError(\"Title must be less than 100 characters long\")\n        return title\n\n    @field_validator(\"start_date\", \"end_date\")\n    @classmethod\n    def validate_date_format(cls, date: Optional[str]) -&gt; Optional[str]:\n        \"\"\"Validate date format.\"\"\"\n        if date is not None:\n            try:\n                datetime.strptime(date, \"%Y-%m-%d\")\n            except ValueError:\n                raise ValueError(\"Date must be in YYYY-MM-DD format\")\n        return date\n</code></pre>"},{"location":"api/#app.models.report.CreateReportRequest.validate_date_format","title":"<code>app.models.report.CreateReportRequest.validate_date_format(date)</code>  <code>classmethod</code>","text":"<p>Validate date format.</p> Source code in <code>app/models/report.py</code> <pre><code>@field_validator(\"start_date\", \"end_date\")\n@classmethod\ndef validate_date_format(cls, date: Optional[str]) -&gt; Optional[str]:\n    \"\"\"Validate date format.\"\"\"\n    if date is not None:\n        try:\n            datetime.strptime(date, \"%Y-%m-%d\")\n        except ValueError:\n            raise ValueError(\"Date must be in YYYY-MM-DD format\")\n    return date\n</code></pre>"},{"location":"api/#app.models.report.CreateReportRequest.validate_title","title":"<code>app.models.report.CreateReportRequest.validate_title(title)</code>  <code>classmethod</code>","text":"<p>Validate report title.</p> Source code in <code>app/models/report.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef validate_title(cls, title: Optional[str]) -&gt; Optional[str]:\n    \"\"\"Validate report title.\"\"\"\n    if title is not None:\n        if len(title) &lt; 3:\n            raise ValueError(\"Title must be at least 3 characters long\")\n        if len(title) &gt; 100:\n            raise ValueError(\"Title must be less than 100 characters long\")\n    return title\n</code></pre>"},{"location":"api/#app.models.report.ReportDB","title":"<code>app.models.report.ReportDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing report data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique report identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who requested the report.</p> <code>title</code> <code>str</code> <p>Report title.</p> <code>format</code> <code>ReportFormat</code> <p>Report format.</p> <code>file_path</code> <code>Optional[str]</code> <p>Path to the generated report file.</p> <code>status</code> <code>ReportStatus</code> <p>Current status of report generation.</p> <code>start_date</code> <code>Optional[str]</code> <p>Start date for report data.</p> <code>end_date</code> <code>Optional[str]</code> <p>End date for report data.</p> <code>device_ids</code> <code>List[str]</code> <p>Device IDs included in the report.</p> <code>created</code> <code>datetime</code> <p>When the report was requested.</p> <code>completed</code> <code>Optional[datetime]</code> <p>When the report generation finished.</p> <code>error_message</code> <code>Optional[str]</code> <p>Error message if generation failed.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional report metadata.</p> Source code in <code>app/models/report.py</code> <pre><code>class ReportDB(BaseModel):\n    \"\"\"\n    Internal model representing report data in the database.\n\n    Attributes:\n        id (str): Unique report identifier.\n        user_id (str): ID of the user who requested the report.\n        title (str): Report title.\n        format (ReportFormat): Report format.\n        file_path (Optional[str]): Path to the generated report file.\n        status (ReportStatus): Current status of report generation.\n        start_date (Optional[str]): Start date for report data.\n        end_date (Optional[str]): End date for report data.\n        device_ids (List[str]): Device IDs included in the report.\n        created (datetime): When the report was requested.\n        completed (Optional[datetime]): When the report generation finished.\n        error_message (Optional[str]): Error message if generation failed.\n        metadata (Dict[str, Any]): Additional report metadata.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    title: str\n    format: ReportFormat\n    file_path: Optional[str] = None\n    status: ReportStatus = ReportStatus.PENDING\n    start_date: Optional[str] = None\n    end_date: Optional[str] = None\n    device_ids: List[str] = Field(default_factory=list)\n    report_type: str = \"energy\"\n    created: datetime = Field(default_factory=datetime.utcnow)\n    completed: Optional[datetime] = None\n    error_message: Optional[str] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.report.ReportFormat","title":"<code>app.models.report.ReportFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of supported report formats.</p> Source code in <code>app/models/report.py</code> <pre><code>class ReportFormat(str, Enum):\n    \"\"\"\n    Enumeration of supported report formats.\n    \"\"\"\n    PDF = \"pdf\"\n    CSV = \"csv\"\n</code></pre>"},{"location":"api/#app.models.report.ReportResponse","title":"<code>app.models.report.ReportResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for report data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique report identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who requested the report.</p> <code>title</code> <code>str</code> <p>Report title.</p> <code>format</code> <code>ReportFormat</code> <p>Report format.</p> <code>status</code> <code>ReportStatus</code> <p>Current status of report generation.</p> <code>created</code> <code>datetime</code> <p>When the report was requested.</p> <code>completed</code> <code>Optional[datetime]</code> <p>When the report generation finished.</p> <code>download_url</code> <code>Optional[str]</code> <p>URL to download the report file.</p> Source code in <code>app/models/report.py</code> <pre><code>class ReportResponse(BaseModel):\n    \"\"\"\n    Model for report data returned in API responses.\n\n    Attributes:\n        id (str): Unique report identifier.\n        user_id (str): ID of the user who requested the report.\n        title (str): Report title.\n        format (ReportFormat): Report format.\n        status (ReportStatus): Current status of report generation.\n        created (datetime): When the report was requested.\n        completed (Optional[datetime]): When the report generation finished.\n        download_url (Optional[str]): URL to download the report file.\n    \"\"\"\n    id: str\n    user_id: str\n    title: str\n    format: str\n    status: str\n    report_type: str\n    start_date: Optional[str] = None\n    end_date: Optional[str] = None\n    device_ids: List[str] = []\n    created: datetime\n    completed: Optional[datetime] = None\n    download_url: Optional[str] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.report.ReportStatus","title":"<code>app.models.report.ReportStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of report generation statuses.</p> Source code in <code>app/models/report.py</code> <pre><code>class ReportStatus(str, Enum):\n    \"\"\"\n    Enumeration of report generation statuses.\n    \"\"\"\n    PENDING = \"pending\"\n    GENERATING = \"generating\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n</code></pre>"},{"location":"api/#app.models.room","title":"<code>app.models.room</code>","text":"<p>Models for room validation.</p>"},{"location":"api/#app.models.room.CreateRoom","title":"<code>app.models.room.CreateRoom</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for room creation input.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Room's name.</p> <code>home_id</code> <code>str</code> <p>ID of the home this room belongs to.</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the room.</p> <code>type</code> <code>str</code> <p>Type of room (e.g., bedroom, kitchen, living room).</p> <code>floor</code> <code>int</code> <p>Floor number where the room is located.</p> <code>devices</code> <code>Optional[List[str]]</code> <p>List of device IDs in this room.</p> Source code in <code>app/models/room.py</code> <pre><code>class CreateRoom(BaseModel):\n    \"\"\"\n    Model for room creation input.\n\n    Attributes:\n        name (str): Room's name.\n        home_id (str): ID of the home this room belongs to.\n        description (Optional[str]): Optional description of the room.\n        type (str): Type of room (e.g., bedroom, kitchen, living room).\n        floor (int): Floor number where the room is located.\n        devices (Optional[List[str]]): List of device IDs in this room.\n    \"\"\"\n    name: str\n    home_id: str\n    description: Optional[str] = None\n    type: str\n    floor: int = 1  # Default to first floor\n    devices: Optional[List[str]] = []\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, n: str) -&gt; str:\n        \"\"\"\n        Validate room name according to requirements.\n\n        Arguments:\n            n (str): Room name to be validated.\n\n        Returns:\n            str: Validated room name.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(n) &lt; 2:\n            raise ValueError(\"Room name must be at least 2 characters long.\")\n        if len(n) &gt; 50:\n            raise ValueError(\"Room name must be less than 50 characters long.\")\n\n        return n\n\n    @field_validator(\"floor\")\n    @classmethod\n    def validate_floor(cls, f: int) -&gt; int:\n        \"\"\"\n        Validate floor number.\n\n        Arguments:\n            f (int): Floor number to be validated.\n\n        Returns:\n            int: Validated floor number.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if f &lt; -5:  # Allow for basement floors\n            raise ValueError(\"Floor number cannot be less than -5.\")\n        if f &gt; 200:  # Allow for very tall buildings\n            raise ValueError(\"Floor number cannot be greater than 200.\")\n\n        return f\n</code></pre>"},{"location":"api/#app.models.room.CreateRoom.validate_floor","title":"<code>app.models.room.CreateRoom.validate_floor(f)</code>  <code>classmethod</code>","text":"<p>Validate floor number.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>int</code> <p>Floor number to be validated.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Validated floor number.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/room.py</code> <pre><code>@field_validator(\"floor\")\n@classmethod\ndef validate_floor(cls, f: int) -&gt; int:\n    \"\"\"\n    Validate floor number.\n\n    Arguments:\n        f (int): Floor number to be validated.\n\n    Returns:\n        int: Validated floor number.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if f &lt; -5:  # Allow for basement floors\n        raise ValueError(\"Floor number cannot be less than -5.\")\n    if f &gt; 200:  # Allow for very tall buildings\n        raise ValueError(\"Floor number cannot be greater than 200.\")\n\n    return f\n</code></pre>"},{"location":"api/#app.models.room.CreateRoom.validate_name","title":"<code>app.models.room.CreateRoom.validate_name(n)</code>  <code>classmethod</code>","text":"<p>Validate room name according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>str</code> <p>Room name to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated room name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/room.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, n: str) -&gt; str:\n    \"\"\"\n    Validate room name according to requirements.\n\n    Arguments:\n        n (str): Room name to be validated.\n\n    Returns:\n        str: Validated room name.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(n) &lt; 2:\n        raise ValueError(\"Room name must be at least 2 characters long.\")\n    if len(n) &gt; 50:\n        raise ValueError(\"Room name must be less than 50 characters long.\")\n\n    return n\n</code></pre>"},{"location":"api/#app.models.room.RoomDB","title":"<code>app.models.room.RoomDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing room data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique room identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who owns this room.</p> <code>home_id</code> <code>str</code> <p>ID of the home this room belongs to.</p> <code>name</code> <code>str</code> <p>Room name.</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the room.</p> <code>type</code> <code>str</code> <p>Type of room.</p> <code>floor</code> <code>int</code> <p>Floor number where the room is located.</p> <code>devices</code> <code>List[str]</code> <p>List of device IDs in this room.</p> <code>created</code> <code>datetime</code> <p>When the room was created.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the room was last updated.</p> <code>active</code> <code>bool</code> <p>Whether the room is currently active.</p> Source code in <code>app/models/room.py</code> <pre><code>class RoomDB(BaseModel):\n    \"\"\"\n    Internal model representing room data in the database.\n\n    Attributes:\n        id (str): Unique room identifier.\n        user_id (str): ID of the user who owns this room.\n        home_id (str): ID of the home this room belongs to.\n        name (str): Room name.\n        description (Optional[str]): Optional description of the room.\n        type (str): Type of room.\n        floor (int): Floor number where the room is located.\n        devices (List[str]): List of device IDs in this room.\n        created (datetime): When the room was created.\n        updated (Optional[datetime]): When the room was last updated.\n        active (bool): Whether the room is currently active.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    home_id: str\n    name: str\n    description: Optional[str] = None\n    type: str\n    floor: int = 1\n    devices: List[str] = []\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n    active: bool = True\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.room.RoomResponse","title":"<code>app.models.room.RoomResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for room data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique room identifier.</p> <code>name</code> <code>str</code> <p>Room name.</p> <code>home_id</code> <code>str</code> <p>ID of the home this room belongs to.</p> <code>type</code> <code>str</code> <p>Type of room.</p> <code>floor</code> <code>int</code> <p>Floor number where the room is located.</p> <code>devices</code> <code>List[str]</code> <p>List of device IDs in this room.</p> <code>created</code> <code>datetime</code> <p>When the room was created.</p> Source code in <code>app/models/room.py</code> <pre><code>class RoomResponse(BaseModel):\n    \"\"\"\n    Model for room data returned in API responses.\n\n    Attributes:\n        id (str): Unique room identifier.\n        name (str): Room name.\n        home_id (str): ID of the home this room belongs to.\n        type (str): Type of room.\n        floor (int): Floor number where the room is located.\n        devices (List[str]): List of device IDs in this room.\n        created (datetime): When the room was created.\n    \"\"\"\n    id: str\n    name: str\n    home_id: str\n    type: str\n    floor: int\n    devices: List[str] = []\n    created: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.room.RoomUpdate","title":"<code>app.models.room.RoomUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating room information.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Updated room name.</p> <code>description</code> <code>Optional[str]</code> <p>Updated room description.</p> <code>type</code> <code>Optional[str]</code> <p>Updated room type.</p> <code>floor</code> <code>Optional[int]</code> <p>Updated floor number.</p> <code>devices</code> <code>Optional[List[str]]</code> <p>Updated list of device IDs.</p> Source code in <code>app/models/room.py</code> <pre><code>class RoomUpdate(BaseModel):\n    \"\"\"\n    Model for updating room information.\n\n    Attributes:\n        name (Optional[str]): Updated room name.\n        description (Optional[str]): Updated room description.\n        type (Optional[str]): Updated room type.\n        floor (Optional[int]): Updated floor number.\n        devices (Optional[List[str]]): Updated list of device IDs.\n    \"\"\"\n    name: Optional[str] = None\n    description: Optional[str] = None\n    type: Optional[str] = None\n    floor: Optional[int] = None\n    devices: Optional[List[str]] = None\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, n: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate room name according to requirements.\n\n        Arguments:\n            n (Optional[str]): Room name to be validated.\n\n        Returns:\n            Optional[str]: Validated room name.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(n, str):\n            if len(n) &lt; 2:\n                raise ValueError(\"Room name must be at least 2 characters long.\")\n            if len(n) &gt; 50:\n                raise ValueError(\"Room name must be less than 50 characters long.\")\n\n        return n\n\n    @field_validator(\"floor\")\n    @classmethod\n    def validate_floor(cls, f: Optional[int]) -&gt; Optional[int]:\n        \"\"\"\n        Validate floor number.\n\n        Arguments:\n            f (Optional[int]): Floor number to be validated.\n\n        Returns:\n            Optional[int]: Validated floor number.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(f, int):\n            if f &lt; -5:\n                raise ValueError(\"Floor number cannot be less than -5.\")\n            if f &gt; 200:\n                raise ValueError(\"Floor number cannot be greater than 200.\")\n\n        return f\n</code></pre>"},{"location":"api/#app.models.room.RoomUpdate.validate_floor","title":"<code>app.models.room.RoomUpdate.validate_floor(f)</code>  <code>classmethod</code>","text":"<p>Validate floor number.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Optional[int]</code> <p>Floor number to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Validated floor number.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/room.py</code> <pre><code>@field_validator(\"floor\")\n@classmethod\ndef validate_floor(cls, f: Optional[int]) -&gt; Optional[int]:\n    \"\"\"\n    Validate floor number.\n\n    Arguments:\n        f (Optional[int]): Floor number to be validated.\n\n    Returns:\n        Optional[int]: Validated floor number.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(f, int):\n        if f &lt; -5:\n            raise ValueError(\"Floor number cannot be less than -5.\")\n        if f &gt; 200:\n            raise ValueError(\"Floor number cannot be greater than 200.\")\n\n    return f\n</code></pre>"},{"location":"api/#app.models.room.RoomUpdate.validate_name","title":"<code>app.models.room.RoomUpdate.validate_name(n)</code>  <code>classmethod</code>","text":"<p>Validate room name according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Optional[str]</code> <p>Room name to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated room name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/room.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, n: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate room name according to requirements.\n\n    Arguments:\n        n (Optional[str]): Room name to be validated.\n\n    Returns:\n        Optional[str]: Validated room name.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(n, str):\n        if len(n) &lt; 2:\n            raise ValueError(\"Room name must be at least 2 characters long.\")\n        if len(n) &gt; 50:\n            raise ValueError(\"Room name must be less than 50 characters long.\")\n\n    return n\n</code></pre>"},{"location":"api/#app.models.suggestion","title":"<code>app.models.suggestion</code>","text":"<p>Models for suggestion validation.</p>"},{"location":"api/#app.models.suggestion.CreateSuggestion","title":"<code>app.models.suggestion.CreateSuggestion</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for suggestion creation input.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>ID of the user who receives the suggestion.</p> <code>title</code> <code>str</code> <p>Title of the suggestion.</p> <code>description</code> <code>str</code> <p>Detailed description of the suggestion.</p> <code>type</code> <code>SuggestionType</code> <p>Type of the suggestion.</p> <code>priority</code> <code>int</code> <p>Priority level (1-5, with 5 being highest).</p> <code>related_device_ids</code> <code>Optional[List[str]]</code> <p>IDs of related devices, if any.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>class CreateSuggestion(BaseModel):\n    \"\"\"\n    Model for suggestion creation input.\n\n    Attributes:\n        user_id (str): ID of the user who receives the suggestion.\n        title (str): Title of the suggestion.\n        description (str): Detailed description of the suggestion.\n        type (SuggestionType): Type of the suggestion.\n        priority (int): Priority level (1-5, with 5 being highest).\n        related_device_ids (Optional[List[str]]): IDs of related devices, if any.\n    \"\"\"\n    user_id: str\n    title: str\n    description: str\n    type: SuggestionType\n    priority: int = 3  # Default to medium priority\n    related_device_ids: Optional[List[str]] = None\n\n    @field_validator(\"title\")\n    @classmethod\n    def validate_title(cls, t: str) -&gt; str:\n        \"\"\"\n        Validate suggestion title.\n\n        Arguments:\n            t (str): Title to be validated.\n\n        Returns:\n            str: Validated title.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(t) &lt; 3:\n            raise ValueError(\"Title must be at least 3 characters long.\")\n        if len(t) &gt; 100:\n            raise ValueError(\"Title must be less than 100 characters long.\")\n\n        return t\n\n    @field_validator(\"description\")\n    @classmethod\n    def validate_description(cls, d: str) -&gt; str:\n        \"\"\"\n        Validate suggestion description.\n\n        Arguments:\n            d (str): Description to be validated.\n\n        Returns:\n            str: Validated description.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(d) &lt; 10:\n            raise ValueError(\"Description must be at least 10 characters long.\")\n        if len(d) &gt; 1000:\n            raise ValueError(\"Description must be less than 1000 characters long.\")\n\n        return d\n\n    @field_validator(\"priority\")\n    @classmethod\n    def validate_priority(cls, p: int) -&gt; int:\n        \"\"\"\n        Validate priority level.\n\n        Arguments:\n            p (int): Priority to be validated.\n\n        Returns:\n            int: Validated priority.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if p &lt; 1 or p &gt; 5:\n            raise ValueError(\"Priority must be between 1 and 5.\")\n        return p\n\n    @field_validator(\"user_id\")\n    @classmethod\n    def validate_user_id(cls, uid: str) -&gt; str:\n        \"\"\"\n        Validate user ID format.\n\n        Arguments:\n            uid (str): User ID to be validated.\n\n        Returns:\n            str: Validated user ID.\n\n        Raises:\n            ValueError: Validation encountered an invalid format.\n        \"\"\"\n        try:\n            uuid.UUID(uid)\n        except ValueError as exc:\n            raise ValueError(\"Invalid user_id format. Must be a valid UUID.\") from exc\n\n        return uid\n\n    @field_validator(\"related_device_ids\")\n    @classmethod\n    def validate_device_ids(cls, devices: Optional[List[str]]) -&gt; Optional[List[str]]:\n        \"\"\"\n        Validate device IDs format.\n\n        Arguments:\n            devices (Optional[List[str]]): Device IDs to be validated.\n\n        Returns:\n            Optional[List[str]]: Validated device IDs.\n\n        Raises:\n            ValueError: Validation encountered an invalid format.\n        \"\"\"\n        if devices:\n            for device_id in devices:\n                try:\n                    uuid.UUID(device_id)\n                except ValueError as exc:\n                    raise ValueError(f\"Invalid device ID format: {device_id}. Must be a valid UUID.\") from exc\n\n        return devices\n</code></pre>"},{"location":"api/#app.models.suggestion.CreateSuggestion.validate_description","title":"<code>app.models.suggestion.CreateSuggestion.validate_description(d)</code>  <code>classmethod</code>","text":"<p>Validate suggestion description.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>str</code> <p>Description to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated description.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"description\")\n@classmethod\ndef validate_description(cls, d: str) -&gt; str:\n    \"\"\"\n    Validate suggestion description.\n\n    Arguments:\n        d (str): Description to be validated.\n\n    Returns:\n        str: Validated description.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(d) &lt; 10:\n        raise ValueError(\"Description must be at least 10 characters long.\")\n    if len(d) &gt; 1000:\n        raise ValueError(\"Description must be less than 1000 characters long.\")\n\n    return d\n</code></pre>"},{"location":"api/#app.models.suggestion.CreateSuggestion.validate_device_ids","title":"<code>app.models.suggestion.CreateSuggestion.validate_device_ids(devices)</code>  <code>classmethod</code>","text":"<p>Validate device IDs format.</p> <p>Parameters:</p> Name Type Description Default <code>devices</code> <code>Optional[List[str]]</code> <p>Device IDs to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>Optional[List[str]]: Validated device IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered an invalid format.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"related_device_ids\")\n@classmethod\ndef validate_device_ids(cls, devices: Optional[List[str]]) -&gt; Optional[List[str]]:\n    \"\"\"\n    Validate device IDs format.\n\n    Arguments:\n        devices (Optional[List[str]]): Device IDs to be validated.\n\n    Returns:\n        Optional[List[str]]: Validated device IDs.\n\n    Raises:\n        ValueError: Validation encountered an invalid format.\n    \"\"\"\n    if devices:\n        for device_id in devices:\n            try:\n                uuid.UUID(device_id)\n            except ValueError as exc:\n                raise ValueError(f\"Invalid device ID format: {device_id}. Must be a valid UUID.\") from exc\n\n    return devices\n</code></pre>"},{"location":"api/#app.models.suggestion.CreateSuggestion.validate_priority","title":"<code>app.models.suggestion.CreateSuggestion.validate_priority(p)</code>  <code>classmethod</code>","text":"<p>Validate priority level.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>Priority to be validated.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Validated priority.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"priority\")\n@classmethod\ndef validate_priority(cls, p: int) -&gt; int:\n    \"\"\"\n    Validate priority level.\n\n    Arguments:\n        p (int): Priority to be validated.\n\n    Returns:\n        int: Validated priority.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if p &lt; 1 or p &gt; 5:\n        raise ValueError(\"Priority must be between 1 and 5.\")\n    return p\n</code></pre>"},{"location":"api/#app.models.suggestion.CreateSuggestion.validate_title","title":"<code>app.models.suggestion.CreateSuggestion.validate_title(t)</code>  <code>classmethod</code>","text":"<p>Validate suggestion title.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>Title to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated title.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef validate_title(cls, t: str) -&gt; str:\n    \"\"\"\n    Validate suggestion title.\n\n    Arguments:\n        t (str): Title to be validated.\n\n    Returns:\n        str: Validated title.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(t) &lt; 3:\n        raise ValueError(\"Title must be at least 3 characters long.\")\n    if len(t) &gt; 100:\n        raise ValueError(\"Title must be less than 100 characters long.\")\n\n    return t\n</code></pre>"},{"location":"api/#app.models.suggestion.CreateSuggestion.validate_user_id","title":"<code>app.models.suggestion.CreateSuggestion.validate_user_id(uid)</code>  <code>classmethod</code>","text":"<p>Validate user ID format.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>User ID to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated user ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered an invalid format.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"user_id\")\n@classmethod\ndef validate_user_id(cls, uid: str) -&gt; str:\n    \"\"\"\n    Validate user ID format.\n\n    Arguments:\n        uid (str): User ID to be validated.\n\n    Returns:\n        str: Validated user ID.\n\n    Raises:\n        ValueError: Validation encountered an invalid format.\n    \"\"\"\n    try:\n        uuid.UUID(uid)\n    except ValueError as exc:\n        raise ValueError(\"Invalid user_id format. Must be a valid UUID.\") from exc\n\n    return uid\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionDB","title":"<code>app.models.suggestion.SuggestionDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing suggestion data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique suggestion identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who receives the suggestion.</p> <code>title</code> <code>str</code> <p>Title of the suggestion.</p> <code>description</code> <code>str</code> <p>Detailed description of the suggestion.</p> <code>type</code> <code>SuggestionType</code> <p>Type of the suggestion.</p> <code>priority</code> <code>int</code> <p>Priority level (1-5, with 5 being highest).</p> <code>status</code> <code>SuggestionStatus</code> <p>Current status of the suggestion.</p> <code>related_device_ids</code> <code>Optional[List[str]]</code> <p>IDs of related devices, if any.</p> <code>created</code> <code>datetime</code> <p>When the suggestion was created.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the suggestion was last updated.</p> <code>implemented_date</code> <code>Optional[datetime]</code> <p>When the suggestion was implemented.</p> <code>user_feedback</code> <code>Optional[str]</code> <p>Feedback from the user on the suggestion.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>class SuggestionDB(BaseModel):\n    \"\"\"\n    Internal model representing suggestion data in the database.\n\n    Attributes:\n        id (str): Unique suggestion identifier.\n        user_id (str): ID of the user who receives the suggestion.\n        title (str): Title of the suggestion.\n        description (str): Detailed description of the suggestion.\n        type (SuggestionType): Type of the suggestion.\n        priority (int): Priority level (1-5, with 5 being highest).\n        status (SuggestionStatus): Current status of the suggestion.\n        related_device_ids (Optional[List[str]]): IDs of related devices, if any.\n        created (datetime): When the suggestion was created.\n        updated (Optional[datetime]): When the suggestion was last updated.\n        implemented_date (Optional[datetime]): When the suggestion was implemented.\n        user_feedback (Optional[str]): Feedback from the user on the suggestion.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    title: str\n    description: str\n    type: SuggestionType\n    priority: int\n    status: SuggestionStatus = SuggestionStatus.PENDING\n    related_device_ids: Optional[List[str]] = None\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n    implemented_date: Optional[datetime] = None\n    user_feedback: Optional[str] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionResponse","title":"<code>app.models.suggestion.SuggestionResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for suggestion data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique suggestion identifier.</p> <code>user_id</code> <code>str</code> <p>ID of the user who receives the suggestion.</p> <code>title</code> <code>str</code> <p>Title of the suggestion.</p> <code>description</code> <code>str</code> <p>Description of the suggestion.</p> <code>type</code> <code>SuggestionType</code> <p>Type of the suggestion.</p> <code>priority</code> <code>int</code> <p>Priority level.</p> <code>status</code> <code>SuggestionStatus</code> <p>Current status of the suggestion.</p> <code>created</code> <code>datetime</code> <p>When the suggestion was created.</p> <code>implemented_date</code> <code>Optional[datetime]</code> <p>When the suggestion was implemented, if applicable.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>class SuggestionResponse(BaseModel):\n    \"\"\"\n    Model for suggestion data returned in API responses.\n\n    Attributes:\n        id (str): Unique suggestion identifier.\n        user_id (str): ID of the user who receives the suggestion.\n        title (str): Title of the suggestion.\n        description (str): Description of the suggestion.\n        type (SuggestionType): Type of the suggestion.\n        priority (int): Priority level.\n        status (SuggestionStatus): Current status of the suggestion.\n        created (datetime): When the suggestion was created.\n        implemented_date (Optional[datetime]): When the suggestion was implemented, if applicable.\n    \"\"\"\n    id: str\n    user_id: str\n    title: str\n    description: str\n    type: SuggestionType\n    priority: int\n    status: SuggestionStatus\n    created: datetime\n    related_device_ids: Optional[List[str]] = None\n    implemented_date: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionStatus","title":"<code>app.models.suggestion.SuggestionStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for suggestion status.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>class SuggestionStatus(str, Enum):\n    \"\"\"\n    Enum for suggestion status.\n    \"\"\"\n    PENDING = \"pending\"\n    ACCEPTED = \"accepted\"\n    REJECTED = \"rejected\"\n    IMPLEMENTED = \"implemented\"\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionType","title":"<code>app.models.suggestion.SuggestionType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for suggestion types.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>class SuggestionType(str, Enum):\n    \"\"\"\n    Enum for suggestion types.\n    \"\"\"\n    ENERGY_SAVING = \"energy_saving\"\n    SECURITY = \"security\"\n    COMFORT = \"comfort\"\n    AUTOMATION = \"automation\"\n    OTHER = \"other\"\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionUpdate","title":"<code>app.models.suggestion.SuggestionUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating suggestion information.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>Optional[str]</code> <p>Updated title.</p> <code>description</code> <code>Optional[str]</code> <p>Updated description.</p> <code>priority</code> <code>Optional[int]</code> <p>Updated priority.</p> <code>status</code> <code>Optional[SuggestionStatus]</code> <p>Updated status.</p> <code>related_device_ids</code> <code>Optional[List[str]]</code> <p>Updated related device IDs.</p> <code>user_feedback</code> <code>Optional[str]</code> <p>User feedback on the suggestion.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>class SuggestionUpdate(BaseModel):\n    \"\"\"\n    Model for updating suggestion information.\n\n    Attributes:\n        title (Optional[str]): Updated title.\n        description (Optional[str]): Updated description.\n        priority (Optional[int]): Updated priority.\n        status (Optional[SuggestionStatus]): Updated status.\n        related_device_ids (Optional[List[str]]): Updated related device IDs.\n        user_feedback (Optional[str]): User feedback on the suggestion.\n    \"\"\"\n    title: Optional[str] = None\n    description: Optional[str] = None\n    priority: Optional[int] = None\n    status: Optional[SuggestionStatus] = None\n    related_device_ids: Optional[List[str]] = None\n    user_feedback: Optional[str] = None\n\n    @field_validator(\"title\")\n    @classmethod\n    def validate_title(cls, t: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate suggestion title.\n\n        Arguments:\n            t (Optional[str]): Title to be validated.\n\n        Returns:\n            Optional[str]: Validated title.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(t, str):\n            if len(t) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters long.\")\n            if len(t) &gt; 100:\n                raise ValueError(\"Title must be less than 100 characters long.\")\n\n        return t\n\n    @field_validator(\"description\")\n    @classmethod\n    def validate_description(cls, d: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate suggestion description.\n\n        Arguments:\n            d (Optional[str]): Description to be validated.\n\n        Returns:\n            Optional[str]: Validated description.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(d, str):\n            if len(d) &lt; 10:\n                raise ValueError(\"Description must be at least 10 characters long.\")\n            if len(d) &gt; 1000:\n                raise ValueError(\"Description must be less than 1000 characters long.\")\n\n        return d\n\n    @field_validator(\"priority\")\n    @classmethod\n    def validate_priority(cls, p: Optional[int]) -&gt; Optional[int]:\n        \"\"\"\n        Validate priority level.\n\n        Arguments:\n            p (Optional[int]): Priority to be validated.\n\n        Returns:\n            Optional[int]: Validated priority.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(p, int) and (p &lt; 1 or p &gt; 5):\n            raise ValueError(\"Priority must be between 1 and 5.\")\n\n        return p\n\n    @field_validator(\"user_feedback\")\n    @classmethod\n    def validate_feedback(cls, f: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate user feedback.\n\n        Arguments:\n            f (Optional[str]): Feedback to be validated.\n\n        Returns:\n            Optional[str]: Validated feedback.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(f, str) and len(f) &gt; 500:\n            raise ValueError(\"Feedback must be less than 500 characters long.\")\n\n        return f\n\n    @field_validator(\"related_device_ids\")\n    @classmethod\n    def validate_device_ids(cls, devices: Optional[List[str]]) -&gt; Optional[List[str]]:\n        \"\"\"\n        Validate device IDs format.\n\n        Arguments:\n            devices (Optional[List[str]]): Device IDs to be validated.\n\n        Returns:\n            Optional[List[str]]: Validated device IDs.\n\n        Raises:\n            ValueError: Validation encountered an invalid format.\n        \"\"\"\n        if devices:\n            for device_id in devices:\n                try:\n                    uuid.UUID(device_id)\n                except ValueError as exc:\n                    raise ValueError(f\"Invalid device ID format: {device_id}. Must be a valid UUID.\") from exc\n\n        return devices\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionUpdate.validate_description","title":"<code>app.models.suggestion.SuggestionUpdate.validate_description(d)</code>  <code>classmethod</code>","text":"<p>Validate suggestion description.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Optional[str]</code> <p>Description to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated description.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"description\")\n@classmethod\ndef validate_description(cls, d: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate suggestion description.\n\n    Arguments:\n        d (Optional[str]): Description to be validated.\n\n    Returns:\n        Optional[str]: Validated description.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(d, str):\n        if len(d) &lt; 10:\n            raise ValueError(\"Description must be at least 10 characters long.\")\n        if len(d) &gt; 1000:\n            raise ValueError(\"Description must be less than 1000 characters long.\")\n\n    return d\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionUpdate.validate_device_ids","title":"<code>app.models.suggestion.SuggestionUpdate.validate_device_ids(devices)</code>  <code>classmethod</code>","text":"<p>Validate device IDs format.</p> <p>Parameters:</p> Name Type Description Default <code>devices</code> <code>Optional[List[str]]</code> <p>Device IDs to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>Optional[List[str]]: Validated device IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered an invalid format.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"related_device_ids\")\n@classmethod\ndef validate_device_ids(cls, devices: Optional[List[str]]) -&gt; Optional[List[str]]:\n    \"\"\"\n    Validate device IDs format.\n\n    Arguments:\n        devices (Optional[List[str]]): Device IDs to be validated.\n\n    Returns:\n        Optional[List[str]]: Validated device IDs.\n\n    Raises:\n        ValueError: Validation encountered an invalid format.\n    \"\"\"\n    if devices:\n        for device_id in devices:\n            try:\n                uuid.UUID(device_id)\n            except ValueError as exc:\n                raise ValueError(f\"Invalid device ID format: {device_id}. Must be a valid UUID.\") from exc\n\n    return devices\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionUpdate.validate_feedback","title":"<code>app.models.suggestion.SuggestionUpdate.validate_feedback(f)</code>  <code>classmethod</code>","text":"<p>Validate user feedback.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Optional[str]</code> <p>Feedback to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated feedback.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"user_feedback\")\n@classmethod\ndef validate_feedback(cls, f: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate user feedback.\n\n    Arguments:\n        f (Optional[str]): Feedback to be validated.\n\n    Returns:\n        Optional[str]: Validated feedback.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(f, str) and len(f) &gt; 500:\n        raise ValueError(\"Feedback must be less than 500 characters long.\")\n\n    return f\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionUpdate.validate_priority","title":"<code>app.models.suggestion.SuggestionUpdate.validate_priority(p)</code>  <code>classmethod</code>","text":"<p>Validate priority level.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Optional[int]</code> <p>Priority to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Validated priority.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"priority\")\n@classmethod\ndef validate_priority(cls, p: Optional[int]) -&gt; Optional[int]:\n    \"\"\"\n    Validate priority level.\n\n    Arguments:\n        p (Optional[int]): Priority to be validated.\n\n    Returns:\n        Optional[int]: Validated priority.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(p, int) and (p &lt; 1 or p &gt; 5):\n        raise ValueError(\"Priority must be between 1 and 5.\")\n\n    return p\n</code></pre>"},{"location":"api/#app.models.suggestion.SuggestionUpdate.validate_title","title":"<code>app.models.suggestion.SuggestionUpdate.validate_title(t)</code>  <code>classmethod</code>","text":"<p>Validate suggestion title.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Optional[str]</code> <p>Title to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Validated title.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/suggestion.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef validate_title(cls, t: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate suggestion title.\n\n    Arguments:\n        t (Optional[str]): Title to be validated.\n\n    Returns:\n        Optional[str]: Validated title.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(t, str):\n        if len(t) &lt; 3:\n            raise ValueError(\"Title must be at least 3 characters long.\")\n        if len(t) &gt; 100:\n            raise ValueError(\"Title must be less than 100 characters long.\")\n\n    return t\n</code></pre>"},{"location":"api/#app.models.usage","title":"<code>app.models.usage</code>","text":"<p>Models for device usage tracking.</p>"},{"location":"api/#app.models.usage.CreateUsage","title":"<code>app.models.usage.CreateUsage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for creating new device usage records.</p> <p>Attributes:</p> Name Type Description <code>device_id</code> <code>str</code> <p>ID of the device being monitored.</p> <code>metrics</code> <code>Dict[str, Any]</code> <p>Usage metrics specific to device type.</p> <code>timestamp</code> <code>Optional[datetime]</code> <p>When the usage was recorded (defaults to now).</p> <code>duration</code> <code>Optional[int]</code> <p>Duration of usage in seconds.</p> <code>energy_consumed</code> <code>Optional[float]</code> <p>Energy used in kWh.</p> <code>status</code> <code>Optional[str]</code> <p>Device status during measurement.</p> Source code in <code>app/models/usage.py</code> <pre><code>class CreateUsage(BaseModel):\n    \"\"\"\n    Model for creating new device usage records.\n\n    Attributes:\n        device_id (str): ID of the device being monitored.\n        metrics (Dict[str, Any]): Usage metrics specific to device type.\n        timestamp (Optional[datetime]): When the usage was recorded (defaults to now).\n        duration (Optional[int]): Duration of usage in seconds.\n        energy_consumed (Optional[float]): Energy used in kWh.\n        status (Optional[str]): Device status during measurement.\n    \"\"\"\n    device_id: str\n    metrics: Dict[str, Any]\n    timestamp: Optional[datetime] = None\n    duration: Optional[int] = None\n    energy_consumed: Optional[float] = None\n    status: Optional[str] = None\n\n    @field_validator(\"device_id\")\n    @classmethod\n    def validate_device_id(cls, v: str) -&gt; str:\n        \"\"\"\n        Validate device_id format.\n\n        Args:\n            v (str): Device ID to be validated.\n\n        Returns:\n            str: Validated device ID.\n\n        Raises:\n            ValueError: Invalid device ID format.\n        \"\"\"\n        if not v or not isinstance(v, str):\n            raise ValueError(\"Device ID must be a valid string\")\n\n        return v\n\n    @field_validator(\"energy_consumed\")\n    @classmethod\n    def validate_energy_consumed(cls, v: Optional[float]) -&gt; Optional[float]:\n        \"\"\"\n        Validate energy consumption is positive if provided.\n\n        Args:\n            v (Optional[float]): Energy consumption to be validated.\n\n        Returns:\n            Optional[float]: Validated energy consumption data.\n\n        Raises:\n            ValueError: Negative energy consumption.\n        \"\"\"\n        if v is not None and v &lt; 0:\n            raise ValueError(\"Energy consumption cannot be negative\")\n\n        return v\n\n    @field_validator(\"duration\")\n    @classmethod\n    def validate_duration(cls, v: Optional[int]) -&gt; Optional[int]:\n        \"\"\"\n        Validate duration is positive if provided.\n\n        Args:\n            v (Optional[int]): Energy consumption duration to be validated.\n\n        Returns:\n            Optional[int]: Validated energy duration data.\n\n        Raises:\n            ValueError: Negative duration.\n        \"\"\"\n        if v is not None and v &lt; 0:\n            raise ValueError(\"Duration cannot be negative\")\n\n        return v\n</code></pre>"},{"location":"api/#app.models.usage.CreateUsage.validate_device_id","title":"<code>app.models.usage.CreateUsage.validate_device_id(v)</code>  <code>classmethod</code>","text":"<p>Validate device_id format.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Device ID to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated device ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid device ID format.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"device_id\")\n@classmethod\ndef validate_device_id(cls, v: str) -&gt; str:\n    \"\"\"\n    Validate device_id format.\n\n    Args:\n        v (str): Device ID to be validated.\n\n    Returns:\n        str: Validated device ID.\n\n    Raises:\n        ValueError: Invalid device ID format.\n    \"\"\"\n    if not v or not isinstance(v, str):\n        raise ValueError(\"Device ID must be a valid string\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.usage.CreateUsage.validate_duration","title":"<code>app.models.usage.CreateUsage.validate_duration(v)</code>  <code>classmethod</code>","text":"<p>Validate duration is positive if provided.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[int]</code> <p>Energy consumption duration to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Validated energy duration data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Negative duration.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"duration\")\n@classmethod\ndef validate_duration(cls, v: Optional[int]) -&gt; Optional[int]:\n    \"\"\"\n    Validate duration is positive if provided.\n\n    Args:\n        v (Optional[int]): Energy consumption duration to be validated.\n\n    Returns:\n        Optional[int]: Validated energy duration data.\n\n    Raises:\n        ValueError: Negative duration.\n    \"\"\"\n    if v is not None and v &lt; 0:\n        raise ValueError(\"Duration cannot be negative\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.usage.CreateUsage.validate_energy_consumed","title":"<code>app.models.usage.CreateUsage.validate_energy_consumed(v)</code>  <code>classmethod</code>","text":"<p>Validate energy consumption is positive if provided.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[float]</code> <p>Energy consumption to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: Validated energy consumption data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Negative energy consumption.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"energy_consumed\")\n@classmethod\ndef validate_energy_consumed(cls, v: Optional[float]) -&gt; Optional[float]:\n    \"\"\"\n    Validate energy consumption is positive if provided.\n\n    Args:\n        v (Optional[float]): Energy consumption to be validated.\n\n    Returns:\n        Optional[float]: Validated energy consumption data.\n\n    Raises:\n        ValueError: Negative energy consumption.\n    \"\"\"\n    if v is not None and v &lt; 0:\n        raise ValueError(\"Energy consumption cannot be negative\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageAggregateResponse","title":"<code>app.models.usage.UsageAggregateResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for aggregated usage statistics returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>device_id</code> <code>str</code> <p>ID of the device being monitored.</p> <code>start_date</code> <code>datetime</code> <p>Start of the aggregation period.</p> <code>end_date</code> <code>datetime</code> <p>End of the aggregation period.</p> <code>total_duration</code> <code>int</code> <p>Total usage duration in seconds.</p> <code>total_energy</code> <code>float</code> <p>Total energy consumed in kWh.</p> <code>average_metrics</code> <code>Dict[str, float]</code> <p>Average of numeric metrics.</p> <code>usage_count</code> <code>int</code> <p>Number of usage records in the period.</p> Source code in <code>app/models/usage.py</code> <pre><code>class UsageAggregateResponse(BaseModel):\n    \"\"\"\n    Model for aggregated usage statistics returned in API responses.\n\n    Attributes:\n        device_id (str): ID of the device being monitored.\n        start_date (datetime): Start of the aggregation period.\n        end_date (datetime): End of the aggregation period.\n        total_duration (int): Total usage duration in seconds.\n        total_energy (float): Total energy consumed in kWh.\n        average_metrics (Dict[str, float]): Average of numeric metrics.\n        usage_count (int): Number of usage records in the period.\n    \"\"\"\n    device_id: str\n    start_date: datetime\n    end_date: datetime\n    total_duration: int = 0\n    total_energy: float = 0\n    average_metrics: Dict[str, float] = {}\n    usage_count: int = 0\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.usage.UsageBulkCreate","title":"<code>app.models.usage.UsageBulkCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for bulk creation of usage records.</p> <p>Attributes:</p> Name Type Description <code>records</code> <code>List[CreateUsage]</code> <p>List of usage records to create.</p> Source code in <code>app/models/usage.py</code> <pre><code>class UsageBulkCreate(BaseModel):\n    \"\"\"\n    Model for bulk creation of usage records.\n\n    Attributes:\n        records (List[CreateUsage]): List of usage records to create.\n    \"\"\"\n    records: List[CreateUsage]\n\n    @field_validator(\"records\")\n    @classmethod\n    def validate_records(cls, v: List[CreateUsage]) -&gt; List[CreateUsage]:\n        \"\"\"\n        Validate records list is not empty.\n\n        Args:\n            v (List[CreateUsage]): Records to be validated.\n\n        Returns:\n            List[CreateUsage]: Validated usage records.\n\n        Raises:\n            ValueError: Records list is empty.\n        \"\"\"\n        if not v:\n            raise ValueError(\"Records list cannot be empty\")\n\n        return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageBulkCreate.validate_records","title":"<code>app.models.usage.UsageBulkCreate.validate_records(v)</code>  <code>classmethod</code>","text":"<p>Validate records list is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>List[CreateUsage]</code> <p>Records to be validated.</p> required <p>Returns:</p> Type Description <code>List[CreateUsage]</code> <p>List[CreateUsage]: Validated usage records.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Records list is empty.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"records\")\n@classmethod\ndef validate_records(cls, v: List[CreateUsage]) -&gt; List[CreateUsage]:\n    \"\"\"\n    Validate records list is not empty.\n\n    Args:\n        v (List[CreateUsage]): Records to be validated.\n\n    Returns:\n        List[CreateUsage]: Validated usage records.\n\n    Raises:\n        ValueError: Records list is empty.\n    \"\"\"\n    if not v:\n        raise ValueError(\"Records list cannot be empty\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageDB","title":"<code>app.models.usage.UsageDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing device usage data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique usage record identifier.</p> <code>device_id</code> <code>str</code> <p>ID of the device being monitored.</p> <code>metrics</code> <code>Dict[str, Any]</code> <p>Usage metrics specific to device type.</p> <code>timestamp</code> <code>datetime</code> <p>When the usage was recorded.</p> <code>duration</code> <code>Optional[int]</code> <p>Duration of usage in seconds.</p> <code>energy_consumed</code> <code>Optional[float]</code> <p>Energy used in kWh.</p> <code>status</code> <code>Optional[str]</code> <p>Device status during measurement.</p> <code>created</code> <code>datetime</code> <p>When this record was created.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When this record was last updated.</p> Source code in <code>app/models/usage.py</code> <pre><code>class UsageDB(BaseModel):\n    \"\"\"\n    Internal model representing device usage data in the database.\n\n    Attributes:\n        id (str): Unique usage record identifier.\n        device_id (str): ID of the device being monitored.\n        metrics (Dict[str, Any]): Usage metrics specific to device type.\n        timestamp (datetime): When the usage was recorded.\n        duration (Optional[int]): Duration of usage in seconds.\n        energy_consumed (Optional[float]): Energy used in kWh.\n        status (Optional[str]): Device status during measurement.\n        created (datetime): When this record was created.\n        updated (Optional[datetime]): When this record was last updated.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    device_id: str\n    metrics: Dict[str, Any]\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    duration: Optional[int] = None\n    energy_consumed: Optional[float] = None\n    status: Optional[str] = None\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.usage.UsageResponse","title":"<code>app.models.usage.UsageResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for usage data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique usage record identifier.</p> <code>device_id</code> <code>str</code> <p>ID of the device being monitored.</p> <code>metrics</code> <code>Dict[str, Any]</code> <p>Usage metrics specific to device type.</p> <code>timestamp</code> <code>datetime</code> <p>When the usage was recorded.</p> <code>duration</code> <code>Optional[int]</code> <p>Duration of usage in seconds.</p> <code>energy_consumed</code> <code>Optional[float]</code> <p>Energy used in kWh.</p> <code>status</code> <code>Optional[str]</code> <p>Device status during measurement.</p> Source code in <code>app/models/usage.py</code> <pre><code>class UsageResponse(BaseModel):\n    \"\"\"\n    Model for usage data returned in API responses.\n\n    Attributes:\n        id (str): Unique usage record identifier.\n        device_id (str): ID of the device being monitored.\n        metrics (Dict[str, Any]): Usage metrics specific to device type.\n        timestamp (datetime): When the usage was recorded.\n        duration (Optional[int]): Duration of usage in seconds.\n        energy_consumed (Optional[float]): Energy used in kWh.\n        status (Optional[str]): Device status during measurement.\n    \"\"\"\n    id: str\n    device_id: str\n    metrics: Dict[str, Any]\n    timestamp: datetime\n    duration: Optional[int] = None\n    energy_consumed: Optional[float] = None\n    status: Optional[str] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.usage.UsageTimeRange","title":"<code>app.models.usage.UsageTimeRange</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for specifying a time range for usage queries.</p> <p>Attributes:</p> Name Type Description <code>start_time</code> <code>datetime</code> <p>Start of the time range.</p> <code>end_time</code> <code>datetime</code> <p>End of the time range.</p> <code>device_id</code> <code>Optional[str]</code> <p>Optional device ID to filter by.</p> Source code in <code>app/models/usage.py</code> <pre><code>class UsageTimeRange(BaseModel):\n    \"\"\"\n    Model for specifying a time range for usage queries.\n\n    Attributes:\n        start_time (datetime): Start of the time range.\n        end_time (datetime): End of the time range.\n        device_id (Optional[str]): Optional device ID to filter by.\n    \"\"\"\n    start_time: datetime\n    end_time: datetime\n    device_id: Optional[str] = None\n\n    @field_validator(\"end_time\")\n    @classmethod\n    def validate_end_time(cls, v: datetime, info) -&gt; datetime:\n        \"\"\"\n        Validate end_time is after start_time.\n        \"\"\"\n        if info.data.get(\"start_time\") and v &lt; info.data.get(\"start_time\"):\n            raise ValueError(\"End time must be after start time\")\n\n        return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageTimeRange.validate_end_time","title":"<code>app.models.usage.UsageTimeRange.validate_end_time(v, info)</code>  <code>classmethod</code>","text":"<p>Validate end_time is after start_time.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"end_time\")\n@classmethod\ndef validate_end_time(cls, v: datetime, info) -&gt; datetime:\n    \"\"\"\n    Validate end_time is after start_time.\n    \"\"\"\n    if info.data.get(\"start_time\") and v &lt; info.data.get(\"start_time\"):\n        raise ValueError(\"End time must be after start time\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageUpdate","title":"<code>app.models.usage.UsageUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating usage information.</p> <p>Attributes:</p> Name Type Description <code>metrics</code> <code>Optional[Dict[str, Any]]</code> <p>Updated metrics.</p> <code>duration</code> <code>Optional[int]</code> <p>Updated duration in seconds.</p> <code>energy_consumed</code> <code>Optional[float]</code> <p>Updated energy consumption in kWh.</p> <code>status</code> <code>Optional[str]</code> <p>Updated device status.</p> Source code in <code>app/models/usage.py</code> <pre><code>class UsageUpdate(BaseModel):\n    \"\"\"\n    Model for updating usage information.\n\n    Attributes:\n        metrics (Optional[Dict[str, Any]]): Updated metrics.\n        duration (Optional[int]): Updated duration in seconds.\n        energy_consumed (Optional[float]): Updated energy consumption in kWh.\n        status (Optional[str]): Updated device status.\n    \"\"\"\n    metrics: Optional[Dict[str, Any]] = None\n    duration: Optional[int] = None\n    energy_consumed: Optional[float] = None\n    status: Optional[str] = None\n\n    @field_validator(\"energy_consumed\")\n    @classmethod\n    def validate_energy_consumed(cls, v: Optional[float]) -&gt; Optional[float]:\n        \"\"\"\n        Validate energy consumption is positive if provided.\n\n        Args:\n            v Optional[float]: Energy consumption metric to be validated.\n\n        Returns:\n            Optional[float]: Validated energy consumption data.\n\n        Returns:\n            ValueError: Negative energy consumption.\n        \"\"\"\n        if v is not None and v &lt; 0:\n            raise ValueError(\"Energy consumption cannot be negative\")\n\n        return v\n\n    @field_validator(\"duration\")\n    @classmethod\n    def validate_duration(cls, v: Optional[int]) -&gt; Optional[int]:\n        \"\"\"\n        Validate duration is positive if provided.\n\n        Args:\n            v Optional[float]: Energy consumption duration to be validated.\n\n        Returns:\n            Optional[float]: Validated energy duration data.\n\n        Returns:\n            ValueError: Negative duration.\n        \"\"\"\n        if v is not None and v &lt; 0:\n            raise ValueError(\"Duration cannot be negative\")\n\n        return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageUpdate.validate_duration","title":"<code>app.models.usage.UsageUpdate.validate_duration(v)</code>  <code>classmethod</code>","text":"<p>Validate duration is positive if provided.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[float]</code> <p>Energy consumption duration to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[float]: Validated energy duration data.</p> <p>Returns:</p> Name Type Description <code>ValueError</code> <code>Optional[int]</code> <p>Negative duration.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"duration\")\n@classmethod\ndef validate_duration(cls, v: Optional[int]) -&gt; Optional[int]:\n    \"\"\"\n    Validate duration is positive if provided.\n\n    Args:\n        v Optional[float]: Energy consumption duration to be validated.\n\n    Returns:\n        Optional[float]: Validated energy duration data.\n\n    Returns:\n        ValueError: Negative duration.\n    \"\"\"\n    if v is not None and v &lt; 0:\n        raise ValueError(\"Duration cannot be negative\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.usage.UsageUpdate.validate_energy_consumed","title":"<code>app.models.usage.UsageUpdate.validate_energy_consumed(v)</code>  <code>classmethod</code>","text":"<p>Validate energy consumption is positive if provided.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Optional[float]</code> <p>Energy consumption metric to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: Validated energy consumption data.</p> <p>Returns:</p> Name Type Description <code>ValueError</code> <code>Optional[float]</code> <p>Negative energy consumption.</p> Source code in <code>app/models/usage.py</code> <pre><code>@field_validator(\"energy_consumed\")\n@classmethod\ndef validate_energy_consumed(cls, v: Optional[float]) -&gt; Optional[float]:\n    \"\"\"\n    Validate energy consumption is positive if provided.\n\n    Args:\n        v Optional[float]: Energy consumption metric to be validated.\n\n    Returns:\n        Optional[float]: Validated energy consumption data.\n\n    Returns:\n        ValueError: Negative energy consumption.\n    \"\"\"\n    if v is not None and v &lt; 0:\n        raise ValueError(\"Energy consumption cannot be negative\")\n\n    return v\n</code></pre>"},{"location":"api/#app.models.user","title":"<code>app.models.user</code>","text":"<p>Models for user validation.</p>"},{"location":"api/#app.models.user.CreateUser","title":"<code>app.models.user.CreateUser</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for user registration input.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>User's desired username.</p> <code>email</code> <code>str</code> <p>User's email address.</p> <code>password</code> <code>str</code> <p>User's password.</p> Source code in <code>app/models/user.py</code> <pre><code>class CreateUser(BaseModel):\n    \"\"\"\n    Model for user registration input.\n\n    Attributes:\n        username (str): User's desired username.\n        email (str): User's email address.\n        password (str): User's password.\n    \"\"\"\n    username: str\n    email: EmailStr\n    password: str\n    role: str = \"admin\"     # Defaults to admin\n\n    @field_validator(\"username\")\n    @classmethod\n    def validate_username(cls, u: str) -&gt; str:\n        \"\"\"\n        Validate username according to requirements.\n\n        Arguments:\n            u (str): Username to be validated.\n\n        Returns:\n            str: Validated username.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(u) &lt; 3:\n            raise ValueError(\"Username must be at least 3 characters long.\")\n        if len(u) &gt; 30:\n            raise ValueError(\"Username must be less than 30 characters long.\")\n\n        return u\n\n    @field_validator(\"password\")\n    @classmethod\n    def validate_password(cls, p: str) -&gt; str:\n        \"\"\"\n        Validate password according to requirements.\n\n        Arguments:\n            p (str): Password to be validated.\n\n        Returns:\n            str: Validated password.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if len(p) &lt; 8:\n            raise ValueError(\"Password must be at least 8 characters long.\")\n        if not any(c.isdigit() for c in p):\n            raise ValueError(\"Password must contain at least 1 number.\")\n        if not any(c.isalpha() for c in p):\n            raise ValueError(\"Password must contain at least 1 letter.\")\n        if not any(c.islower() for c in p):\n            raise ValueError(\"Password must contain at least 1 lowercase letter.\")\n        if not any(c.isupper() for c in p):\n            raise ValueError(\"Password must contain at least 1 uppercase letter.\")\n        if not any(c in \"!@#$%^&amp;*()_+-=[]{}|;':\\\",.&lt;&gt;?/\" for c in p):\n            raise ValueError(\"Password must contain at least 1 special character.\")\n\n        return p\n</code></pre>"},{"location":"api/#app.models.user.CreateUser.validate_password","title":"<code>app.models.user.CreateUser.validate_password(p)</code>  <code>classmethod</code>","text":"<p>Validate password according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>str</code> <p>Password to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated password.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"password\")\n@classmethod\ndef validate_password(cls, p: str) -&gt; str:\n    \"\"\"\n    Validate password according to requirements.\n\n    Arguments:\n        p (str): Password to be validated.\n\n    Returns:\n        str: Validated password.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(p) &lt; 8:\n        raise ValueError(\"Password must be at least 8 characters long.\")\n    if not any(c.isdigit() for c in p):\n        raise ValueError(\"Password must contain at least 1 number.\")\n    if not any(c.isalpha() for c in p):\n        raise ValueError(\"Password must contain at least 1 letter.\")\n    if not any(c.islower() for c in p):\n        raise ValueError(\"Password must contain at least 1 lowercase letter.\")\n    if not any(c.isupper() for c in p):\n        raise ValueError(\"Password must contain at least 1 uppercase letter.\")\n    if not any(c in \"!@#$%^&amp;*()_+-=[]{}|;':\\\",.&lt;&gt;?/\" for c in p):\n        raise ValueError(\"Password must contain at least 1 special character.\")\n\n    return p\n</code></pre>"},{"location":"api/#app.models.user.CreateUser.validate_username","title":"<code>app.models.user.CreateUser.validate_username(u)</code>  <code>classmethod</code>","text":"<p>Validate username according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Username to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Validated username.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"username\")\n@classmethod\ndef validate_username(cls, u: str) -&gt; str:\n    \"\"\"\n    Validate username according to requirements.\n\n    Arguments:\n        u (str): Username to be validated.\n\n    Returns:\n        str: Validated username.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if len(u) &lt; 3:\n        raise ValueError(\"Username must be at least 3 characters long.\")\n    if len(u) &gt; 30:\n        raise ValueError(\"Username must be less than 30 characters long.\")\n\n    return u\n</code></pre>"},{"location":"api/#app.models.user.UserDB","title":"<code>app.models.user.UserDB</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal model representing user data in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique user identifier.</p> <code>username</code> <code>str</code> <p>Username.</p> <code>email</code> <code>EmailStr</code> <p>User's email address.</p> <code>hashed_password</code> <code>str</code> <p>Securely hashed password.</p> <code>active</code> <code>bool</code> <p>Whether the user account is currently active.</p> <code>created</code> <code>datetime</code> <p>When the user account was created.</p> <code>updated</code> <code>Optional[datetime]</code> <p>When the user account was last updated.</p> <code>role</code> <code>str</code> <p>User's role, default to admin.</p> Source code in <code>app/models/user.py</code> <pre><code>class UserDB(BaseModel):\n    \"\"\"\n    Internal model representing user data in the database.\n\n    Attributes:\n        id (str): Unique user identifier.\n        username (str): Username.\n        email (EmailStr): User's email address.\n        hashed_password (str): Securely hashed password.\n        active (bool): Whether the user account is currently active.\n        created (datetime): When the user account was created.\n        updated (Optional[datetime]): When the user account was last updated.\n        role (str): User's role, default to admin.\n    \"\"\"\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    username: str\n    email: EmailStr\n    hashed_password: str\n    active: bool = True\n    verified: bool = False\n    created: datetime = Field(default_factory=datetime.utcnow)\n    updated: Optional[datetime] = None\n    role: str = \"admin\"     # Defaults to admin\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.user.UserResponse","title":"<code>app.models.user.UserResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for user data returned in API responses.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique user identifier.</p> <code>username</code> <code>str</code> <p>Username.</p> <code>email</code> <code>EmailStr</code> <p>User's email address.</p> <code>active</code> <code>bool</code> <p>Whether the user account is currently active.</p> <code>created</code> <code>datetime</code> <p>When the user account was created.</p> Source code in <code>app/models/user.py</code> <pre><code>class UserResponse(BaseModel):\n    \"\"\"\n    Model for user data returned in API responses.\n\n    Attributes:\n        id (str): Unique user identifier.\n        username (str): Username.\n        email (EmailStr): User's email address.\n        active (bool): Whether the user account is currently active.\n        created (datetime): When the user account was created.\n    \"\"\"\n    id: str\n    username: str\n    active: bool\n    created: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#app.models.user.UserUpdate","title":"<code>app.models.user.UserUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for updating user information.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>Optional[str]</code> <p>User's updated username.</p> <code>email</code> <code>Optional[EmailStr]</code> <p>User's updated email address.</p> Source code in <code>app/models/user.py</code> <pre><code>class UserUpdate(BaseModel):\n    \"\"\"\n    Model for updating user information.\n\n    Attributes:\n        username (Optional[str]): User's updated username.\n        email (Optional[EmailStr]): User's updated email address.\n    \"\"\"\n    username: Optional[str] = None\n    email: Optional[EmailStr] = None\n\n    @field_validator(\"username\")\n    @classmethod\n    def validate_username(cls, u: Optional[str]) -&gt; Optional[str]:\n        \"\"\"\n        Validate username according to requirements.\n\n        Arguments:\n            u (str): Username to be validated.\n\n        Returns:\n            str: Validated username.\n\n        Raises:\n            ValueError: Validation encountered a missing requirement.\n        \"\"\"\n        if isinstance(u, str):\n            if len(u) &lt; 3:\n                raise ValueError(\"Username must be at least 3 characters long.\")\n            if len(u) &gt; 30:\n                raise ValueError(\"Username must be less than 30 characters long.\")\n\n        return u\n</code></pre>"},{"location":"api/#app.models.user.UserUpdate.validate_username","title":"<code>app.models.user.UserUpdate.validate_username(u)</code>  <code>classmethod</code>","text":"<p>Validate username according to requirements.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>str</code> <p>Username to be validated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>Validated username.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Validation encountered a missing requirement.</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"username\")\n@classmethod\ndef validate_username(cls, u: Optional[str]) -&gt; Optional[str]:\n    \"\"\"\n    Validate username according to requirements.\n\n    Arguments:\n        u (str): Username to be validated.\n\n    Returns:\n        str: Validated username.\n\n    Raises:\n        ValueError: Validation encountered a missing requirement.\n    \"\"\"\n    if isinstance(u, str):\n        if len(u) &lt; 3:\n            raise ValueError(\"Username must be at least 3 characters long.\")\n        if len(u) &gt; 30:\n            raise ValueError(\"Username must be less than 30 characters long.\")\n\n    return u\n</code></pre>"},{"location":"api/#app.routes.access_management_routes","title":"<code>app.routes.access_management_routes</code>","text":"<p>Access management routes for the smart home system.</p>"},{"location":"api/#app.routes.access_management_routes.create_access_management","title":"<code>app.routes.access_management_routes.create_access_management(access_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create new access management entries.</p> <p>Users can only create entries where they are the owner. Admin users can create entries for any owner.</p> Source code in <code>app/routes/access_management_routes.py</code> <pre><code>@router.post(\"/\", response_model=List[AccessManagementResponse], status_code=status.HTTP_201_CREATED)\nasync def create_access_management(\n    access_create: CreateAccessManagement,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create new access management entries.\n\n    Users can only create entries where they are the owner.\n    Admin users can create entries for any owner.\n    \"\"\"\n    # Check if the requesting user is the owner or an admin\n    if current_user.role != \"admin\" and current_user.id != access_create.owner_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create access for another owner\"\n        )\n\n    # Create a list to hold all created entries\n    created_entries = []\n\n    # Create an entry for each user_id in the list\n    for user_id in access_create.user_ids:\n        # Create a new AccessManagementDB model\n        access_db = AccessManagementDB(\n            owner_id=access_create.owner_id,\n            resource_id=access_create.resource_id,\n            resource_type=access_create.resource_type,\n            user_id=user_id,\n            access_level=access_create.access_level,\n            expires_at=access_create.expires_at,\n            note=access_create.note\n        )\n\n        # Insert the entry into the database\n        try:\n            am_c.insert_one(access_db.model_dump())\n            created_entries.append(access_db)\n        except DuplicateKeyError:\n            # Skip duplicates and continue\n            continue\n\n    if not created_entries:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"No access entries were created. They might already exist.\"\n        )\n\n    return [AccessManagementResponse.model_validate(entry) for entry in created_entries]\n</code></pre>"},{"location":"api/#app.routes.access_management_routes.delete_access_management","title":"<code>app.routes.access_management_routes.delete_access_management(entry_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete an access management entry.</p> <p>Users can only delete entries where they are the owner. Admin users can delete any entry.</p> Source code in <code>app/routes/access_management_routes.py</code> <pre><code>@router.delete(\"/{entry_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_access_management(\n    entry_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an access management entry.\n\n    Users can only delete entries where they are the owner.\n    Admin users can delete any entry.\n    \"\"\"\n    # Find the entry to delete\n    entry = am_c.find_one({\"id\": entry_id})\n    if not entry:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Access management entry with ID {entry_id} not found\"\n        )\n\n    # Check if the requesting user is the owner or an admin\n    if current_user.role != \"admin\" and current_user.id != entry[\"owner_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this access entry\"\n        )\n\n    # Perform the deletion\n    result = am_c.delete_one({\"id\": entry_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete access management entry\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.access_management_routes.get_access_management","title":"<code>app.routes.access_management_routes.get_access_management(entry_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single access management entry by ID.</p> <p>Users can only access entries where they are the owner or the granted user. Admin users can access any entry.</p> Source code in <code>app/routes/access_management_routes.py</code> <pre><code>@router.get(\"/{entry_id}\", response_model=AccessManagementResponse)\nasync def get_access_management(\n    entry_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single access management entry by ID.\n\n    Users can only access entries where they are the owner or the granted user.\n    Admin users can access any entry.\n    \"\"\"\n    # Get the entry\n    entry = am_c.find_one({\"id\": entry_id})\n\n    if not entry:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Access management entry with ID {entry_id} not found\"\n        )\n\n    # Check if the requesting user is the owner, the granted user, or an admin\n    if (current_user.role != \"admin\" and \n        current_user.id != entry[\"owner_id\"] and \n        current_user.id != entry[\"user_id\"]):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this entry\"\n        )\n\n    return AccessManagementResponse.model_validate(entry)\n</code></pre>"},{"location":"api/#app.routes.access_management_routes.get_all_access_management","title":"<code>app.routes.access_management_routes.get_all_access_management(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), owner_id=None, resource_id=None, resource_type=None, user_id=None, access_level=None, active=None)</code>  <code>async</code>","text":"<p>Get all access management entries.</p> <p>Admin users can see all entries. Regular users can only see entries where they are the owner or the granted user.</p> Source code in <code>app/routes/access_management_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[AccessManagementResponse])\nasync def get_all_access_management(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    owner_id: Optional[str] = None,\n    resource_id: Optional[str] = None,\n    resource_type: Optional[ResourceType] = None,\n    user_id: Optional[str] = None,\n    access_level: Optional[AccessLevel] = None,\n    active: Optional[bool] = None\n) -&gt; List[AccessManagementResponse]:\n    \"\"\"\n    Get all access management entries.\n\n    Admin users can see all entries.\n    Regular users can only see entries where they are the owner or the granted user.\n    \"\"\"\n    # Build query filter\n    query: Dict[str, Any] = {}\n\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access entries they own or are granted to them\n        query[\"$or\"] = [\n            {\"owner_id\": current_user.id},\n            {\"user_id\": current_user.id}\n        ]\n\n    # Add filters if provided\n    if owner_id:\n        query[\"owner_id\"] = owner_id\n    if resource_id:\n        query[\"resource_id\"] = resource_id\n    if resource_type:\n        query[\"resource_type\"] = resource_type\n    if user_id:\n        query[\"user_id\"] = user_id\n    if access_level:\n        query[\"access_level\"] = access_level\n    if active is not None:\n        query[\"active\"] = active\n\n    # Convert cursor to list\n    cursor = am_c.find(query).skip(skip).limit(limit)\n    entries = list(cursor)\n\n    # Convert to AccessManagementResponse models\n    return [AccessManagementResponse.model_validate(entry) for entry in entries]\n</code></pre>"},{"location":"api/#app.routes.access_management_routes.update_access_management","title":"<code>app.routes.access_management_routes.update_access_management(entry_id, access_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update an access management entry.</p> <p>Users can only update entries where they are the owner. Admin users can update any entry.</p> Source code in <code>app/routes/access_management_routes.py</code> <pre><code>@router.patch(\"/{entry_id}\", response_model=AccessManagementResponse)\nasync def update_access_management(\n    entry_id: str,\n    access_update: AccessManagementUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update an access management entry.\n\n    Users can only update entries where they are the owner.\n    Admin users can update any entry.\n    \"\"\"\n    # Find the entry to update\n    entry = am_c.find_one({\"id\": entry_id})\n    if not entry:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Access management entry with ID {entry_id} not found\"\n        )\n\n    # Check if the requesting user is the owner or an admin\n    if current_user.role != \"admin\" and current_user.id != entry[\"owner_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this access entry\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in access_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = am_c.update_one(\n                {\"id\": entry_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Access management entry not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate entry\"\n            )\n\n    # Retrieve and return the updated entry\n    updated_entry = am_c.find_one({\"id\": entry_id})\n    return AccessManagementResponse.model_validate(updated_entry)\n</code></pre>"},{"location":"api/#app.routes.analytics_routes","title":"<code>app.routes.analytics_routes</code>","text":"<p>Analytics data management routes for the smart home system.</p>"},{"location":"api/#app.routes.analytics_routes.create_analytics","title":"<code>app.routes.analytics_routes.create_analytics(analytics_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new analytics record. Users can only create analytics for themselves, while admins can create for any user.</p> Source code in <code>app/routes/analytics_routes.py</code> <pre><code>@router.post(\"/\", response_model=AnalyticsResponse, status_code=status.HTTP_201_CREATED)\nasync def create_analytics(\n    analytics_create: CreateAnalytics,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new analytics record.\n    Users can only create analytics for themselves, while admins can create for any user.\n    \"\"\"\n    # Check if the requesting user is the analytics owner or an admin\n    if current_user.role != \"admin\" and current_user.id != analytics_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create analytics for another user\"\n        )\n\n    # Create a new AnalyticsDB model\n    analytics_db = AnalyticsDB(**analytics_create.model_dump())\n\n    # Insert the analytics into the database\n    try:\n        an_c.insert_one(analytics_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Analytics with this ID already exists\"\n        )\n\n    return AnalyticsResponse.model_validate(analytics_db)\n</code></pre>"},{"location":"api/#app.routes.analytics_routes.delete_analytics","title":"<code>app.routes.analytics_routes.delete_analytics(analytics_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete an analytics record. Users can only delete their own analytics, while admins can delete any analytics.</p> Source code in <code>app/routes/analytics_routes.py</code> <pre><code>@router.delete(\"/{analytics_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_analytics(\n    analytics_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an analytics record.\n    Users can only delete their own analytics, while admins can delete any analytics.\n    \"\"\"\n    # Find the analytics to delete\n    analytics = an_c.find_one({\"id\": analytics_id})\n    if not analytics:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Analytics with ID {analytics_id} not found\"\n        )\n\n    # Check if the requesting user is the owner or an admin\n    if current_user.role != \"admin\" and current_user.id != analytics[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this analytics data\"\n        )\n\n    # Perform the deletion\n    result = an_c.delete_one({\"id\": analytics_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete analytics data\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.analytics_routes.get_all_analytics","title":"<code>app.routes.analytics_routes.get_all_analytics(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, device_id=None, data_type=None, start_time=None, end_time=None, tags=Query(None))</code>  <code>async</code>","text":"<p>Get all analytics data with filtering options. Admin users can see all analytics, while regular users can only see their own.</p> Source code in <code>app/routes/analytics_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[AnalyticsResponse])\nasync def get_all_analytics(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    device_id: Optional[str] = None,\n    data_type: Optional[str] = None,\n    start_time: Optional[datetime] = None,\n    end_time: Optional[datetime] = None,\n    tags: Optional[List[str]] = Query(None)\n) -&gt; List[AnalyticsResponse]:\n    \"\"\"\n    Get all analytics data with filtering options.\n    Admin users can see all analytics, while regular users can only see their own.\n    \"\"\"\n    # Create query object and validate time range if provided\n    query_params = AnalyticsQuery(\n        user_id=user_id,\n        device_id=device_id,\n        data_type=data_type,\n        start_time=start_time,\n        end_time=end_time,\n        tags=tags\n    )\n\n    if start_time and end_time:\n        try:\n            query_params.validate_time_range_post_init()\n        except ValueError as e:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(e)\n            )\n\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own analytics\n        query_params.user_id = current_user.id\n\n    # Build MongoDB query filter\n    query: Dict[str, Any] = {}\n    if query_params.user_id:\n        query[\"user_id\"] = query_params.user_id\n    if query_params.device_id:\n        query[\"device_id\"] = query_params.device_id\n    if query_params.data_type:\n        query[\"data_type\"] = query_params.data_type\n\n    # Time range filters\n    if query_params.start_time or query_params.end_time:\n        query[\"timestamp\"] = {}\n        if query_params.start_time:\n            query[\"timestamp\"][\"$gte\"] = query_params.start_time\n        if query_params.end_time:\n            query[\"timestamp\"][\"$lte\"] = query_params.end_time\n\n    # Tags filter (if one of the specified tags is in the analytics tags list)\n    if query_params.tags:\n        query[\"tags\"] = {\"$in\": query_params.tags}\n\n    # Add sorting by timestamp (descending)\n    cursor = an_c.find(query).sort(\"timestamp\", -1).skip(skip).limit(limit)\n    analytics_data = list(cursor)\n\n    # Convert to AnalyticsResponse models\n    return [AnalyticsResponse.model_validate(item) for item in analytics_data]\n</code></pre>"},{"location":"api/#app.routes.analytics_routes.get_analytics","title":"<code>app.routes.analytics_routes.get_analytics(analytics_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single analytics record by ID. Users can only access their own analytics, while admins can access any analytics.</p> Source code in <code>app/routes/analytics_routes.py</code> <pre><code>@router.get(\"/{analytics_id}\", response_model=AnalyticsResponse)\nasync def get_analytics(\n    analytics_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single analytics record by ID.\n    Users can only access their own analytics, while admins can access any analytics.\n    \"\"\"\n    # Get the analytics record\n    analytics = an_c.find_one({\"id\": analytics_id})\n\n    if not analytics:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Analytics with ID {analytics_id} not found\"\n        )\n\n    # Check if the requesting user is the owner or an admin\n    if current_user.role != \"admin\" and current_user.id != analytics[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this analytics data\"\n        )\n\n    return AnalyticsResponse.model_validate(analytics)\n</code></pre>"},{"location":"api/#app.routes.analytics_routes.update_analytics","title":"<code>app.routes.analytics_routes.update_analytics(analytics_id, analytics_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update an analytics record. Users can only update their own analytics, while admins can update any analytics.</p> Source code in <code>app/routes/analytics_routes.py</code> <pre><code>@router.patch(\"/{analytics_id}\", response_model=AnalyticsResponse)\nasync def update_analytics(\n    analytics_id: str,\n    analytics_update: AnalyticsUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update an analytics record.\n    Users can only update their own analytics, while admins can update any analytics.\n    \"\"\"\n    # Find the analytics to update\n    analytics = an_c.find_one({\"id\": analytics_id})\n    if not analytics:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Analytics with ID {analytics_id} not found\"\n        )\n\n    # Check if the requesting user is the owner or an admin\n    if current_user.role != \"admin\" and current_user.id != analytics[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this analytics data\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in analytics_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        result = an_c.update_one(\n            {\"id\": analytics_id},\n            {\"$set\": update_data}\n        )\n        if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n            raise HTTPException(\n                status_code=status.HTTP_304_NOT_MODIFIED,\n                detail=\"Analytics data not modified\"\n            )\n\n    # Retrieve and return the updated analytics\n    updated_analytics = an_c.find_one({\"id\": analytics_id})\n    return AnalyticsResponse.model_validate(updated_analytics)\n</code></pre>"},{"location":"api/#app.routes.automation_routes","title":"<code>app.routes.automation_routes</code>","text":"<p>Automation management routes for the smart home system.</p>"},{"location":"api/#app.routes.automation_routes.create_automation","title":"<code>app.routes.automation_routes.create_automation(automation_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new automation. Users can only create automations for themselves, while admins can create for any user.</p> Source code in <code>app/routes/automation_routes.py</code> <pre><code>@router.post(\"/\", response_model=AutomationDetailResponse, status_code=status.HTTP_201_CREATED)\nasync def create_automation(\n    automation_create: CreateAutomation,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new automation.\n    Users can only create automations for themselves, while admins can create for any user.\n    \"\"\"\n    # Check if the requesting user is the automation owner or an admin\n    if current_user.role != \"admin\" and current_user.id != automation_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create automation for another user\"\n        )\n\n    # Create a new AutomationDB model\n    automation_db = AutomationDB(**automation_create.model_dump())\n\n    # Insert the automation into the database\n    try:\n        a_c.insert_one(automation_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Automation with this ID already exists\"\n        )\n\n    return AutomationDetailResponse.model_validate(automation_db)\n</code></pre>"},{"location":"api/#app.routes.automation_routes.delete_automation","title":"<code>app.routes.automation_routes.delete_automation(automation_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete an automation. Users can only delete their own automations, while admins can delete any automation.</p> Source code in <code>app/routes/automation_routes.py</code> <pre><code>@router.delete(\"/{automation_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_automation(\n    automation_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an automation.\n    Users can only delete their own automations, while admins can delete any automation.\n    \"\"\"\n    # Find the automation to delete\n    automation = a_c.find_one({\"id\": automation_id})\n    if not automation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Automation with ID {automation_id} not found\"\n        )\n\n    # Check if the requesting user is the automation owner or an admin\n    if current_user.role != \"admin\" and current_user.id != automation[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this automation\"\n        )\n\n    # Perform the deletion\n    result = a_c.delete_one({\"id\": automation_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete automation\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.automation_routes.get_all_automations","title":"<code>app.routes.automation_routes.get_all_automations(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, device_id=None, trigger_type=None, action_type=None, enabled=None)</code>  <code>async</code>","text":"<p>Get all automations. Admin users can see all automations, while regular users can only see their own.</p> Source code in <code>app/routes/automation_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[AutomationResponse])\nasync def get_all_automations(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    device_id: Optional[str] = None,\n    trigger_type: Optional[TriggerType] = None,\n    action_type: Optional[ActionType] = None,\n    enabled: Optional[bool] = None\n) -&gt; List[AutomationResponse]:\n    \"\"\"\n    Get all automations.\n    Admin users can see all automations, while regular users can only see their own.\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own automations\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if device_id:\n        query[\"device_id\"] = device_id\n    if trigger_type:\n        query[\"trigger_type\"] = trigger_type\n    if action_type:\n        query[\"action_type\"] = action_type\n    if enabled is not None:\n        query[\"enabled\"] = enabled\n\n    # Convert cursor to list\n    cursor = a_c.find(query).skip(skip).limit(limit)\n    automations = list(cursor)\n\n    # Convert to AutomationResponse models\n    return [AutomationResponse.model_validate(automation) for automation in automations]\n</code></pre>"},{"location":"api/#app.routes.automation_routes.get_automation","title":"<code>app.routes.automation_routes.get_automation(automation_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single automation by ID. Users can only access their own automations, while admins can access any automation.</p> Source code in <code>app/routes/automation_routes.py</code> <pre><code>@router.get(\"/{automation_id}\", response_model=AutomationDetailResponse)\nasync def get_automation(\n    automation_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single automation by ID.\n    Users can only access their own automations, while admins can access any automation.\n    \"\"\"\n    # Get the automation\n    automation = a_c.find_one({\"id\": automation_id})\n\n    if not automation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Automation with ID {automation_id} not found\"\n        )\n\n    # Check if the requesting user is the automation owner or an admin\n    if current_user.role != \"admin\" and current_user.id != automation[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this automation\"\n        )\n\n    return AutomationDetailResponse.model_validate(automation)\n</code></pre>"},{"location":"api/#app.routes.automation_routes.update_automation","title":"<code>app.routes.automation_routes.update_automation(automation_id, automation_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update an automation's information. Users can only update their own automations, while admins can update any automation.</p> Source code in <code>app/routes/automation_routes.py</code> <pre><code>@router.patch(\"/{automation_id}\", response_model=AutomationDetailResponse)\nasync def update_automation(\n    automation_id: str,\n    automation_update: AutomationUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update an automation's information.\n    Users can only update their own automations, while admins can update any automation.\n    \"\"\"\n    # Find the automation to update\n    automation = a_c.find_one({\"id\": automation_id})\n    if not automation:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Automation with ID {automation_id} not found\"\n        )\n\n    # Check if the requesting user is the automation owner or an admin\n    if current_user.role != \"admin\" and current_user.id != automation[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this automation\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in automation_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = a_c.update_one(\n                {\"id\": automation_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Automation data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate entry\"\n            )\n\n    # Retrieve and return the updated automation\n    updated_automation = a_c.find_one({\"id\": automation_id})\n    return AutomationDetailResponse.model_validate(updated_automation)\n</code></pre>"},{"location":"api/#app.routes.device_routes","title":"<code>app.routes.device_routes</code>","text":"<p>Device management routes for the smart home system.</p>"},{"location":"api/#app.routes.device_routes.create_device","title":"<code>app.routes.device_routes.create_device(device_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new device. Users can only create devices for themselves, while admins can create devices for any user.</p> Source code in <code>app/routes/device_routes.py</code> <pre><code>@router.post(\"/\", response_model=DeviceResponse, status_code=status.HTTP_201_CREATED)\nasync def create_device(\n    device_create: CreateDevice,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new device.\n    Users can only create devices for themselves, while admins can create devices for any user.\n    \"\"\"\n    # Check if the requesting user is the device owner or an admin\n    if current_user.role != \"admin\" and current_user.id != device_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create device for another user\"\n        )\n\n    # Generate a unique ID for the device\n    device_id = str(uuid.uuid4())\n\n    # Create a new DeviceDB model with the generated ID\n    device_data = device_create.model_dump()\n    device_data[\"id\"] = device_id\n    device_db = DeviceDB(**device_data)\n\n    # Insert the device into the database\n    try:\n        d_c.insert_one(device_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Device with this ID already exists\"\n        )\n\n    # Fetch the newly created device from the database\n    device = d_c.find_one({\"id\": device_id})\n\n    return DeviceResponse.model_validate(device)\n</code></pre>"},{"location":"api/#app.routes.device_routes.delete_device","title":"<code>app.routes.device_routes.delete_device(device_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a device. Users can only delete their own devices, while admins can delete any device.</p> Source code in <code>app/routes/device_routes.py</code> <pre><code>@router.delete(\"/{device_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_device(\n    device_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a device.\n    Users can only delete their own devices, while admins can delete any device.\n    \"\"\"\n    # Find the device to delete\n    device = d_c.find_one({\"id\": device_id})\n    if not device:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Device with ID {device_id} not found\"\n        )\n\n    # Check if the requesting user is the device owner or an admin\n    if current_user.role != \"admin\" and current_user.id != device[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this device\"\n        )\n\n    # Perform the deletion\n    result = d_c.delete_one({\"id\": device_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete device\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.device_routes.get_all_devices","title":"<code>app.routes.device_routes.get_all_devices(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, type=None, room_id=None, status=None, manufacturer=None)</code>  <code>async</code>","text":"<p>Get all devices. Admin users can see all devices, while regular users can only see their own.</p> <p>Filter parameters: - user_id: Filter by user ID - type: Filter by device type - room_id: Filter by room ID - status: Filter by device status - manufacturer: Filter by manufacturer</p> Source code in <code>app/routes/device_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[DeviceResponse])\nasync def get_all_devices(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    type: Optional[DeviceType] = None,\n    room_id: Optional[str] = None,\n    status: Optional[DeviceStatus] = None,\n    manufacturer: Optional[str] = None\n) -&gt; List[DeviceResponse]:\n    \"\"\"\n    Get all devices.\n    Admin users can see all devices, while regular users can only see their own.\n\n    Filter parameters:\n    - user_id: Filter by user ID\n    - type: Filter by device type\n    - room_id: Filter by room ID\n    - status: Filter by device status\n    - manufacturer: Filter by manufacturer\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own devices\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if type:\n        query[\"type\"] = type\n    if room_id:\n        query[\"room_id\"] = room_id\n    if status:\n        query[\"status\"] = status\n    if manufacturer:\n        query[\"manufacturer\"] = manufacturer\n\n    # Convert cursor to list\n    cursor = d_c.find(query).skip(skip).limit(limit)\n    devices = list(cursor)\n\n    # Convert to DeviceResponse models\n    return [DeviceResponse.model_validate(device) for device in devices]\n</code></pre>"},{"location":"api/#app.routes.device_routes.get_device","title":"<code>app.routes.device_routes.get_device(device_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single device by ID. Users can only access their own devices, while admins can access any device.</p> Source code in <code>app/routes/device_routes.py</code> <pre><code>@router.get(\"/{device_id}\", response_model=DeviceResponse)\nasync def get_device(\n    device_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single device by ID.\n    Users can only access their own devices, while admins can access any device.\n    \"\"\"\n    # Get the device\n    device = d_c.find_one({\"id\": device_id})\n\n    if not device:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Device with ID {device_id} not found\"\n        )\n\n    # Check if the requesting user is the device owner or an admin\n    if current_user.role != \"admin\" and current_user.id != device[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this device\"\n        )\n\n    return DeviceResponse.model_validate(device)\n</code></pre>"},{"location":"api/#app.routes.device_routes.update_device","title":"<code>app.routes.device_routes.update_device(device_id, device_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a device's information. Users can only update their own devices, while admins can update any device.</p> Source code in <code>app/routes/device_routes.py</code> <pre><code>@router.patch(\"/{device_id}\", response_model=DeviceResponse)\nasync def update_device(\n    device_id: str,\n    device_update: DeviceUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a device's information.\n    Users can only update their own devices, while admins can update any device.\n    \"\"\"\n    # Find the device to update\n    device = d_c.find_one({\"id\": device_id})\n    if not device:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Device with ID {device_id} not found\"\n        )\n\n    # Check if the requesting user is the device owner or an admin\n    if current_user.role != \"admin\" and current_user.id != device[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this device\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in device_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = d_c.update_one(\n                {\"id\": device_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Device data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate device\"\n            )\n\n    # Retrieve and return the updated device\n    updated_device = d_c.find_one({\"id\": device_id})\n    return DeviceResponse.model_validate(updated_device)\n</code></pre>"},{"location":"api/#app.routes.goal_routes","title":"<code>app.routes.goal_routes</code>","text":"<p>Energy goal management routes for the smart home system.</p>"},{"location":"api/#app.routes.goal_routes.create_goal","title":"<code>app.routes.goal_routes.create_goal(goal_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new energy goal. Users can only create their own goals, while admins can create any goal.</p> Source code in <code>app/routes/goal_routes.py</code> <pre><code>@router.post(\"/\", response_model=EnergyGoalResponse, status_code=status.HTTP_201_CREATED)\nasync def create_goal(\n    goal_create: CreateEnergyGoal,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new energy goal.\n    Users can only create their own goals, while admins can create any goal.\n    \"\"\"\n    # Check if the requesting user is the goal owner or an admin\n    if current_user.role != \"admin\" and current_user.id != goal_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create goal for another user\"\n        )\n\n    # Create a new EnergyGoalDB model\n    goal_db = EnergyGoalDB(**goal_create.model_dump())\n\n    # Calculate initial progress percentage\n    if goal_db.target_value &gt; 0:\n        goal_db.progress_percentage = (goal_db.current_value / goal_db.target_value) * 100\n\n    # Insert the goal into the database\n    try:\n        g_c.insert_one(goal_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Goal with this ID already exists\"\n        )\n\n    return EnergyGoalResponse.model_validate(goal_db)\n</code></pre>"},{"location":"api/#app.routes.goal_routes.delete_goal","title":"<code>app.routes.goal_routes.delete_goal(goal_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete an energy goal. Users can only delete their own goals, while admins can delete any goal.</p> Source code in <code>app/routes/goal_routes.py</code> <pre><code>@router.delete(\"/{goal_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_goal(\n    goal_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an energy goal.\n    Users can only delete their own goals, while admins can delete any goal.\n    \"\"\"\n    # Find the goal to delete\n    goal = g_c.find_one({\"id\": goal_id})\n    if not goal:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Goal with ID {goal_id} not found\"\n        )\n\n    # Check if the requesting user is the goal owner or an admin\n    if current_user.role != \"admin\" and current_user.id != goal[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this goal\"\n        )\n\n    # Perform the deletion\n    result = g_c.delete_one({\"id\": goal_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete goal\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.goal_routes.get_all_goals","title":"<code>app.routes.goal_routes.get_all_goals(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, type=None, status=None, timeframe=None)</code>  <code>async</code>","text":"<p>Get all energy goals with filtering options. Admin users can see all goals, while regular users can only see their own.</p> Source code in <code>app/routes/goal_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[EnergyGoalResponse])\nasync def get_all_goals(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    type: Optional[GoalType] = None,\n    status: Optional[GoalStatus] = None,\n    timeframe: Optional[GoalTimeframe] = None\n) -&gt; List[EnergyGoalResponse]:\n    \"\"\"\n    Get all energy goals with filtering options.\n    Admin users can see all goals, while regular users can only see their own.\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own goals\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if type:\n        query[\"type\"] = type\n    if status:\n        query[\"status\"] = status\n    if timeframe:\n        query[\"timeframe\"] = timeframe\n\n    # Convert cursor to list\n    cursor = g_c.find(query).skip(skip).limit(limit)\n    goals = list(cursor)\n\n    # Convert to EnergyGoalResponse models\n    return [EnergyGoalResponse.model_validate(goal) for goal in goals]\n</code></pre>"},{"location":"api/#app.routes.goal_routes.get_goal","title":"<code>app.routes.goal_routes.get_goal(goal_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single energy goal by ID. Users can only access their own goals, while admins can access any goal.</p> Source code in <code>app/routes/goal_routes.py</code> <pre><code>@router.get(\"/{goal_id}\", response_model=EnergyGoalResponse)\nasync def get_goal(\n    goal_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single energy goal by ID.\n    Users can only access their own goals, while admins can access any goal.\n    \"\"\"\n    # Get the goal\n    goal = g_c.find_one({\"id\": goal_id})\n\n    if not goal:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Goal with ID {goal_id} not found\"\n        )\n\n    # Check if the requesting user is the goal owner or an admin\n    if current_user.role != \"admin\" and current_user.id != goal[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this goal\"\n        )\n\n    return EnergyGoalResponse.model_validate(goal)\n</code></pre>"},{"location":"api/#app.routes.goal_routes.update_goal","title":"<code>app.routes.goal_routes.update_goal(goal_id, goal_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update an energy goal's information. Users can only update their own goals, while admins can update any goal.</p> Source code in <code>app/routes/goal_routes.py</code> <pre><code>@router.patch(\"/{goal_id}\", response_model=EnergyGoalResponse)\nasync def update_goal(\n    goal_id: str,\n    goal_update: EnergyGoalUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update an energy goal's information.\n    Users can only update their own goals, while admins can update any goal.\n    \"\"\"\n    # Find the goal to update\n    goal = g_c.find_one({\"id\": goal_id})\n    if not goal:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Goal with ID {goal_id} not found\"\n        )\n\n    # Check if the requesting user is the goal owner or an admin\n    if current_user.role != \"admin\" and current_user.id != goal[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this goal\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in goal_update.model_dump().items() if v is not None}\n\n    # Calculate progress percentage if current_value or target_value is updated\n    if \"current_value\" in update_data or \"target_value\" in update_data:\n        current_value = update_data.get(\"current_value\", goal[\"current_value\"])\n        target_value = update_data.get(\"target_value\", goal[\"target_value\"])\n\n        if target_value &gt; 0:\n            update_data[\"progress_percentage\"] = (current_value / target_value) * 100\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = g_c.update_one(\n                {\"id\": goal_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Goal data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate\"\n            )\n\n    # Retrieve and return the updated goal\n    updated_goal = g_c.find_one({\"id\": goal_id})\n    return EnergyGoalResponse.model_validate(updated_goal)\n</code></pre>"},{"location":"api/#app.routes.goal_routes.update_goal_progress","title":"<code>app.routes.goal_routes.update_goal_progress(goal_id, progress_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update an energy goal's progress. Users can only update their own goals, while admins can update any goal.</p> Source code in <code>app/routes/goal_routes.py</code> <pre><code>@router.patch(\"/{goal_id}/progress\", response_model=EnergyGoalResponse)\nasync def update_goal_progress(\n    goal_id: str,\n    progress_update: EnergyGoalProgressUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update an energy goal's progress.\n    Users can only update their own goals, while admins can update any goal.\n    \"\"\"\n    # Find the goal to update\n    goal = g_c.find_one({\"id\": goal_id})\n    if not goal:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Goal with ID {goal_id} not found\"\n        )\n\n    # Check if the requesting user is the goal owner or an admin\n    if current_user.role != \"admin\" and current_user.id != goal[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this goal\"\n        )\n\n    # Create update data\n    current_value = progress_update.current_value\n    target_value = goal[\"target_value\"]\n\n    update_data = {\n        \"current_value\": current_value,\n        \"updated\": datetime.utcnow()\n    }\n\n    # Calculate progress percentage\n    if target_value &gt; 0:\n        update_data[\"progress_percentage\"] = (current_value / target_value) * 100\n\n        # Auto-update status if completed\n        if current_value &gt;= target_value and goal[\"status\"] == GoalStatus.ACTIVE:\n            update_data[\"status\"] = GoalStatus.COMPLETED\n\n    # Perform the update\n    try:\n        result = g_c.update_one(\n            {\"id\": goal_id},\n            {\"$set\": update_data}\n        )\n        if result.modified_count == 0:\n            raise HTTPException(\n                status_code=status.HTTP_304_NOT_MODIFIED,\n                detail=\"Goal progress not modified\"\n            )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Error updating goal progress: {str(e)}\"\n        )\n\n    # Retrieve and return the updated goal\n    updated_goal = g_c.find_one({\"id\": goal_id})\n    return EnergyGoalResponse.model_validate(updated_goal)\n</code></pre>"},{"location":"api/#app.routes.notification_routes","title":"<code>app.routes.notification_routes</code>","text":"<p>Notification management routes for the smart home system.</p>"},{"location":"api/#app.routes.notification_routes.bulk_update_notifications","title":"<code>app.routes.notification_routes.bulk_update_notifications(bulk_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update multiple notifications at once (typically to mark them as read/unread). Users can only update their own notifications, while admins can update any notification.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.post(\"/bulk_update\", response_model=dict)\nasync def bulk_update_notifications(\n    bulk_update: NotificationBulkUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update multiple notifications at once (typically to mark them as read/unread).\n    Users can only update their own notifications, while admins can update any notification.\n    \"\"\"\n    # Build query to match only authorized notifications\n    query = {\n        \"id\": {\"$in\": bulk_update.notification_ids}\n    }\n\n    # For regular users, restrict to their own notifications\n    if current_user.role != \"admin\":\n        query[\"user_id\"] = current_user.id\n\n    # Set up update data\n    update_data = {\"read\": bulk_update.read}\n    if bulk_update.read:\n        update_data[\"read_timestamp\"] = datetime.utcnow()\n    else:\n        update_data[\"read_timestamp\"] = None\n\n    # Perform the update\n    result = n_c.update_many(\n        query,\n        {\"$set\": update_data}\n    )\n\n    return {\n        \"modified_count\": result.modified_count,\n        \"matched_count\": result.matched_count\n    }\n</code></pre>"},{"location":"api/#app.routes.notification_routes.create_notification","title":"<code>app.routes.notification_routes.create_notification(notification_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new notification. Admins can create notifications for any user, regular users can only create notifications for themselves.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.post(\"/\", response_model=NotificationResponse, status_code=status.HTTP_201_CREATED)\nasync def create_notification(\n    notification_create: CreateNotification,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new notification.\n    Admins can create notifications for any user,\n    regular users can only create notifications for themselves.\n    \"\"\"\n    # Check if the requesting user is the notification owner or an admin\n    if current_user.role != \"admin\" and current_user.id != notification_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create notification for another user\"\n        )\n\n    # Create a new NotificationDB model\n    notification_db = NotificationDB(**notification_create.model_dump())\n\n    # Insert the notification into the database\n    try:\n        n_c.insert_one(notification_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Notification with this ID already exists\"\n        )\n\n    return NotificationResponse.model_validate(notification_db)\n</code></pre>"},{"location":"api/#app.routes.notification_routes.delete_notification","title":"<code>app.routes.notification_routes.delete_notification(notification_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a notification. Users can only delete their own notifications, while admins can delete any notification.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.delete(\"/{notification_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_notification(\n    notification_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a notification.\n    Users can only delete their own notifications, while admins can delete any notification.\n    \"\"\"\n    # Find the notification to delete\n    notification = n_c.find_one({\"id\": notification_id})\n    if not notification:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Notification with ID {notification_id} not found\"\n        )\n\n    # Check if the requesting user is the notification owner or an admin\n    if current_user.role != \"admin\" and current_user.id != notification[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this notification\"\n        )\n\n    # Perform the deletion\n    result = n_c.delete_one({\"id\": notification_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete notification\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.notification_routes.delete_notifications","title":"<code>app.routes.notification_routes.delete_notifications(current_user=Depends(get_current_user), user_id=None, read=None, type=None, priority=None, source=None)</code>  <code>async</code>","text":"<p>Delete multiple notifications based on filter criteria. Users can only delete their own notifications, while admins can delete any notification.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.delete(\"/\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_notifications(\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    read: Optional[bool] = None,\n    type: Optional[str] = None,\n    priority: Optional[str] = None,\n    source: Optional[str] = None\n):\n    \"\"\"\n    Delete multiple notifications based on filter criteria.\n    Users can only delete their own notifications, while admins can delete any notification.\n    \"\"\"\n    # Build query\n    query = {}\n\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only delete their own notifications\n        query[\"user_id\"] = current_user.id\n    elif user_id:\n        # Admin users can specify a user_id filter\n        query[\"user_id\"] = user_id\n\n    # Add additional filters if provided\n    if read is not None:\n        query[\"read\"] = read\n    if type:\n        query[\"type\"] = type\n    if priority:\n        query[\"priority\"] = priority\n    if source:\n        query[\"source\"] = source\n\n    # Perform the deletion\n    result = n_c.delete_many(query)\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.notification_routes.get_all_notifications","title":"<code>app.routes.notification_routes.get_all_notifications(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, read=None, type=None, priority=None, source=None, from_date=None, to_date=None)</code>  <code>async</code>","text":"<p>Get all notifications. Admin users can see all notifications, while regular users can only see their own.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[NotificationResponse])\nasync def get_all_notifications(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    read: Optional[bool] = None,\n    type: Optional[str] = None,\n    priority: Optional[str] = None,\n    source: Optional[str] = None,\n    from_date: Optional[datetime] = None,\n    to_date: Optional[datetime] = None\n) -&gt; List[NotificationResponse]:\n    \"\"\"\n    Get all notifications.\n    Admin users can see all notifications, while regular users can only see their own.\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own notifications\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if read is not None:\n        query[\"read\"] = read\n    if type:\n        query[\"type\"] = type\n    if priority:\n        query[\"priority\"] = priority\n    if source:\n        query[\"source\"] = source\n\n    # Date range query\n    date_query = {}\n    if from_date:\n        date_query[\"$gte\"] = from_date\n    if to_date:\n        date_query[\"$lte\"] = to_date\n    if date_query:\n        query[\"timestamp\"] = date_query\n\n    # Convert cursor to list\n    cursor = n_c.find(query).sort(\"timestamp\", -1).skip(skip).limit(limit)\n    notifications = list(cursor)\n\n    # Convert to NotificationResponse models\n    return [NotificationResponse.model_validate(notification) for notification in notifications]\n</code></pre>"},{"location":"api/#app.routes.notification_routes.get_notification","title":"<code>app.routes.notification_routes.get_notification(notification_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single notification by ID. Users can only access their own notifications, while admins can access any notification.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.get(\"/{notification_id}\", response_model=NotificationResponse)\nasync def get_notification(\n    notification_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single notification by ID.\n    Users can only access their own notifications, while admins can access any notification.\n    \"\"\"\n    # Get the notification\n    notification = n_c.find_one({\"id\": notification_id})\n\n    if not notification:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Notification with ID {notification_id} not found\"\n        )\n\n    # Check if the requesting user is the notification owner or an admin\n    if current_user.role != \"admin\" and current_user.id != notification[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this notification\"\n        )\n\n    return NotificationResponse.model_validate(notification)\n</code></pre>"},{"location":"api/#app.routes.notification_routes.update_notification","title":"<code>app.routes.notification_routes.update_notification(notification_id, notification_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a notification's information. Users can only update their own notifications, while admins can update any notification.</p> Source code in <code>app/routes/notification_routes.py</code> <pre><code>@router.patch(\"/{notification_id}\", response_model=NotificationResponse)\nasync def update_notification(\n    notification_id: str,\n    notification_update: NotificationUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a notification's information.\n    Users can only update their own notifications, while admins can update any notification.\n    \"\"\"\n    # Find the notification to update\n    notification = n_c.find_one({\"id\": notification_id})\n    if not notification:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Notification with ID {notification_id} not found\"\n        )\n\n    # Check if the requesting user is the notification owner or an admin\n    if current_user.role != \"admin\" and current_user.id != notification[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this notification\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in notification_update.model_dump().items() if v is not None}\n\n    # If marking as read, add the read timestamp\n    if notification_update.read is True and notification.get(\"read\") is False:\n        update_data[\"read_timestamp\"] = datetime.utcnow()\n\n    # If marking as unread, remove the read timestamp\n    if notification_update.read is False:\n        update_data[\"read_timestamp\"] = None\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = n_c.update_one(\n                {\"id\": notification_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0:\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Notification data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate notification ID\"\n            )\n\n    # Retrieve and return the updated notification\n    updated_notification = n_c.find_one({\"id\": notification_id})\n    return NotificationResponse.model_validate(updated_notification)\n</code></pre>"},{"location":"api/#app.routes.profile_routes","title":"<code>app.routes.profile_routes</code>","text":"<p>Profile management routes for the smart home system.</p>"},{"location":"api/#app.routes.profile_routes.create_profile","title":"<code>app.routes.profile_routes.create_profile(profile_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new profile. Users can only create their own profile, while admins can create any profile.</p> Source code in <code>app/routes/profile_routes.py</code> <pre><code>@router.post(\"/\", response_model=ProfileResponse, status_code=status.HTTP_201_CREATED)\nasync def create_profile(\n    profile_create: CreateProfile,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new profile.\n    Users can only create their own profile, while admins can create any profile.\n    \"\"\"\n    # Check if the requesting user is the profile owner or an admin\n    if current_user.role != \"admin\" and current_user.id != profile_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create profile for another user\"\n        )\n\n    # Check if a profile already exists for this user_id\n    existing_profile = p_c.find_one({\"user_id\": profile_create.user_id})\n\n    if existing_profile:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Profile already exists for user with ID {profile_create.user_id}\"\n        )\n\n    # Create a new ProfileDB model\n    profile_db = ProfileDB(**profile_create.model_dump())\n\n    # Insert the profile into the database\n    try:\n        p_c.insert_one(profile_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Profile with this ID or user_id already exists\"\n        )\n\n    return ProfileResponse.model_validate(profile_db)\n</code></pre>"},{"location":"api/#app.routes.profile_routes.delete_profile","title":"<code>app.routes.profile_routes.delete_profile(profile_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a profile. Users can only delete their own profile, while admins can delete any profile.</p> Source code in <code>app/routes/profile_routes.py</code> <pre><code>@router.delete(\"/{profile_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_profile(\n    profile_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a profile.\n    Users can only delete their own profile, while admins can delete any profile.\n    \"\"\"\n    # Find the profile to delete\n    profile = p_c.find_one({\"id\": profile_id})\n    if not profile:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Profile with ID {profile_id} not found\"\n        )\n\n    # Check if the requesting user is the profile owner or an admin\n    if current_user.role != \"admin\" and current_user.id != profile[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this profile\"\n        )\n\n    # Perform the deletion\n    result = p_c.delete_one({\"id\": profile_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete profile\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.profile_routes.get_all_profiles","title":"<code>app.routes.profile_routes.get_all_profiles(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, timezone=None, temperature_unit=None, dark_mode=None)</code>  <code>async</code>","text":"<p>Get all profiles. Admin users can see all profiles, while regular users can only see their own.</p> Source code in <code>app/routes/profile_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[ProfileResponse])\nasync def get_all_profiles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    timezone: Optional[str] = None,\n    temperature_unit: Optional[str] = None,\n    dark_mode: Optional[bool] = None\n) -&gt; List[ProfileResponse]:\n    \"\"\"\n    Get all profiles.\n    Admin users can see all profiles, while regular users can only see their own.\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own profile\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if timezone:\n        query[\"timezone\"] = timezone\n    if temperature_unit:\n        query[\"temperature_unit\"] = temperature_unit\n    if dark_mode is not None:\n        query[\"dark_mode\"] = dark_mode\n\n    # Convert cursor to list\n    cursor = p_c.find(query).skip(skip).limit(limit)\n    profiles = list(cursor)\n\n    # Convert to ProfileResponse models\n    return [ProfileResponse.model_validate(profile) for profile in profiles]\n</code></pre>"},{"location":"api/#app.routes.profile_routes.get_profile","title":"<code>app.routes.profile_routes.get_profile(profile_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single profile by ID. Users can only access their own profile, while admins can access any profile.</p> Source code in <code>app/routes/profile_routes.py</code> <pre><code>@router.get(\"/{profile_id}\", response_model=ProfileResponse)\nasync def get_profile(\n    profile_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single profile by ID.\n    Users can only access their own profile, while admins can access any profile.\n    \"\"\"\n    # Get the profile\n    profile = p_c.find_one({\"id\": profile_id})\n\n    if not profile:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Profile with ID {profile_id} not found\"\n        )\n\n    # Check if the requesting user is the profile owner or an admin\n    if current_user.role != \"admin\" and current_user.id != profile[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this profile\"\n        )\n\n    return ProfileResponse.model_validate(profile)\n</code></pre>"},{"location":"api/#app.routes.profile_routes.update_profile","title":"<code>app.routes.profile_routes.update_profile(profile_id, profile_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a profile's information. Users can only update their own profile, while admins can update any profile.</p> Source code in <code>app/routes/profile_routes.py</code> <pre><code>@router.patch(\"/{profile_id}\", response_model=ProfileResponse)\nasync def update_profile(\n    profile_id: str,\n    profile_update: ProfileUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a profile's information.\n    Users can only update their own profile, while admins can update any profile.\n    \"\"\"\n    # Find the profile to update\n    profile = p_c.find_one({\"id\": profile_id})\n    if not profile:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Profile with ID {profile_id} not found\"\n        )\n\n    # Check if the requesting user is the profile owner or an admin\n    if current_user.role != \"admin\" and current_user.id != profile[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this profile\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in profile_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = p_c.update_one(\n                {\"id\": profile_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Profile data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate user_id\"\n            )\n\n    # Retrieve and return the updated profile\n    updated_profile = p_c.find_one({\"id\": profile_id})\n    return ProfileResponse.model_validate(updated_profile)\n</code></pre>"},{"location":"api/#app.routes.report_routes","title":"<code>app.routes.report_routes</code>","text":"<p>API routes for report generation and management.</p>"},{"location":"api/#app.routes.report_routes.create_report","title":"<code>app.routes.report_routes.create_report(request, background_tasks)</code>  <code>async</code>","text":"<p>Request generation of a new energy report.</p> <p>The report will be generated asynchronously in the background.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.post(\"/\", status_code=status.HTTP_202_ACCEPTED, response_model=ReportResponse)\nasync def create_report(\n    request: CreateReportRequest,\n    background_tasks: BackgroundTasks\n):\n    \"\"\"\n    Request generation of a new energy report.\n\n    The report will be generated asynchronously in the background.\n    \"\"\"\n    # Create a title if none provided\n    if not request.title:\n        timeframe = \"\"\n        if request.start_date and request.end_date:\n            timeframe = f\" ({request.start_date} to {request.end_date})\"\n        request.title = f\"Energy Report{timeframe}\"\n\n    # Create report record\n    report_db = ReportDB(\n        user_id=request.user_id,\n        title=request.title,\n        format=request.format,\n        start_date=request.start_date,\n        end_date=request.end_date,\n        device_ids=request.device_ids or [],\n        report_type=request.report_type\n    )\n\n    # Save to database - run in executor to make it non-blocking\n    report_id = await run_in_executor(ReportService.create_report)(report_db)\n\n    # Start background task to generate report - will run in thread pool\n    @run_in_executor\n    def generate_report_wrapper(report_id):\n        return ReportService.generate_report(report_id)\n\n    background_tasks.add_task(generate_report_wrapper, report_id)\n\n    # Get the created report - run in executor to make it non-blocking\n    report = await run_in_executor(ReportService.get_report)(report_id)\n    if not report:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create report\"\n        )\n\n    # Create response with download URL\n    response = ReportResponse(\n        id=report[\"id\"],\n        user_id=report[\"user_id\"],\n        title=report[\"title\"],\n        format=report[\"format\"],\n        status=report[\"status\"],\n        report_type=report[\"report_type\"],\n        start_date=report.get(\"start_date\"),\n        end_date=report.get(\"end_date\"),\n        device_ids=report.get(\"device_ids\", []),\n        created=report[\"created\"],\n        completed=report.get(\"completed\"),\n        download_url=f\"/api/v1/reports/{report['id']}/download\" if report[\"status\"] == ReportStatus.COMPLETED else None\n    )\n\n    return response\n</code></pre>"},{"location":"api/#app.routes.report_routes.delete_report","title":"<code>app.routes.report_routes.delete_report(report_id=Path(..., description='ID of the report to delete'))</code>  <code>async</code>","text":"<p>Delete a report and its associated file.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.delete(\"/{report_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_report(\n    report_id: str = Path(..., description=\"ID of the report to delete\")\n):\n    \"\"\"\n    Delete a report and its associated file.\n    \"\"\"\n    report = await run_in_executor(ReportService.get_report)(report_id)\n    if not report:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Report not found\"\n        )\n\n    # Delete the file if it exists\n    file_path = report.get(\"file_path\")\n    if file_path and os.path.exists(file_path):\n        try:\n            os.remove(file_path)\n        except Exception:\n            # Log but don't fail if file deletion fails\n            pass\n\n    # Delete from database\n    result = await run_in_executor(ReportService.delete_report)(report_id)\n    if not result:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete report\"\n        )\n\n    return None\n</code></pre>"},{"location":"api/#app.routes.report_routes.download_report","title":"<code>app.routes.report_routes.download_report(report_id=Path(..., description='ID of the report to download'))</code>  <code>async</code>","text":"<p>Download a generated report file.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.get(\"/{report_id}/download\")\nasync def download_report(\n    report_id: str = Path(..., description=\"ID of the report to download\")\n):\n    \"\"\"\n    Download a generated report file.\n    \"\"\"\n    report = await run_in_executor(ReportService.get_report)(report_id)\n    if not report:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Report not found\"\n        )\n\n    if report[\"status\"] != ReportStatus.COMPLETED:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Report is not ready for download. Current status: {report['status']}\"\n        )\n\n    file_path = report.get(\"file_path\")\n    if not file_path or not os.path.exists(file_path):\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Report file not found\"\n        )\n\n    # Determine file type for content-type header\n    media_type = \"application/pdf\" if report[\"format\"].lower() == \"pdf\" else \"text/csv\"\n\n    # Get filename from path\n    filename = os.path.basename(file_path)\n\n    return FileResponse(\n        path=file_path,\n        media_type=media_type,\n        filename=filename\n    )\n</code></pre>"},{"location":"api/#app.routes.report_routes.get_report","title":"<code>app.routes.report_routes.get_report(report_id=Path(..., description='ID of the report to retrieve'))</code>  <code>async</code>","text":"<p>Get the status and details of a specific report.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.get(\"/{report_id}\", response_model=ReportResponse)\nasync def get_report(\n    report_id: str = Path(..., description=\"ID of the report to retrieve\")\n):\n    \"\"\"\n    Get the status and details of a specific report.\n    \"\"\"\n    report = await run_in_executor(ReportService.get_report)(report_id)\n    if not report:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Report not found\"\n        )\n\n    # Create response\n    response = ReportResponse(\n        id=report[\"id\"],\n        user_id=report[\"user_id\"],\n        title=report[\"title\"],\n        format=report[\"format\"],\n        status=report[\"status\"],\n        report_type=report[\"report_type\"],\n        start_date=report.get(\"start_date\"),\n        end_date=report.get(\"end_date\"),\n        device_ids=report.get(\"device_ids\", []),\n        created=report[\"created\"],\n        completed=report.get(\"completed\"),\n        download_url=f\"/api/v1/reports/{report['id']}/download\" if report[\"status\"] == ReportStatus.COMPLETED else None\n    )\n\n    return response\n</code></pre>"},{"location":"api/#app.routes.report_routes.get_user_reports","title":"<code>app.routes.report_routes.get_user_reports(user_id=Path(..., description='ID of the user'), limit=Query(10, description='Maximum number of reports to return'), offset=Query(0, description='Offset for pagination'))</code>  <code>async</code>","text":"<p>Get all reports for a specific user.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.get(\"/user/{user_id}\", response_model=List[ReportResponse])\nasync def get_user_reports(\n    user_id: str = Path(..., description=\"ID of the user\"),\n    limit: int = Query(10, description=\"Maximum number of reports to return\"),\n    offset: int = Query(0, description=\"Offset for pagination\")\n):\n    \"\"\"\n    Get all reports for a specific user.\n    \"\"\"\n    reports = await run_in_executor(ReportService.get_user_reports)(user_id)\n\n    # Apply pagination\n    paginated_reports = reports[offset:offset+limit]\n\n    # Create response\n    responses = []\n    for report in paginated_reports:\n        responses.append(\n            ReportResponse(\n                id=report[\"id\"],\n                user_id=report[\"user_id\"],\n                title=report[\"title\"],\n                format=report[\"format\"],\n                status=report[\"status\"],\n                report_type=report[\"report_type\"],\n                start_date=report.get(\"start_date\"),\n                end_date=report.get(\"end_date\"),\n                device_ids=report.get(\"device_ids\", []),\n                created=report[\"created\"],\n                completed=report.get(\"completed\"),\n                download_url=f\"/api/v1/reports/{report['id']}/download\" if report[\"status\"] == ReportStatus.COMPLETED else None\n            )\n        )\n\n    return responses\n</code></pre>"},{"location":"api/#app.routes.report_routes.run_in_executor","title":"<code>app.routes.report_routes.run_in_executor(func)</code>","text":"<p>Decorator to run synchronous functions in a thread pool executor. Makes them non-blocking for FastAPI's async framework.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>def run_in_executor(func):\n    \"\"\"\n    Decorator to run synchronous functions in a thread pool executor.\n    Makes them non-blocking for FastAPI's async framework.\n    \"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        return await asyncio.get_event_loop().run_in_executor(\n            executor, lambda: func(*args, **kwargs)\n        )\n    return wrapper\n</code></pre>"},{"location":"api/#app.routes.room_routes","title":"<code>app.routes.room_routes</code>","text":"<p>Room management routes for the smart home system.</p>"},{"location":"api/#app.routes.room_routes.create_room","title":"<code>app.routes.room_routes.create_room(room_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new room.</p> Source code in <code>app/routes/room_routes.py</code> <pre><code>@router.post(\"/\", response_model=RoomResponse, status_code=status.HTTP_201_CREATED)\nasync def create_room(\n    room_create: CreateRoom,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new room.\n    \"\"\"\n    # Create a new RoomDB model with user_id set to current user\n    room_db = RoomDB(\n        user_id=current_user.id,  # Set the current user as the owner\n        **room_create.model_dump()\n    )\n\n    # Insert the room into the database\n    try:\n        r_c.insert_one(room_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Room with this ID already exists\"\n        )\n\n    return RoomResponse.model_validate(room_db)\n</code></pre>"},{"location":"api/#app.routes.room_routes.delete_room","title":"<code>app.routes.room_routes.delete_room(room_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a room. Users can only delete their own rooms, while admins can delete any room.</p> Source code in <code>app/routes/room_routes.py</code> <pre><code>@router.delete(\"/{room_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_room(\n    room_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a room.\n    Users can only delete their own rooms, while admins can delete any room.\n    \"\"\"\n    # Find the room to delete\n    room = r_c.find_one({\"id\": room_id})\n    if not room:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Room with ID {room_id} not found\"\n        )\n\n    # Check if the requesting user is the room owner or an admin\n    if current_user.role != \"admin\" and current_user.id != room[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this room\"\n        )\n\n    # Perform the deletion\n    result = r_c.delete_one({\"id\": room_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete room\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.room_routes.get_all_rooms","title":"<code>app.routes.room_routes.get_all_rooms(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, home_id=None, type=None, floor=None, active=None)</code>  <code>async</code>","text":"<p>Get all rooms with optional filtering. Admin users can see all rooms, while regular users can only see their own.</p> Source code in <code>app/routes/room_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[RoomResponse])\nasync def get_all_rooms(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    home_id: Optional[str] = None,\n    type: Optional[str] = None,\n    floor: Optional[int] = None,\n    active: Optional[bool] = None\n) -&gt; List[RoomResponse]:\n    \"\"\"\n    Get all rooms with optional filtering.\n    Admin users can see all rooms, while regular users can only see their own.\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own rooms\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if home_id:\n        query[\"home_id\"] = home_id\n    if type:\n        query[\"type\"] = type\n    if floor is not None:\n        query[\"floor\"] = floor\n    if active is not None:\n        query[\"active\"] = active\n\n    # Convert cursor to list\n    cursor = r_c.find(query).skip(skip).limit(limit)\n    rooms = list(cursor)\n\n    # Convert to RoomResponse models\n    return [RoomResponse.model_validate(room) for room in rooms]\n</code></pre>"},{"location":"api/#app.routes.room_routes.get_room","title":"<code>app.routes.room_routes.get_room(room_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single room by ID. Users can only access their own rooms, while admins can access any room.</p> Source code in <code>app/routes/room_routes.py</code> <pre><code>@router.get(\"/{room_id}\", response_model=RoomResponse)\nasync def get_room(\n    room_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single room by ID.\n    Users can only access their own rooms, while admins can access any room.\n    \"\"\"\n    # Get the room\n    room = r_c.find_one({\"id\": room_id})\n\n    if not room:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Room with ID {room_id} not found\"\n        )\n\n    # Check if the requesting user is the room owner or an admin\n    if current_user.role != \"admin\" and current_user.id != room[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this room\"\n        )\n\n    return RoomResponse.model_validate(room)\n</code></pre>"},{"location":"api/#app.routes.room_routes.update_room","title":"<code>app.routes.room_routes.update_room(room_id, room_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a room's information. Users can only update their own rooms, while admins can update any room.</p> Source code in <code>app/routes/room_routes.py</code> <pre><code>@router.patch(\"/{room_id}\", response_model=RoomResponse)\nasync def update_room(\n    room_id: str,\n    room_update: RoomUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a room's information.\n    Users can only update their own rooms, while admins can update any room.\n    \"\"\"\n    # Find the room to update\n    room = r_c.find_one({\"id\": room_id})\n    if not room:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Room with ID {room_id} not found\"\n        )\n\n    # Check if the requesting user is the room owner or an admin\n    if current_user.role != \"admin\" and current_user.id != room[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this room\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in room_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = r_c.update_one(\n                {\"id\": room_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Room data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate ID\"\n            )\n\n    # Retrieve and return the updated room\n    updated_room = r_c.find_one({\"id\": room_id})\n    return RoomResponse.model_validate(updated_room)\n</code></pre>"},{"location":"api/#app.routes.suggestion_routes","title":"<code>app.routes.suggestion_routes</code>","text":"<p>Suggestion management routes for the smart home system.</p>"},{"location":"api/#app.routes.suggestion_routes.create_suggestion","title":"<code>app.routes.suggestion_routes.create_suggestion(suggestion_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new suggestion. Users can only create suggestions for themselves, while admins can create suggestions for any user.</p> Source code in <code>app/routes/suggestion_routes.py</code> <pre><code>@router.post(\"/\", response_model=SuggestionResponse, status_code=status.HTTP_201_CREATED)\nasync def create_suggestion(\n    suggestion_create: CreateSuggestion,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new suggestion.\n    Users can only create suggestions for themselves, while admins can create suggestions for any user.\n    \"\"\"\n    # Check if the requesting user is the suggestion owner or an admin\n    if current_user.role != \"admin\" and current_user.id != suggestion_create.user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to create suggestion for another user\"\n        )\n\n    # Create a new SuggestionDB model\n    suggestion_db = SuggestionDB(**suggestion_create.model_dump())\n\n    # Insert the suggestion into the database\n    try:\n        s_c.insert_one(suggestion_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Suggestion with this ID already exists\"\n        )\n\n    return SuggestionResponse.model_validate(suggestion_db)\n</code></pre>"},{"location":"api/#app.routes.suggestion_routes.delete_suggestion","title":"<code>app.routes.suggestion_routes.delete_suggestion(suggestion_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a suggestion. Users can only delete their own suggestions, while admins can delete any suggestion.</p> Source code in <code>app/routes/suggestion_routes.py</code> <pre><code>@router.delete(\"/{suggestion_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_suggestion(\n    suggestion_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a suggestion.\n    Users can only delete their own suggestions, while admins can delete any suggestion.\n    \"\"\"\n    # Find the suggestion to delete\n    suggestion = s_c.find_one({\"id\": suggestion_id})\n    if not suggestion:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Suggestion with ID {suggestion_id} not found\"\n        )\n\n    # Check if the requesting user is the suggestion owner or an admin\n    if current_user.role != \"admin\" and current_user.id != suggestion[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to delete this suggestion\"\n        )\n\n    # Perform the deletion\n    result = s_c.delete_one({\"id\": suggestion_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete suggestion\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.suggestion_routes.get_all_suggestions","title":"<code>app.routes.suggestion_routes.get_all_suggestions(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), user_id=None, status=None, type=None, priority=None, from_date=None, to_date=None)</code>  <code>async</code>","text":"<p>Get all suggestions. Admin users can see all suggestions, while regular users can only see their own.</p> Source code in <code>app/routes/suggestion_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[SuggestionResponse])\nasync def get_all_suggestions(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    user_id: Optional[str] = None,\n    status: Optional[SuggestionStatus] = None,\n    type: Optional[SuggestionType] = None,\n    priority: Optional[int] = None,\n    from_date: Optional[datetime] = None,\n    to_date: Optional[datetime] = None\n) -&gt; List[SuggestionResponse]:\n    \"\"\"\n    Get all suggestions.\n    Admin users can see all suggestions, while regular users can only see their own.\n    \"\"\"\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        # Non-admin users can only access their own suggestions\n        user_id = current_user.id\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if user_id:\n        query[\"user_id\"] = user_id\n    if status:\n        query[\"status\"] = status\n    if type:\n        query[\"type\"] = type\n    if priority:\n        query[\"priority\"] = priority\n\n    # Date range filtering\n    if from_date or to_date:\n        date_query = {}\n        if from_date:\n            date_query[\"$gte\"] = from_date\n        if to_date:\n            date_query[\"$lte\"] = to_date\n        if date_query:\n            query[\"created\"] = date_query\n\n    # Convert cursor to list\n    cursor = s_c.find(query).skip(skip).limit(limit).sort(\"created\", -1)\n    suggestions = list(cursor)\n\n    # Convert to SuggestionResponse models\n    return [SuggestionResponse.model_validate(suggestion) for suggestion in suggestions]\n</code></pre>"},{"location":"api/#app.routes.suggestion_routes.get_suggestion","title":"<code>app.routes.suggestion_routes.get_suggestion(suggestion_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single suggestion by ID. Users can only access their own suggestions, while admins can access any suggestion.</p> Source code in <code>app/routes/suggestion_routes.py</code> <pre><code>@router.get(\"/{suggestion_id}\", response_model=SuggestionResponse)\nasync def get_suggestion(\n    suggestion_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single suggestion by ID.\n    Users can only access their own suggestions, while admins can access any suggestion.\n    \"\"\"\n    # Get the suggestion\n    suggestion = s_c.find_one({\"id\": suggestion_id})\n\n    if not suggestion:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Suggestion with ID {suggestion_id} not found\"\n        )\n\n    # Check if the requesting user is the suggestion owner or an admin\n    if current_user.role != \"admin\" and current_user.id != suggestion[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this suggestion\"\n        )\n\n    return SuggestionResponse.model_validate(suggestion)\n</code></pre>"},{"location":"api/#app.routes.suggestion_routes.update_suggestion","title":"<code>app.routes.suggestion_routes.update_suggestion(suggestion_id, suggestion_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a suggestion's information. Users can only update their own suggestions, while admins can update any suggestion.</p> Source code in <code>app/routes/suggestion_routes.py</code> <pre><code>@router.patch(\"/{suggestion_id}\", response_model=SuggestionResponse)\nasync def update_suggestion(\n    suggestion_id: str,\n    suggestion_update: SuggestionUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a suggestion's information.\n    Users can only update their own suggestions, while admins can update any suggestion.\n    \"\"\"\n    # Find the suggestion to update\n    suggestion = s_c.find_one({\"id\": suggestion_id})\n    if not suggestion:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Suggestion with ID {suggestion_id} not found\"\n        )\n\n    # Check if the requesting user is the suggestion owner or an admin\n    if current_user.role != \"admin\" and current_user.id != suggestion[\"user_id\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this suggestion\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in suggestion_update.model_dump().items() if v is not None}\n\n    # Update implemented_date if status is changed to IMPLEMENTED\n    if suggestion_update.status == SuggestionStatus.IMPLEMENTED:\n        update_data[\"implemented_date\"] = datetime.utcnow()\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = s_c.update_one(\n                {\"id\": suggestion_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Suggestion data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate\"\n            )\n\n    # Retrieve and return the updated suggestion\n    updated_suggestion = s_c.find_one({\"id\": suggestion_id})\n    return SuggestionResponse.model_validate(updated_suggestion)\n</code></pre>"},{"location":"api/#app.routes.usage_routes","title":"<code>app.routes.usage_routes</code>","text":"<p>Usage data management routes for the smart home system.</p>"},{"location":"api/#app.routes.usage_routes.check_device_ownership","title":"<code>app.routes.usage_routes.check_device_ownership(device_id, user_id)</code>","text":"<p>Check if a user owns a device.</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>def check_device_ownership(device_id: str, user_id: str) -&gt; bool:\n    \"\"\"Check if a user owns a device.\"\"\"\n    device = d_c.find_one({\"id\": device_id})\n    if not device:\n        return False\n    return device.get(\"user_id\") == user_id\n</code></pre>"},{"location":"api/#app.routes.usage_routes.create_bulk_usage","title":"<code>app.routes.usage_routes.create_bulk_usage(bulk_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create multiple usage records at once. Users can only create records for their own devices, while admins can create for any device.</p> <p>Parameters:</p> Name Type Description Default <code>bulk_create</code> <code>UsageBulkCreate</code> <p>List of usage records to create</p> required <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <p>List[UsageResponse]: The newly created usage records</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.post(\"/bulk\", response_model=List[UsageResponse], status_code=status.HTTP_201_CREATED)\nasync def create_bulk_usage(\n    bulk_create: UsageBulkCreate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create multiple usage records at once.\n    Users can only create records for their own devices, while admins can create for any device.\n\n    Args:\n        bulk_create: List of usage records to create\n        current_user: The authenticated user\n\n    Returns:\n        List[UsageResponse]: The newly created usage records\n    \"\"\"\n    # Check device ownership for regular users\n    if current_user.role != \"admin\":\n        for record in bulk_create.records:\n            owns_device = check_device_ownership(record.device_id, current_user.id)\n            if not owns_device:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=f\"Not authorized to create usage data for device {record.device_id}\"\n                )\n\n    created_records = []\n\n    for record in bulk_create.records:\n        # Set timestamp to now if not provided\n        if not record.timestamp:\n            record.timestamp = datetime.utcnow()\n\n        # Create a new UsageDB model\n        usage_db = UsageDB(**record.model_dump())\n\n        # Insert the usage record into the database\n        try:\n            us_c.insert_one(usage_db.model_dump())\n            created_records.append(usage_db)\n        except DuplicateKeyError:\n            # Continue with other records if one fails\n            continue\n\n    if not created_records:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Failed to create any usage records\"\n        )\n\n    return [UsageResponse.model_validate(record) for record in created_records]\n</code></pre>"},{"location":"api/#app.routes.usage_routes.create_usage","title":"<code>app.routes.usage_routes.create_usage(usage_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new usage record. Users can only create records for their own devices, while admins can create for any device.</p> <p>Parameters:</p> Name Type Description Default <code>usage_create</code> <code>CreateUsage</code> <p>Data for the new usage record</p> required <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>UsageResponse</code> <p>The newly created usage record</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.post(\"/\", response_model=UsageResponse, status_code=status.HTTP_201_CREATED)\nasync def create_usage(\n    usage_create: CreateUsage,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new usage record.\n    Users can only create records for their own devices, while admins can create for any device.\n\n    Args:\n        usage_create: Data for the new usage record\n        current_user: The authenticated user\n\n    Returns:\n        UsageResponse: The newly created usage record\n    \"\"\"\n    # Check device ownership for regular users\n    if current_user.role != \"admin\":\n        owns_device = check_device_ownership(usage_create.device_id, current_user.id)\n        if not owns_device:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to create usage data for this device\"\n            )\n\n    # Set timestamp to now if not provided\n    if not usage_create.timestamp:\n        usage_create.timestamp = datetime.utcnow()\n\n    # Create a new UsageDB model\n    usage_db = UsageDB(**usage_create.model_dump())\n\n    # Insert the usage record into the database\n    try:\n        us_c.insert_one(usage_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Usage record with this ID already exists\"\n        )\n\n    return UsageResponse.model_validate(usage_db)\n</code></pre>"},{"location":"api/#app.routes.usage_routes.delete_usage","title":"<code>app.routes.usage_routes.delete_usage(usage_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a usage record. Users can only delete records for their own devices, while admins can delete any record.</p> <p>Parameters:</p> Name Type Description Default <code>usage_id</code> <code>str</code> <p>The ID of the usage record to delete</p> required <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>Response</code> <p>204 No Content on success</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.delete(\"/{usage_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_usage(\n    usage_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a usage record.\n    Users can only delete records for their own devices, while admins can delete any record.\n\n    Args:\n        usage_id: The ID of the usage record to delete\n        current_user: The authenticated user\n\n    Returns:\n        Response: 204 No Content on success\n    \"\"\"\n    # Find the usage record to delete\n    usage = us_c.find_one({\"id\": usage_id})\n    if not usage:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Usage record with ID {usage_id} not found\"\n        )\n\n    # Check device ownership for regular users\n    if current_user.role != \"admin\":\n        owns_device = check_device_ownership(usage[\"device_id\"], current_user.id)\n        if not owns_device:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to delete this usage record\"\n            )\n\n    # Perform the deletion\n    result = us_c.delete_one({\"id\": usage_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete usage record\"\n        )\n\n    # Return a proper 204 No Content response with no body\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"api/#app.routes.usage_routes.get_all_usage","title":"<code>app.routes.usage_routes.get_all_usage(skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000), current_user=Depends(get_current_user), device_id=None, start_time=None, end_time=None, status=None, min_energy=None, max_energy=None, sort='timestamp_desc')</code>  <code>async</code>","text":"<p>Get all usage records. Admin users can see all records, while regular users can only see records for their devices.</p> <p>Parameters:</p> Name Type Description Default <code>skip</code> <code>int</code> <p>Number of records to skip (pagination)</p> <code>Query(0, ge=0)</code> <code>limit</code> <code>int</code> <p>Maximum number of records to return (pagination)</p> <code>Query(100, ge=1, le=1000)</code> <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <code>device_id</code> <code>Optional[str]</code> <p>Filter by device ID</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Filter by records after this time</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>Filter by records before this time</p> <code>None</code> <code>status</code> <code>Optional[str]</code> <p>Filter by device status</p> <code>None</code> <code>min_energy</code> <code>Optional[float]</code> <p>Filter by minimum energy consumed</p> <code>None</code> <code>max_energy</code> <code>Optional[float]</code> <p>Filter by maximum energy consumed</p> <code>None</code> <code>sort</code> <code>Optional[str]</code> <p>Sorting method for results</p> <code>'timestamp_desc'</code> <p>Returns:</p> Type Description <code>List[UsageResponse]</code> <p>List[UsageResponse]: List of usage records</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[UsageResponse])\nasync def get_all_usage(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    current_user: UserDB = Depends(get_current_user),\n    device_id: Optional[str] = None,\n    start_time: Optional[datetime] = None,\n    end_time: Optional[datetime] = None,\n    status: Optional[str] = None,\n    min_energy: Optional[float] = None,\n    max_energy: Optional[float] = None,\n    sort: Optional[str] = \"timestamp_desc\"  # Options: timestamp_asc, timestamp_desc, energy_asc, energy_desc\n) -&gt; List[UsageResponse]:\n    \"\"\"\n    Get all usage records.\n    Admin users can see all records, while regular users can only see records for their devices.\n\n    Args:\n        skip: Number of records to skip (pagination)\n        limit: Maximum number of records to return (pagination)\n        current_user: The authenticated user\n        device_id: Filter by device ID\n        start_time: Filter by records after this time\n        end_time: Filter by records before this time\n        status: Filter by device status\n        min_energy: Filter by minimum energy consumed\n        max_energy: Filter by maximum energy consumed\n        sort: Sorting method for results\n\n    Returns:\n        List[UsageResponse]: List of usage records\n    \"\"\"\n    # Build query filter\n    query: Dict[str, Any] = {}\n\n    if device_id:\n        query[\"device_id\"] = device_id\n\n        # Check device ownership for regular users\n        if current_user.role != \"admin\":\n            owns_device = check_device_ownership(device_id, current_user.id)\n            if not owns_device:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=\"Not authorized to access this device's data\"\n                )\n    elif current_user.role != \"admin\":\n        # For non-admin users without a specific device_id, find all their devices\n        user_devices = list(d_c.find({\"user_id\": current_user.id}))\n        if not user_devices:\n            return []  # User has no devices, return empty list\n\n        device_ids = [device[\"id\"] for device in user_devices]\n        query[\"device_id\"] = {\"$in\": device_ids}\n\n    # Add time range filter if provided\n    if start_time or end_time:\n        time_query = {}\n        if start_time:\n            time_query[\"$gte\"] = start_time\n        if end_time:\n            time_query[\"$lte\"] = end_time\n        if time_query:\n            query[\"timestamp\"] = time_query\n\n    if status:\n        query[\"status\"] = status\n\n    # Add energy consumption filter if provided\n    if min_energy is not None or max_energy is not None:\n        energy_query = {}\n        if min_energy is not None:\n            energy_query[\"$gte\"] = min_energy\n        if max_energy is not None:\n            energy_query[\"$lte\"] = max_energy\n        if energy_query:\n            query[\"energy_consumed\"] = energy_query\n\n    # Determine sort order\n    sort_field = \"timestamp\"\n    sort_direction = -1  # Default to newest first\n\n    if sort:\n        if sort == \"timestamp_asc\":\n            sort_field, sort_direction = \"timestamp\", 1\n        elif sort == \"timestamp_desc\":\n            sort_field, sort_direction = \"timestamp\", -1\n        elif sort == \"energy_asc\":\n            sort_field, sort_direction = \"energy_consumed\", 1\n        elif sort == \"energy_desc\":\n            sort_field, sort_direction = \"energy_consumed\", -1\n\n    # Convert cursor to list\n    cursor = us_c.find(query).sort(sort_field, sort_direction).skip(skip).limit(limit)\n    usage_records = list(cursor)\n\n    # Convert to UsageResponse models\n    return [UsageResponse.model_validate(record) for record in usage_records]\n</code></pre>"},{"location":"api/#app.routes.usage_routes.get_usage","title":"<code>app.routes.usage_routes.get_usage(usage_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single usage record by ID. Users can only access usage data for their own devices, while admins can access any record.</p> <p>Parameters:</p> Name Type Description Default <code>usage_id</code> <code>str</code> <p>The ID of the usage record to get</p> required <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>UsageResponse</code> <p>The requested usage record</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.get(\"/{usage_id}\", response_model=UsageResponse)\nasync def get_usage(\n    usage_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single usage record by ID.\n    Users can only access usage data for their own devices, while admins can access any record.\n\n    Args:\n        usage_id: The ID of the usage record to get\n        current_user: The authenticated user\n\n    Returns:\n        UsageResponse: The requested usage record\n    \"\"\"\n    # Get the usage record\n    usage = us_c.find_one({\"id\": usage_id})\n\n    if not usage:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Usage record with ID {usage_id} not found\"\n        )\n\n    # Check device ownership for regular users\n    if current_user.role != \"admin\":\n        owns_device = check_device_ownership(usage[\"device_id\"], current_user.id)\n        if not owns_device:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to access this usage record\"\n            )\n\n    return UsageResponse.model_validate(usage)\n</code></pre>"},{"location":"api/#app.routes.usage_routes.get_usage_aggregate","title":"<code>app.routes.usage_routes.get_usage_aggregate(time_range, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get aggregated usage statistics for a specified time range and device. Users can only access data for their own devices, while admins can access any data.</p> <p>Parameters:</p> Name Type Description Default <code>time_range</code> <code>UsageTimeRange</code> <p>Object containing start_time, end_time, and device_id</p> required <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>UsageAggregateResponse</code> <p>Aggregated usage statistics</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.post(\"/aggregate/\", response_model=UsageAggregateResponse)\nasync def get_usage_aggregate(\n    time_range: UsageTimeRange,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get aggregated usage statistics for a specified time range and device.\n    Users can only access data for their own devices, while admins can access any data.\n\n    Args:\n        time_range: Object containing start_time, end_time, and device_id\n        current_user: The authenticated user\n\n    Returns:\n        UsageAggregateResponse: Aggregated usage statistics\n    \"\"\"\n    # TimeRange validator already checks that end_time is after start_time\n\n    # Check device ownership for regular users\n    if current_user.role != \"admin\":\n        if not check_device_ownership(time_range.device_id, current_user.id):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to access this device's data\"\n            )\n\n    # Build query filter\n    query = {\n        \"device_id\": time_range.device_id,\n        \"timestamp\": {\n            \"$gte\": time_range.start_time,\n            \"$lte\": time_range.end_time\n        }\n    }\n\n    # Get all usage records for the specified time range and device\n    cursor = us_c.find(query)\n    usage_records = list(cursor)\n\n    if not usage_records:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"No usage records found for the specified criteria\"\n        )\n\n    # Initialize aggregation results\n    total_duration = 0\n    total_energy = 0\n    usage_count = len(usage_records)\n\n    # Collect numeric metrics for averaging\n    metric_sums = {}\n    metric_counts = {}\n\n    for record in usage_records:\n        # Sum duration and energy\n        if \"duration\" in record and record[\"duration\"]:\n            total_duration += record[\"duration\"]\n\n        if \"energy_consumed\" in record and record[\"energy_consumed\"]:\n            total_energy += record[\"energy_consumed\"]\n\n        # Collect metrics for averaging\n        if \"metrics\" in record:\n            for key, value in record[\"metrics\"].items():\n                if isinstance(value, (int, float)):  # Only average numeric metrics\n                    if key not in metric_sums:\n                        metric_sums[key] = 0\n                        metric_counts[key] = 0\n\n                    metric_sums[key] += value\n                    metric_counts[key] += 1\n\n    # Calculate average metrics\n    average_metrics = {}\n    for key in metric_sums:\n        if metric_counts[key] &gt; 0:\n            average_metrics[key] = metric_sums[key] / metric_counts[key]\n\n    # Create the aggregated response\n    aggregated_data = UsageAggregateResponse(\n        device_id=time_range.device_id,\n        start_date=time_range.start_time,\n        end_date=time_range.end_time,\n        total_duration=total_duration,\n        total_energy=total_energy,\n        average_metrics=average_metrics,\n        usage_count=usage_count\n    )\n\n    return aggregated_data\n</code></pre>"},{"location":"api/#app.routes.usage_routes.update_usage","title":"<code>app.routes.usage_routes.update_usage(usage_id, usage_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a usage record's information. Users can only update records for their own devices, while admins can update any record.</p> <p>Parameters:</p> Name Type Description Default <code>usage_id</code> <code>str</code> <p>The ID of the usage record to update</p> required <code>usage_update</code> <code>UsageUpdate</code> <p>The data to update</p> required <code>current_user</code> <code>UserDB</code> <p>The authenticated user</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>UsageResponse</code> <p>The updated usage record</p> Source code in <code>app/routes/usage_routes.py</code> <pre><code>@router.patch(\"/{usage_id}\", response_model=UsageResponse)\nasync def update_usage(\n    usage_id: str,\n    usage_update: UsageUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a usage record's information.\n    Users can only update records for their own devices, while admins can update any record.\n\n    Args:\n        usage_id: The ID of the usage record to update\n        usage_update: The data to update\n        current_user: The authenticated user\n\n    Returns:\n        UsageResponse: The updated usage record\n    \"\"\"\n    # Find the usage record to update\n    usage = us_c.find_one({\"id\": usage_id})\n    if not usage:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Usage record with ID {usage_id} not found\"\n        )\n\n    # Check device ownership for regular users\n    if current_user.role != \"admin\":\n        owns_device = check_device_ownership(usage[\"device_id\"], current_user.id)\n        if not owns_device:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to update this usage record\"\n            )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {k: v for k, v in usage_update.model_dump().items() if v is not None}\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = us_c.update_one(\n                {\"id\": usage_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0 and len(update_data) &gt; 1:  # &gt; 1 to account for the updated timestamp\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"Usage record data not modified\"\n                )\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Failed to update usage record: {str(e)}\"\n            )\n\n    # Retrieve and return the updated usage record\n    updated_usage = us_c.find_one({\"id\": usage_id})\n    return UsageResponse.model_validate(updated_usage)\n</code></pre>"},{"location":"api/#app.routes.user_routes","title":"<code>app.routes.user_routes</code>","text":"<p>User management routes for the smart home system with debug prints.</p>"},{"location":"api/#app.routes.user_routes.create_user","title":"<code>app.routes.user_routes.create_user(user_create, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Create a new user. Only admin users can create new users.</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.post(\"/\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def create_user(\n    user_create: CreateUser,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new user.\n    Only admin users can create new users.\n    \"\"\"\n    # Debug print\n    # print(f\"DEBUG: create_user called with username={user_create.username}, u_c={u_c}\")\n\n    # Verify admin role\n    verify_role(current_user.role, \"admin\")\n\n    # Check if username or email already exists\n    username_exists = u_c.find_one({\"username\": user_create.username})\n    # print(f\"DEBUG: username_exists={username_exists}\")\n\n    if username_exists:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Username already exists\"\n        )\n\n    email_exists = u_c.find_one({\"email\": user_create.email})\n    # print(f\"DEBUG: email_exists={email_exists}\")\n\n    if email_exists:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email already exists\"\n        )\n\n    # Create a new UserDB model\n    hashed_password = hash_password(user_create.password)\n    user_db = UserDB(\n        username=user_create.username,\n        email=user_create.email,\n        hashed_password=hashed_password,\n        role=user_create.role\n    )\n\n    # Insert the user into the database\n    try:\n        u_c.insert_one(user_db.model_dump())\n    except DuplicateKeyError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"User with this ID, username, or email already exists\"\n        )\n\n    return UserResponse.model_validate(user_db)\n</code></pre>"},{"location":"api/#app.routes.user_routes.delete_user","title":"<code>app.routes.user_routes.delete_user(user_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Delete a user. Only admin users can delete users.</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_user(\n    user_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Delete a user.\n    Only admin users can delete users.\n    \"\"\"\n    # Verify admin role\n    verify_role(current_user.role, \"admin\")\n\n    # Find the user to delete\n    user = u_c.find_one({\"id\": user_id})\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User with ID {user_id} not found\"\n        )\n\n    # Perform the deletion\n    result = u_c.delete_one({\"id\": user_id})\n\n    if result.deleted_count == 0:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete user\"\n        )\n\n    return JSONResponse(status_code=status.HTTP_204_NO_CONTENT, content={})\n</code></pre>"},{"location":"api/#app.routes.user_routes.get_all_users","title":"<code>app.routes.user_routes.get_all_users(skip=0, limit=100, current_user=Depends(get_current_user), role=None, active=None)</code>  <code>async</code>","text":"<p>Get all users (admin only).</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.get(\"/\", response_model=List[UserResponse])\nasync def get_all_users(\n    skip: int = 0,\n    limit: int = 100,\n    current_user: UserDB = Depends(get_current_user),\n    role: Optional[str] = None,\n    active: Optional[bool] = None\n) -&gt; List[UserResponse]:\n    \"\"\"\n    Get all users (admin only).\n    \"\"\"\n    # Debug print\n    # print(f\"DEBUG: get_all_users called with u_c={u_c}, id(u_c)={id(u_c)}\")\n\n    # Check if user is admin\n    if current_user.role != \"admin\":\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to view all users\"\n        )\n\n    # Build query filter\n    query: Dict[str, Any] = {}\n    if role:\n        query[\"role\"] = role\n    if active is not None:\n        query[\"active\"] = active\n\n    # Debug print\n    # print(f\"DEBUG: Executing find with query={query}\")\n\n    # Convert cursor to list explicitly\n    cursor = u_c.find(query).skip(skip).limit(limit)\n    # print(f\"DEBUG: type(cursor)={type(cursor)}, cursor={cursor}\")\n\n    users = list(cursor)\n    # print(f\"DEBUG: users={users}, len(users)={len(users)}\")\n\n    # Convert to UserResponse models\n    return [UserResponse.model_validate(user) for user in users]\n</code></pre>"},{"location":"api/#app.routes.user_routes.get_user","title":"<code>app.routes.user_routes.get_user(user_id, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Get a single user by ID. Users can only access their own data, while admins can access any user's data.</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.get(\"/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: str,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Get a single user by ID.\n    Users can only access their own data, while admins can access any user's data.\n    \"\"\"    \n    # Debug print\n    # print(f\"DEBUG: get_user called with user_id={user_id}, u_c={u_c}\")\n\n    # Check if the requesting user is the user being requested or an admin\n    if current_user.role != \"admin\" and current_user.id != user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to access this user's data\"\n        )\n\n    user = u_c.find_one({\"id\": user_id})\n    # print(f\"DEBUG: find_one result={user}\")\n\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User with ID {user_id} not found\"\n        )\n\n    return UserResponse.model_validate(user)\n</code></pre>"},{"location":"api/#app.routes.user_routes.update_user","title":"<code>app.routes.user_routes.update_user(user_id, user_update, current_user=Depends(get_current_user))</code>  <code>async</code>","text":"<p>Update a user's information. Users can only update their own data, while admins can update any user's data.</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.patch(\"/{user_id}\", response_model=UserResponse)\nasync def update_user(\n    user_id: str,\n    user_update: UserUpdate,\n    current_user: UserDB = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's information.\n    Users can only update their own data, while admins can update any user's data.\n    \"\"\"\n    # Check if the requesting user is the user being updated or an admin\n    if current_user.role != \"admin\" and current_user.id != user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Not authorized to update this user's data\"\n        )\n\n    # Find the user to update\n    user = u_c.find_one({\"id\": user_id})\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User with ID {user_id} not found\"\n        )\n\n    # Create update data dictionary with only the provided fields\n    update_data = {}\n    if user_update.username is not None:\n        # Check if new username already exists (if it's different from current)\n        if user_update.username != user[\"username\"]:\n            if u_c.find_one({\"username\": user_update.username}):\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Username already exists\"\n                )\n        update_data[\"username\"] = user_update.username\n\n    if user_update.email is not None:\n        # Check if new email already exists (if it's different from current)\n        if user_update.email != user[\"email\"]:\n            if u_c.find_one({\"email\": user_update.email}):\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Email already exists\"\n                )\n        update_data[\"email\"] = user_update.email\n\n    # Add updated timestamp\n    update_data[\"updated\"] = datetime.utcnow()\n\n    # Perform the update if there's data to update\n    if update_data:\n        try:\n            result = u_c.update_one(\n                {\"id\": user_id},\n                {\"$set\": update_data}\n            )\n            if result.modified_count == 0:\n                raise HTTPException(\n                    status_code=status.HTTP_304_NOT_MODIFIED,\n                    detail=\"User data not modified\"\n                )\n        except DuplicateKeyError:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Update would create a duplicate username or email\"\n            )\n\n    # Retrieve and return the updated user\n    updated_user = u_c.find_one({\"id\": user_id})\n    return UserResponse.model_validate(updated_user)\n</code></pre>"},{"location":"api/#app.seeds.seed_database","title":"<code>app.seeds.seed_database</code>","text":"<p>Database seeding script for Smart Home Automation platform. This script populates the MongoDB collections with realistic data.</p>"},{"location":"api/#app.seeds.seed_database.clear_collections","title":"<code>app.seeds.seed_database.clear_collections()</code>","text":"<p>Clear all collections to start fresh.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def clear_collections():\n    \"\"\"Clear all collections to start fresh.\"\"\"\n    collections = [\n        user_collection, profile_collection, device_collection, room_collection, \n        usage_collection, automation_collection, notification_collection, \n        access_management_collection, goal_collection, analytics_collection, \n        suggestion_collection\n    ]\n    for collection in collections:\n        collection.delete_many({})\n    print(\"All collections cleared.\")\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_access_management","title":"<code>app.seeds.seed_database.create_access_management(users, devices)</code>","text":"<p>Create access management entries for sharing resources.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_access_management(users: List[Dict[str, Any]], devices: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create access management entries for sharing resources.\"\"\"\n    access_entries = []\n\n    # For each user who has devices\n    for user in users:\n        user_devices = [d for d in devices if d[\"user_id\"] == user[\"id\"]]\n        if not user_devices:\n            continue\n\n        # Determine if this user shares devices (40% chance)\n        if random.random() &gt; 0.6:\n            # Find possible recipients (other users)\n            other_users = [u for u in users if u[\"id\"] != user[\"id\"]]\n            if not other_users:\n                continue\n\n            # Determine how many devices to share (1-3)\n            num_shares = random.randint(1, min(3, len(user_devices)))\n\n            # Select devices to share\n            devices_to_share = random.sample(user_devices, num_shares)\n\n            # For each device, create sharing\n            for device in devices_to_share:\n                # Choose 1-3 users to share with\n                share_recipients = random.sample(other_users, random.randint(1, min(3, len(other_users))))\n\n                # Determine access level\n                access_level = random.choice([\"read\", \"control\", \"manage\"])\n\n                # Determine if there's an expiration (30% chance)\n                expires_at = None\n                if random.random() &gt; 0.7:\n                    # Expire 1-30 days from now\n                    expires_at = datetime.now() + timedelta(days=random.randint(1, 30))\n\n                # Create note (50% chance)\n                note = None\n                if random.random() &gt; 0.5:\n                    note_templates = [\n                        f\"Sharing {device['name']} with family\",\n                        f\"Temporary access for house sitting\",\n                        f\"Guest access to {device['name']}\",\n                        f\"Please don't change the settings\",\n                        f\"Access for the weekend\"\n                    ]\n                    note = random.choice(note_templates)\n\n                # Create access entry for each recipient\n                for recipient in share_recipients:\n                    access_entry = {\n                        \"id\": generate_uuid(),\n                        \"owner_id\": user[\"id\"],\n                        \"resource_id\": device[\"id\"],\n                        \"resource_type\": \"device\",  # Simplified - could also be room, home, etc.\n                        \"user_id\": recipient[\"id\"],\n                        \"access_level\": access_level,\n                        \"created\": random_date(device[\"created\"], datetime(2024, 2, 15)),\n                        \"updated\": None,\n                        \"expires_at\": expires_at,\n                        \"active\": True,\n                        \"note\": note\n                    }\n\n                    # 30% chance of update\n                    if random.random() &gt; 0.7:\n                        access_entry[\"updated\"] = random_date(access_entry[\"created\"], datetime(2024, 3, 21))\n\n                    access_entries.append(access_entry)\n                    access_management_collection.insert_one(access_entry)\n\n    print(f\"Created {len(access_entries)} access management entries\")\n    return access_entries\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_analytics","title":"<code>app.seeds.seed_database.create_analytics(users, devices)</code>","text":"<p>Create analytics data for devices.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_analytics(users: List[Dict[str, Any]], devices: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create analytics data for devices.\"\"\"\n    analytics_entries = []\n    data_types = [\"energy\", \"usage\", \"temperature\", \"humidity\", \"motion\", \"light\"]\n\n    for device in devices:\n        # Skip offline devices\n        if device[\"status\"] == \"offline\":\n            continue\n\n        # Determine appropriate data types for this device\n        applicable_types = []\n        if device[\"type\"] == \"light\":\n            applicable_types = [\"energy\", \"usage\", \"light\"]\n        elif device[\"type\"] == \"thermostat\":\n            applicable_types = [\"energy\", \"temperature\", \"humidity\"]\n        elif device[\"type\"] == \"lock\":\n            applicable_types = [\"usage\"]\n        elif device[\"type\"] == \"camera\":\n            applicable_types = [\"usage\", \"motion\"]\n        elif device[\"type\"] == \"sensor\":\n            # Determine sensor type from name\n            sensor_type = \"motion\"  # default\n            if \"temperature\" in device[\"name\"].lower():\n                applicable_types = [\"temperature\"]\n            elif \"humidity\" in device[\"name\"].lower():\n                applicable_types = [\"humidity\"]\n            elif \"motion\" in device[\"name\"].lower():\n                applicable_types = [\"motion\"]\n            elif \"light\" in device[\"name\"].lower():\n                applicable_types = [\"light\"]\n            else:\n                applicable_types = [random.choice(data_types)]\n        elif device[\"type\"] == \"outlet\":\n            applicable_types = [\"energy\", \"usage\"]\n        else:\n            applicable_types = [\"energy\", \"usage\"]\n\n        # Determine number of analytics entries (1-20)\n        num_entries = random.randint(1, 20)\n\n        for _ in range(num_entries):\n            # Choose data type\n            data_type = random.choice(applicable_types)\n\n            # Generate metrics based on data type\n            metrics = {}\n            if data_type == \"energy\":\n                metrics = {\n                    \"consumption\": round(random.uniform(0.1, 10), 3),  # kWh\n                    \"cost\": round(random.uniform(0.01, 1.5), 2),  # $\n                    \"duration\": random.randint(10, 1440)  # minutes\n                }\n            elif data_type == \"usage\":\n                metrics = {\n                    \"duration\": random.randint(10, 480),  # minutes\n                    \"interactions\": random.randint(1, 50),\n                    \"active_time\": random.randint(5, 200)  # minutes\n                }\n            elif data_type == \"temperature\":\n                metrics = {\n                    \"value\": round(random.uniform(18, 26), 1),  # Celsius\n                    \"setpoint\": round(random.uniform(20, 24), 1),  # Celsius\n                    \"outside_temp\": round(random.uniform(10, 35), 1)  # Celsius\n                }\n            elif data_type == \"humidity\":\n                metrics = {\n                    \"value\": random.randint(30, 70),  # Percent\n                    \"comfort_zone\": random.choice([\"low\", \"optimal\", \"high\"])\n                }\n            elif data_type == \"motion\":\n                metrics = {\n                    \"detected\": random.random() &gt; 0.3,\n                    \"duration\": random.randint(0, 120) if metrics.get(\"detected\", False) else 0,\n                    \"peak_time\": f\"{random.randint(0, 23):02d}:{random.choice(['00', '15', '30', '45'])}\"\n                }\n            elif data_type == \"light\":\n                metrics = {\n                    \"level\": random.randint(0, 100),  # Percent\n                    \"color_temp\": random.randint(2000, 6500),  # Kelvin\n                    \"is_natural\": random.random() &gt; 0.5\n                }\n\n            # Generate tags\n            tags = []\n            if random.random() &gt; 0.4:  # 60% have tags\n                possible_tags = [\"daily\", \"weekly\", \"monthly\", \"peak\", \"off-peak\", \"weekend\", \"weekday\"]\n                num_tags = random.randint(1, 3)\n                tags = random.sample(possible_tags, num_tags)\n\n            # Create analytics entry\n            timestamp = random_datetime(device[\"created\"], datetime(2024, 3, 21))\n            analytics_entry = {\n                \"id\": generate_uuid(),\n                \"user_id\": device[\"user_id\"],\n                \"device_id\": device[\"id\"],\n                \"data_type\": data_type,\n                \"metrics\": metrics,\n                \"tags\": tags,\n                \"timestamp\": timestamp,\n                \"updated\": None\n            }\n\n            # 20% chance of update\n            if random.random() &gt; 0.8:\n                analytics_entry[\"updated\"] = timestamp + timedelta(minutes=random.randint(5, 60))\n\n            analytics_entries.append(analytics_entry)\n            analytics_collection.insert_one(analytics_entry)\n\n    print(f\"Created {len(analytics_entries)} analytics entries\")\n    return analytics_entries\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_automations","title":"<code>app.seeds.seed_database.create_automations(users, devices)</code>","text":"<p>Create automations for users' devices.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_automations(users: List[Dict[str, Any]], devices: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create automations for users' devices.\"\"\"\n    automations = []\n\n    # Map users to their devices\n    user_devices = {}\n    for device in devices:\n        if device[\"user_id\"] not in user_devices:\n            user_devices[device[\"user_id\"]] = []\n        user_devices[device[\"user_id\"]].append(device)\n\n    trigger_types = [\"time\", \"sensor\", \"manual\", \"device_state\", \"location\", \"weather\"]\n    action_types = [\"device_control\", \"notification\", \"scene_activation\", \"energy_management\"]\n\n    for user in users:\n        if user[\"id\"] not in user_devices:\n            continue\n\n        # Determine number of automations (2-8)\n        num_automations = random.randint(2, 8)\n\n        for _ in range(num_automations):\n            # Select trigger type\n            trigger_type = random.choice(trigger_types)\n\n            # Select action type\n            action_type = random.choice(action_types)\n\n            # Select a device from user's devices\n            device = random.choice(user_devices[user[\"id\"]])\n\n            # Generate trigger data based on type\n            trigger_data = {}\n            if trigger_type == \"time\":\n                trigger_data = {\n                    \"time\": f\"{random.randint(0, 23):02d}:{random.choice(['00', '15', '30', '45'])}\",\n                    \"days\": random.sample([\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"], \n                                         random.randint(1, 7))\n                }\n            elif trigger_type == \"sensor\":\n                trigger_data = {\n                    \"sensor_id\": random.choice(user_devices[user[\"id\"]])[\"id\"],\n                    \"condition\": random.choice([\"motion_detected\", \"temperature_above\", \"temperature_below\"]),\n                    \"threshold\": random.randint(15, 30) if \"temperature\" in trigger_data.get(\"condition\", \"\") else None\n                }\n            elif trigger_type == \"device_state\":\n                trigger_data = {\n                    \"device_id\": random.choice(user_devices[user[\"id\"]])[\"id\"],\n                    \"state\": random.choice([\"on\", \"off\", \"locked\", \"unlocked\"]),\n                    \"for_duration\": random.randint(0, 30) if random.random() &gt; 0.7 else None\n                }\n            elif trigger_type == \"location\":\n                trigger_data = {\n                    \"condition\": random.choice([\"arriving\", \"leaving\"]),\n                    \"user_ids\": [user[\"id\"]]\n                }\n            elif trigger_type == \"weather\":\n                trigger_data = {\n                    \"condition\": random.choice([\"sunny\", \"rainy\", \"cloudy\", \"snowy\"]),\n                    \"temperature_above\": random.randint(20, 30) if random.random() &gt; 0.5 else None,\n                    \"temperature_below\": random.randint(0, 15) if random.random() &gt; 0.5 else None\n                }\n            else:  # manual\n                trigger_data = {\n                    \"button_press\": random.choice([\"single\", \"double\", \"long\"]),\n                    \"device_id\": random.choice(user_devices[user[\"id\"]])[\"id\"]\n                }\n\n            # Generate action data based on type\n            action_data = {}\n            if action_type == \"device_control\":\n                target_device = random.choice(user_devices[user[\"id\"]])\n                if target_device[\"type\"] == \"light\":\n                    action_data = {\n                        \"device_id\": target_device[\"id\"],\n                        \"action\": random.choice([\"turn_on\", \"turn_off\", \"toggle\", \"dim\"]),\n                        \"brightness\": random.randint(10, 100) if \"dim\" in action_data.get(\"action\", \"\") else None\n                    }\n                elif target_device[\"type\"] == \"thermostat\":\n                    action_data = {\n                        \"device_id\": target_device[\"id\"],\n                        \"action\": random.choice([\"set_temperature\", \"set_mode\"]),\n                        \"temperature\": random.randint(18, 26) if \"temperature\" in action_data.get(\"action\", \"\") else None,\n                        \"mode\": random.choice([\"heat\", \"cool\", \"auto\", \"off\"]) if \"mode\" in action_data.get(\"action\", \"\") else None\n                    }\n                else:\n                    action_data = {\n                        \"device_id\": target_device[\"id\"],\n                        \"action\": random.choice([\"turn_on\", \"turn_off\", \"toggle\"])\n                    }\n            elif action_type == \"notification\":\n                action_data = {\n                    \"title\": random.choice([\n                        \"Home Alert\", \"Device Status\", \"Automation Triggered\", \n                        \"Security Alert\", \"Energy Notification\"\n                    ]),\n                    \"message\": random.choice([\n                        \"Your automation was triggered\",\n                        f\"Device {device['name']} has changed state\",\n                        \"Motion detected in your home\",\n                        \"Temperature threshold reached\",\n                        \"Someone has arrived home\"\n                    ]),\n                    \"priority\": random.choice([\"low\", \"medium\", \"high\"])\n                }\n            elif action_type == \"scene_activation\":\n                action_data = {\n                    \"scene_name\": random.choice([\n                        \"Good Morning\", \"Good Night\", \"Movie Time\", \"Dinner Mode\",\n                        \"Away Mode\", \"Welcome Home\", \"Party Mode\", \"Reading Time\"\n                    ])\n                }\n            elif action_type == \"energy_management\":\n                action_data = {\n                    \"action\": random.choice([\"eco_mode\", \"power_saving\", \"schedule_adjustment\"]),\n                    \"devices\": [d[\"id\"] for d in random.sample(\n                        user_devices[user[\"id\"]], \n                        random.randint(1, min(3, len(user_devices[user[\"id\"]])))\n                    )]\n                }\n\n            # Create name and description\n            if trigger_type == \"time\":\n                name = f\"{trigger_data.get('time', '00:00')} {action_data.get('scene_name', '') or action_type.replace('_', ' ').title()}\"\n            elif trigger_type == \"sensor\":\n                sensor_device = next((d for d in devices if d[\"id\"] == trigger_data.get(\"sensor_id\")), None)\n                name = f\"When {sensor_device['name'] if sensor_device else 'sensor'} {trigger_data.get('condition', '')}\"\n            elif trigger_type == \"location\":\n                name = f\"When {trigger_data.get('condition', '')} home\"\n            else:\n                name = f\"{trigger_type.replace('_', ' ').title()} Automation {random.randint(1, 100)}\"\n\n            description = f\"Automation that triggers when {trigger_type.replace('_', ' ')} and performs {action_type.replace('_', ' ')}\"\n\n            # Create automation - use safe date range\n            end_date = datetime(2024, 2, 1)\n            created_date = random_date(device[\"created\"], end_date)\n            automation = {\n                \"id\": generate_uuid(),\n                \"name\": name,\n                \"description\": description,\n                \"user_id\": user[\"id\"],\n                \"device_id\": device[\"id\"],\n                \"enabled\": random.random() &gt; 0.2,  # 80% enabled\n                \"trigger_type\": trigger_type,\n                \"trigger_data\": trigger_data,\n                \"action_type\": action_type,\n                \"action_data\": action_data,\n                \"conditions\": None,  # Simplified for now\n                \"created\": created_date,\n                \"updated\": random_date(created_date, datetime(2024, 3, 21)) if random.random() &gt; 0.7 else None,\n                \"last_triggered\": random_date(created_date, datetime(2024, 3, 21)) if random.random() &gt; 0.4 else None,\n                \"execution_count\": random.randint(0, 100)\n            }\n\n            automations.append(automation)\n            automation_collection.insert_one(automation)\n\n    print(f\"Created {len(automations)} automations\")\n    return automations\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_devices","title":"<code>app.seeds.seed_database.create_devices(users, rooms, profiles)</code>","text":"<p>Create devices for each user, assigned to rooms.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_devices(users: List[Dict[str, Any]], rooms: List[Dict[str, Any]], profiles: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create devices for each user, assigned to rooms.\"\"\"\n    devices = []\n    device_types = list(DEVICE_CAPABILITIES.keys())\n\n    # Map users to their rooms\n    user_rooms = {}\n    for room in rooms:\n        if room[\"user_id\"] not in user_rooms:\n            user_rooms[room[\"user_id\"]] = []\n        user_rooms[room[\"user_id\"]].append(room)\n\n    # Create devices for each user\n    for user in users:\n        if user[\"id\"] not in user_rooms:\n            continue\n\n        # Get this user's profile\n        user_profile = next((p for p in profiles if p[\"user_id\"] == user[\"id\"]), None)\n\n        # Find rooms for this user\n        user_room_list = user_rooms[user[\"id\"]]\n\n        # Determine how many devices this user has (between 5 and 20)\n        num_devices = random.randint(5, 20)\n\n        # Create devices and assign to rooms\n        for _ in range(num_devices):\n            # Select random device type\n            device_type = random.choice(device_types)\n\n            # Select manufacturer for this device type\n            manufacturer = random.choice(DEVICE_MANUFACTURERS[device_type])\n\n            # Select model for this manufacturer if available, otherwise generic\n            if manufacturer in DEVICE_MODELS:\n                model = random.choice(DEVICE_MODELS[manufacturer])\n            else:\n                model = f\"{device_type.capitalize()} {random.choice(['Basic', 'Pro', 'Plus', 'Premium'])}\"\n\n            # Select capabilities for this device type\n            capabilities = DEVICE_CAPABILITIES[device_type]\n\n            # Select a room\n            room = random.choice(user_room_list)\n\n            # Create device name based on type and room\n            if device_type == \"light\":\n                name_patterns = [\n                    f\"{room['name']} Light\",\n                    f\"{room['name']} Lamp\",\n                    f\"{room['name']} Ceiling Light\",\n                    f\"{room['name']} Accent Light\"\n                ]\n                name = random.choice(name_patterns)\n            elif device_type == \"thermostat\":\n                name = f\"{room['name']} Thermostat\"\n            elif device_type == \"lock\":\n                name_patterns = [\n                    f\"{room['name']} Door Lock\",\n                    f\"Front Door Lock\",\n                    f\"Back Door Lock\",\n                    f\"Side Door Lock\",\n                    f\"Garage Door Lock\"\n                ]\n                name = random.choice(name_patterns)\n            elif device_type == \"camera\":\n                name_patterns = [\n                    f\"{room['name']} Camera\",\n                    f\"{room['name']} Security Camera\",\n                    f\"Indoor Camera {room['name']}\",\n                    f\"Doorbell Camera\"\n                ]\n                name = random.choice(name_patterns)\n            elif device_type == \"sensor\":\n                sensor_types = [\"Motion\", \"Temperature\", \"Humidity\", \"Door\", \"Window\", \"Water Leak\"]\n                sensor_type = random.choice(sensor_types)\n                name = f\"{room['name']} {sensor_type} Sensor\"\n            elif device_type == \"switch\":\n                name = f\"{room['name']} Switch\"\n            elif device_type == \"outlet\":\n                name_patterns = [\n                    f\"{room['name']} Outlet\",\n                    f\"{room['name']} Smart Plug\",\n                    f\"{room['name']} Power Outlet\"\n                ]\n                name = random.choice(name_patterns)\n            elif device_type == \"speaker\":\n                name_patterns = [\n                    f\"{room['name']} Speaker\",\n                    f\"{manufacturer} {model} ({room['name']})\",\n                    f\"Smart Speaker {room['name']}\"\n                ]\n                name = random.choice(name_patterns)\n            else:\n                name = f\"{room['name']} {device_type.capitalize()}\"\n\n            # Random device status with weights\n            status_choices = [\"online\", \"offline\", \"error\", \"maintenance\"]\n            status_weights = [0.8, 0.15, 0.03, 0.02]\n            status = random.choices(status_choices, weights=status_weights)[0]\n\n            # Random settings based on device type\n            settings = {}\n            if device_type == \"light\":\n                settings = {\n                    \"brightness\": random.randint(0, 100),\n                    \"color_temp\": random.randint(2000, 6500),\n                    \"on\": random.random() &gt; 0.5\n                }\n                if \"color\" in capabilities:\n                    settings[\"color\"] = {\n                        \"hue\": random.randint(0, 360),\n                        \"saturation\": random.randint(0, 100)\n                    }\n            elif device_type == \"thermostat\":\n                settings = {\n                    \"current_temp\": round(random.uniform(18, 26), 1),\n                    \"target_temp\": round(random.uniform(20, 24), 1),\n                    \"mode\": random.choice([\"heat\", \"cool\", \"auto\", \"off\"]),\n                    \"eco_mode\": random.random() &gt; 0.7\n                }\n            elif device_type == \"lock\":\n                settings = {\n                    \"locked\": random.random() &gt; 0.7,\n                    \"auto_lock_enabled\": random.random() &gt; 0.5,\n                    \"auto_lock_timeout\": random.choice([30, 60, 120, 300])\n                }\n\n            # Generate IP and MAC for some devices\n            ip_address = None\n            mac_address = None\n            if random.random() &gt; 0.3:  # 70% have IP\n                ip_address = fake.ipv4()\n                mac_address = \":\".join([f\"{random.randint(0, 255):02x}\" for _ in range(6)])\n\n            # Firmware version\n            firmware_version = f\"{random.randint(1, 5)}.{random.randint(0, 9)}.{random.randint(0, 9)}\"\n\n            # Create device\n            device_id = generate_uuid()\n            # Ensure device creation date is valid (not after March 1, 2024)\n            device_created_date = random_date(user[\"created\"], datetime(2024, 3, 1))\n            device = {\n                \"id\": device_id,\n                \"name\": name,\n                \"type\": device_type,\n                \"user_id\": user[\"id\"],\n                \"room_id\": room[\"id\"],\n                \"ip_address\": ip_address,\n                \"mac_address\": mac_address,\n                \"manufacturer\": manufacturer,\n                \"model\": model,\n                \"firmware_version\": firmware_version,\n                \"settings\": settings,\n                \"status\": status,\n                \"last_online\": datetime.now() - timedelta(minutes=random.randint(0, 1440)) if status != \"offline\" else None,\n                \"created\": device_created_date,\n                \"updated\": None,\n                \"capabilities\": random.sample(capabilities, min(len(capabilities), random.randint(1, len(capabilities))))\n            }\n\n            # 40% chance device has been updated\n            if random.random() &gt; 0.6:\n                device[\"updated\"] = random_date(device[\"created\"], datetime(2024, 3, 21))\n\n            devices.append(device)\n            device_collection.insert_one(device)\n\n            # Add device to room\n            room_collection.update_one(\n                {\"id\": room[\"id\"]},\n                {\"$push\": {\"devices\": device_id}}\n            )\n\n            # 20% chance this device is a favorite\n            if user_profile and random.random() &gt; 0.8:\n                profile_collection.update_one(\n                    {\"user_id\": user[\"id\"]},\n                    {\"$push\": {\"favorite_devices\": device_id}}\n                )\n\n    print(f\"Created {len(devices)} devices\")\n    return devices\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_energy_goals","title":"<code>app.seeds.seed_database.create_energy_goals(users, devices)</code>","text":"<p>Create energy saving goals for users.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_energy_goals(users: List[Dict[str, Any]], devices: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create energy saving goals for users.\"\"\"\n    goals = []\n\n    # Goal templates\n    goal_templates = [\n        {\n            \"title\": \"Reduce Monthly Energy Usage\",\n            \"description\": \"Goal to reduce total energy consumption by {target_value}% compared to last month.\",\n            \"type\": \"energy_saving\"\n        },\n        {\n            \"title\": \"Limit Peak Hour Consumption\",\n            \"description\": \"Reduce energy usage during peak hours (6-9pm) to less than {target_value} kWh per day.\",\n            \"type\": \"consumption_limit\"\n        },\n        {\n            \"title\": \"Lower Standby Power Usage\",\n            \"description\": \"Reduce standby power consumption by {target_value}% by optimizing device settings.\",\n            \"type\": \"usage_reduction\"\n        },\n        {\n            \"title\": \"Avoid Peak Demand Charges\",\n            \"description\": \"Keep peak demand below {target_value} kW to avoid extra charges on your utility bill.\",\n            \"type\": \"peak_avoidance\"\n        },\n        {\n            \"title\": \"Increase Renewable Energy Usage\",\n            \"description\": \"Shift {target_value}% of energy consumption to hours with higher renewable energy availability.\",\n            \"type\": \"renewable_usage\"\n        }\n    ]\n\n    for user in users:\n        # 60% chance user has goals\n        if random.random() &gt; 0.4:\n            # Get user's devices\n            user_devices = [d for d in devices if d[\"user_id\"] == user[\"id\"]]\n            if not user_devices:\n                continue\n\n            # Determine number of goals (1-3)\n            num_goals = random.randint(1, 3)\n\n            for _ in range(num_goals):\n                # Choose template\n                template = random.choice(goal_templates)\n\n                # Determine timeframe\n                timeframe = random.choice([\"daily\", \"weekly\", \"monthly\", \"yearly\"])\n\n                # Set target value based on goal type\n                if template[\"type\"] == \"energy_saving\" or template[\"type\"] == \"usage_reduction\":\n                    target_value = random.randint(5, 25)  # Percent reduction\n                elif template[\"type\"] == \"consumption_limit\":\n                    target_value = random.randint(5, 20)  # kWh limit\n                elif template[\"type\"] == \"peak_avoidance\":\n                    target_value = random.randint(3, 8)  # kW limit\n                else:  # renewable_usage\n                    target_value = random.randint(20, 50)  # Percent of renewable\n\n                # Fill in description\n                description = template[\"description\"].replace(\"{target_value}\", str(target_value))\n\n                # Determine start date\n                start_date = random_date(datetime(2024, 1, 1), datetime(2024, 3, 1))\n\n                # Determine end date based on timeframe\n                end_date = None\n                if timeframe == \"daily\":\n                    end_date = start_date + timedelta(days=1)\n                elif timeframe == \"weekly\":\n                    end_date = start_date + timedelta(weeks=1)\n                elif timeframe == \"monthly\":\n                    end_date = start_date + timedelta(days=30)\n                elif timeframe == \"yearly\":\n                    end_date = start_date + timedelta(days=365)\n                else:  # custom\n                    end_date = start_date + timedelta(days=random.randint(7, 90))\n\n                # Determine related devices (if any)\n                related_devices = []\n                if random.random() &gt; 0.3:  # 70% chance of related devices\n                    num_related = random.randint(1, min(5, len(user_devices)))\n                    related_devices = [d[\"id\"] for d in random.sample(user_devices, num_related)]\n\n                # Determine current progress\n                current_value = 0\n                progress_percentage = 0\n\n                # If goal is in the past or ongoing, set some progress\n                if end_date &lt; datetime.now() or random.random() &gt; 0.5:\n                    if template[\"type\"] == \"energy_saving\" or template[\"type\"] == \"usage_reduction\":\n                        current_value = random.randint(1, target_value)\n                    elif template[\"type\"] == \"consumption_limit\":\n                        current_value = random.randint(target_value - 5, target_value + 5)\n                    elif template[\"type\"] == \"peak_avoidance\":\n                        current_value = random.randint(target_value - 2, target_value + 2)\n                    else:  # renewable_usage\n                        current_value = random.randint(1, target_value)\n\n                    progress_percentage = min(100, int((current_value / target_value) * 100))\n\n                # Determine status\n                if end_date &lt; datetime.now():\n                    if progress_percentage &gt;= 100:\n                        status = \"completed\"\n                    else:\n                        status = \"failed\"\n                else:\n                    status = random.choice([\"active\", \"paused\"]) if random.random() &gt; 0.2 else \"active\"\n\n                goal = {\n                    \"id\": generate_uuid(),\n                    \"user_id\": user[\"id\"],\n                    \"title\": template[\"title\"],\n                    \"description\": description,\n                    \"type\": template[\"type\"],\n                    \"target_value\": float(target_value),\n                    \"current_value\": float(current_value),\n                    \"progress_percentage\": float(progress_percentage),\n                    \"timeframe\": timeframe,\n                    \"start_date\": start_date,\n                    \"end_date\": end_date,\n                    \"status\": status,\n                    \"related_devices\": related_devices,\n                    \"created\": start_date - timedelta(days=random.randint(1, 7)),\n                    \"updated\": random_date(start_date, datetime(2024, 3, 21)) if random.random() &gt; 0.5 else None\n                }\n\n                goals.append(goal)\n                goal_collection.insert_one(goal)\n\n    print(f\"Created {len(goals)} energy goals\")\n    return goals\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_homes","title":"<code>app.seeds.seed_database.create_homes(users)</code>","text":"<p>Create homes for users (conceptual, not in database).</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_homes(users: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create homes for users (conceptual, not in database).\"\"\"\n    homes = []\n\n    for user in users:\n        # Each user has 1-3 homes\n        num_homes = random.choices([1, 2, 3], weights=[0.7, 0.2, 0.1])[0]\n\n        for i in range(num_homes):\n            home_name = \"Main Home\"\n            if i == 1:\n                home_name = random.choice([\"Vacation Home\", \"Beach House\", \"Cabin\", \"Lake House\"])\n            elif i == 2:\n                home_name = random.choice([\"Rental Property\", \"Parents' House\", \"Office\"])\n\n            home = {\n                \"id\": generate_uuid(),\n                \"user_id\": user[\"id\"],\n                \"name\": home_name,\n                \"address\": fake.address(),\n                \"created\": user[\"created\"]\n            }\n            homes.append(home)\n\n    print(f\"Created {len(homes)} conceptual homes\")\n    return homes\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_notifications","title":"<code>app.seeds.seed_database.create_notifications(users, devices, automations, rooms)</code>","text":"<p>Create notifications for users.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_notifications(users: List[Dict[str, Any]], devices: List[Dict[str, Any]], automations: List[Dict[str, Any]], rooms: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create notifications for users.\"\"\"\n    notifications = []\n\n    # Notification templates by type\n    notification_templates = {\n        \"alert\": [\n            {\"title\": \"Motion Detected\", \"message\": \"Motion was detected in {room}\"},\n            {\"title\": \"Door Unlocked\", \"message\": \"Your {device} was unlocked\"},\n            {\"title\": \"Temperature Alert\", \"message\": \"Temperature is too {high_low} in {room}\"},\n            {\"title\": \"Battery Low\", \"message\": \"{device} battery is running low\"},\n            {\"title\": \"Water Leak Detected\", \"message\": \"Water leak detected by {device}\"}\n        ],\n        \"info\": [\n            {\"title\": \"Device Offline\", \"message\": \"{device} appears to be offline\"},\n            {\"title\": \"Update Available\", \"message\": \"A firmware update is available for {device}\"},\n            {\"title\": \"Energy Report\", \"message\": \"Your weekly energy report is ready\"},\n            {\"title\": \"New Device Detected\", \"message\": \"A new device was detected on your network\"},\n            {\"title\": \"Automation Created\", \"message\": \"Your new automation '{automation}' has been created\"}\n        ],\n        \"warning\": [\n            {\"title\": \"Device Error\", \"message\": \"{device} reported an error: {error_code}\"},\n            {\"title\": \"High Energy Usage\", \"message\": \"Your energy usage is {percent}% higher than usual\"},\n            {\"title\": \"Failed Authentication\", \"message\": \"Failed login attempt detected\"},\n            {\"title\": \"Connection Issues\", \"message\": \"{device} is having connectivity problems\"},\n            {\"title\": \"Hub Offline\", \"message\": \"Your smart home hub is offline\"}\n        ],\n        \"success\": [\n            {\"title\": \"Automation Successful\", \"message\": \"Automation '{automation}' ran successfully\"},\n            {\"title\": \"Device Added\", \"message\": \"{device} was successfully added to your home\"},\n            {\"title\": \"Update Completed\", \"message\": \"{device} was successfully updated to version {version}\"},\n            {\"title\": \"Energy Goal Met\", \"message\": \"Congratulations! You met your energy saving goal\"},\n            {\"title\": \"Device Paired\", \"message\": \"{device} was successfully paired with your account\"}\n        ]\n    }\n\n    for user in users:\n        # Determine number of notifications (5-30)\n        num_notifications = random.randint(5, 30)\n\n        # Get user's devices\n        user_devices = [d for d in devices if d[\"user_id\"] == user[\"id\"]]\n        if not user_devices:\n            continue\n\n        # Get user's automations\n        user_automations = [a for a in automations if a[\"user_id\"] == user[\"id\"]]\n\n        for _ in range(num_notifications):\n            # Determine notification type\n            notification_type = random.choices(\n                [\"alert\", \"info\", \"warning\", \"success\"],\n                weights=[0.2, 0.5, 0.2, 0.1]\n            )[0]\n\n            # Determine priority\n            priority = random.choices(\n                [\"low\", \"medium\", \"high\"],\n                weights=[0.3, 0.5, 0.2]\n            )[0]\n\n            # Determine source\n            source = random.choices(\n                [\"device\", \"system\", \"automation\", \"goal\", \"security\"],\n                weights=[0.4, 0.3, 0.2, 0.05, 0.05]\n            )[0]\n\n            # Get template\n            template = random.choice(notification_templates[notification_type])\n            title = template[\"title\"]\n            message = template[\"message\"]\n\n            # Fill in placeholders\n            source_id = None\n            if \"{device}\" in message or \"{device}\" in title:\n                device = random.choice(user_devices)\n                title = title.replace(\"{device}\", device[\"name\"])\n                message = message.replace(\"{device}\", device[\"name\"])\n                if source == \"device\":\n                    source_id = device[\"id\"]\n\n            if \"{room}\" in message or \"{room}\" in title:\n                if user_devices:\n                    device = random.choice(user_devices)\n                    room_id = device[\"room_id\"]\n                    room = next((r for r in rooms if r[\"id\"] == room_id), None)\n                    if room:\n                        title = title.replace(\"{room}\", room[\"name\"])\n                        message = message.replace(\"{room}\", room[\"name\"])\n\n            if \"{automation}\" in message or \"{automation}\" in title:\n                if user_automations:\n                    automation = random.choice(user_automations)\n                    title = title.replace(\"{automation}\", automation[\"name\"])\n                    message = message.replace(\"{automation}\", automation[\"name\"])\n                    if source == \"automation\":\n                        source_id = automation[\"id\"]\n\n            if \"{high_low}\" in message:\n                message = message.replace(\"{high_low}\", random.choice([\"high\", \"low\"]))\n\n            if \"{percent}\" in message:\n                message = message.replace(\"{percent}\", str(random.randint(15, 50)))\n\n            if \"{error_code}\" in message:\n                message = message.replace(\"{error_code}\", f\"E{random.randint(100, 999)}\")\n\n            if \"{version}\" in message:\n                message = message.replace(\"{version}\", f\"{random.randint(1,5)}.{random.randint(0,9)}.{random.randint(0,9)}\")\n\n            # Determine timestamp\n            timestamp = random_datetime(datetime(2024, 1, 1), datetime(2024, 3, 21))\n\n            # Determine read status (older = more likely to be read)\n            days_old = (datetime(2024, 3, 21) - timestamp).days\n            read_probability = min(0.9, days_old / 30)  # Older than 30 days = 90% read\n            read = random.random() &lt; read_probability\n\n            # Create read timestamp if read\n            read_timestamp = None\n            if read:\n                read_timestamp = timestamp + timedelta(minutes=random.randint(1, 1440))  # 1 min to 1 day later\n\n            notification = {\n                \"id\": generate_uuid(),\n                \"user_id\": user[\"id\"],\n                \"title\": title,\n                \"message\": message,\n                \"type\": notification_type,\n                \"priority\": priority,\n                \"source\": source,\n                \"source_id\": source_id,\n                \"read\": read,\n                \"timestamp\": timestamp,\n                \"read_timestamp\": read_timestamp\n            }\n\n            notifications.append(notification)\n            notification_collection.insert_one(notification)\n\n    print(f\"Created {len(notifications)} notifications\")\n    return notifications\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_profiles","title":"<code>app.seeds.seed_database.create_profiles(users)</code>","text":"<p>Create user profiles for existing users.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_profiles(users: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create user profiles for existing users.\"\"\"\n    profiles = []\n    temperature_units = [\"C\", \"F\"]\n\n    for user in users:\n        first_name = fake.first_name()\n        last_name = fake.last_name()\n\n        # 70% chance to use display name\n        display_name = None\n        if random.random() &gt; 0.3:\n            display_names = [\n                f\"{first_name}\", \n                f\"{first_name} {last_name}\", \n                f\"{first_name[0]}{last_name}\", \n                f\"{first_name}_{random.randint(1, 100)}\"\n            ]\n            display_name = random.choice(display_names)\n\n        # 60% chance to have avatar\n        avatar = None\n        if random.random() &gt; 0.4:\n            avatar = f\"https://example.com/avatars/{user['id']}.jpg\"\n\n        # 80% chance to have phone number\n        phone_number = None\n        if random.random() &gt; 0.2:\n            phone_number = fake.phone_number()\n\n        # Select timezone from common options\n        timezones = [\n            \"UTC\", \"America/New_York\", \"America/Chicago\", \"America/Denver\", \n            \"America/Los_Angeles\", \"Europe/London\", \"Europe/Paris\", \"Asia/Tokyo\",\n            \"Australia/Sydney\", \"Pacific/Auckland\"\n        ]\n\n        profile = {\n            \"id\": generate_uuid(),\n            \"user_id\": user[\"id\"],\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"display_name\": display_name,\n            \"avatar\": avatar,\n            \"phone_number\": phone_number,\n            \"timezone\": random.choice(timezones),\n            \"temperature_unit\": random.choice(temperature_units),\n            \"dark_mode\": random.random() &gt; 0.5,  # 50% use dark mode\n            \"favorite_devices\": [],  # Will be populated later\n            \"created\": user[\"created\"],\n            \"updated\": user[\"updated\"]\n        }\n\n        profiles.append(profile)\n        profile_collection.insert_one(profile)\n\n    print(f\"Created {len(profiles)} profiles\")\n    return profiles\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_rooms","title":"<code>app.seeds.seed_database.create_rooms(homes)</code>","text":"<p>Create rooms for each home.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_rooms(homes: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create rooms for each home.\"\"\"\n    rooms = []\n\n    for home in homes:\n        # Determine number of rooms based on home type\n        if \"Main\" in home[\"name\"]:\n            num_rooms = random.randint(5, 10)\n        elif any(keyword in home[\"name\"] for keyword in [\"Vacation\", \"Beach\", \"Cabin\", \"Lake\"]):\n            num_rooms = random.randint(3, 7)\n        else:\n            num_rooms = random.randint(2, 5)\n\n        # Select random room types without duplicates\n        selected_room_types = random.sample(ROOM_TYPES, min(num_rooms, len(ROOM_TYPES)))\n\n        # If we need more rooms than unique types, add some numbered bedrooms or generic rooms\n        if num_rooms &gt; len(selected_room_types):\n            extra_rooms = [\"Bedroom \" + str(i) for i in range(2, num_rooms - len(selected_room_types) + 2)]\n            selected_room_types.extend(extra_rooms)\n\n        for room_type in selected_room_types:\n            floor = 1\n            if room_type in [\"Basement\", \"Garage\"]:\n                floor = 0\n            elif room_type in [\"Attic\", \"Guest Room\", \"Bedroom 2\", \"Bedroom 3\"]:\n                floor = 2\n\n            room = {\n                \"id\": generate_uuid(),\n                \"user_id\": home[\"user_id\"],\n                \"home_id\": home[\"id\"],\n                \"name\": room_type,\n                \"description\": f\"{room_type} in {home['name']}\",\n                \"type\": room_type.lower().replace(\" \", \"_\"),\n                \"floor\": floor,\n                \"devices\": [],  # Will be populated later\n                \"created\": home[\"created\"],\n                \"updated\": None,\n                \"active\": True\n            }\n\n            # Some rooms have been updated\n            if random.random() &gt; 0.7:\n                room[\"updated\"] = random_date(home[\"created\"], datetime(2024, 3, 21))\n\n            rooms.append(room)\n            room_collection.insert_one(room)\n\n    print(f\"Created {len(rooms)} rooms\")\n    return rooms\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_suggestions","title":"<code>app.seeds.seed_database.create_suggestions(users, devices)</code>","text":"<p>Create suggestions for users to improve their smart home.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_suggestions(users: List[Dict[str, Any]], devices: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create suggestions for users to improve their smart home.\"\"\"\n    suggestions = []\n\n    # Suggestion templates by type\n    suggestion_templates = {\n        \"energy_saving\": [\n            {\"title\": \"Optimize Thermostat Schedule\", \n             \"description\": \"Based on your usage patterns, adjusting your thermostat schedule could save up to 15% on heating and cooling costs. We suggest lowering temperatures at night and when you're away from home.\"},\n            {\"title\": \"Replace High-Energy Light Bulbs\", \n             \"description\": \"Some of your lights are using older technology. Replacing them with LED bulbs could reduce lighting energy consumption by up to 80%.\"},\n            {\"title\": \"Smart Power Strip for Entertainment Center\", \n             \"description\": \"Your entertainment devices are drawing standby power. Using a smart power strip could eliminate this vampire power and save up to $100 annually.\"},\n            {\"title\": \"Install Motion Sensors for Lights\", \n             \"description\": \"We've noticed lights staying on in unoccupied rooms. Adding motion sensors could reduce wasted electricity by automatically turning off lights when rooms are empty.\"},\n            {\"title\": \"Schedule Device Power Down\", \n             \"description\": \"Creating a nighttime automation to power down non-essential devices could reduce your overnight energy consumption by up to 12%.\"}\n        ],\n        \"security\": [\n            {\"title\": \"Add Entry Sensors to Windows\", \n             \"description\": \"Your home security could be improved by adding entry sensors to ground-floor windows. This would alert you immediately if a window is opened unexpectedly.\"},\n            {\"title\": \"Improve Door Lock Security\", \n             \"description\": \"Your front door lock doesn't have auto-lock enabled. We recommend enabling this feature to ensure your door locks automatically after being unlocked.\"},\n            {\"title\": \"Set Up Camera Motion Zones\", \n             \"description\": \"Your security cameras could be more effective by setting up specific motion zones to reduce false alerts and focus on important areas.\"},\n            {\"title\": \"Create Lighting Schedules When Away\", \n             \"description\": \"Setting up randomized lighting schedules when you're away can deter potential intruders by simulating occupancy.\"},\n            {\"title\": \"Enable Two-Factor Authentication\", \n             \"description\": \"For improved account security, enable two-factor authentication for your smart home system access.\"}\n        ],\n        \"comfort\": [\n            {\"title\": \"Optimize Temperature for Better Sleep\", \n             \"description\": \"Research shows sleeping in slightly cooler temperatures improves sleep quality. We suggest setting your bedroom to 65-68\u00b0F (18-20\u00b0C) overnight.\"},\n            {\"title\": \"Create Morning Routine Automation\", \n             \"description\": \"Start your day right with a morning routine that gradually turns on lights, adjusts the thermostat, and plays your favorite music at wake-up time.\"},\n            {\"title\": \"Add Humidity Control to Bedrooms\", \n             \"description\": \"The humidity levels in your bedrooms fluctuate outside the ideal 40-60% range. A smart humidifier could improve air quality and comfort.\"},\n            {\"title\": \"Set Up Optimal Lighting Scenes\", \n             \"description\": \"Creating preset lighting scenes for different activities (reading, movie watching, dinner) can enhance mood and comfort in your living spaces.\"},\n            {\"title\": \"Automate Blinds for Natural Light\", \n             \"description\": \"Adding smart blinds that automatically adjust based on time of day and sunlight can optimize natural light while maintaining privacy.\"}\n        ],\n        \"automation\": [\n            {\"title\": \"Create Arriving/Leaving Home Routines\", \n             \"description\": \"Set up geofencing to automatically adjust your home when you arrive or leave - turning on/off lights, adjusting temperature, and securing doors.\"},\n            {\"title\": \"Link Weather to Home Behavior\", \n             \"description\": \"Connect your system to weather forecasts to automatically close blinds during hot days or adjust heating before cold fronts arrive.\"},\n            {\"title\": \"Set Up Night Mode Routine\", \n             \"description\": \"Create a bedtime routine that secures your home, dims lights, and creates the optimal sleeping environment with a single command.\"},\n            {\"title\": \"Voice Command Shortcuts\", \n             \"description\": \"We've identified common device combinations you use. Setting up custom voice commands could make controlling these groups more convenient.\"},\n            {\"title\": \"Automate Based on Occupancy\", \n             \"description\": \"Using your motion sensors to automatically control lights and climate based on which rooms are occupied could improve convenience and efficiency.\"}\n        ]\n    }\n\n    for user in users:\n        # 70% chance user has suggestions\n        if random.random() &gt; 0.3:\n            # Get user's devices\n            user_devices = [d for d in devices if d[\"user_id\"] == user[\"id\"]]\n            if not user_devices:\n                continue\n\n            # Determine number of suggestions (2-10)\n            num_suggestions = random.randint(2, 10)\n\n            for _ in range(num_suggestions):\n                # Choose suggestion type\n                suggestion_type = random.choice(list(suggestion_templates.keys()))\n\n                # Choose template\n                template = random.choice(suggestion_templates[suggestion_type])\n\n                # Determine priority\n                priority = random.randint(1, 5)\n\n                # Determine related devices\n                related_device_ids = None\n                if random.random() &gt; 0.3:  # 70% have related devices\n                    num_related = random.randint(1, min(3, len(user_devices)))\n                    related_device_ids = [d[\"id\"] for d in random.sample(user_devices, num_related)]\n\n                # Determine status\n                status_weights = [0.4, 0.3, 0.2, 0.1]  # pending, accepted, rejected, implemented\n                status = random.choices([\"pending\", \"accepted\", \"rejected\", \"implemented\"], weights=status_weights)[0]\n\n                # Create timestamps\n                created = random_date(datetime(2024, 1, 1), datetime(2024, 3, 15))\n                updated = None\n                implemented_date = None\n                user_feedback = None\n\n                # If not pending, add update info\n                if status != \"pending\":\n                    updated = created + timedelta(days=random.randint(1, 14))\n\n                    if status == \"implemented\":\n                        implemented_date = updated + timedelta(days=random.randint(1, 7))\n\n                    if random.random() &gt; 0.5:  # 50% chance of feedback\n                        if status == \"accepted\" or status == \"implemented\":\n                            feedback_options = [\n                                \"Great suggestion, I'll try this.\",\n                                \"This is exactly what I needed.\",\n                                \"Thanks for the recommendation!\",\n                                \"I've been looking for something like this.\"\n                            ]\n                        else:  # rejected\n                            feedback_options = [\n                                \"Not interested in this right now.\",\n                                \"I've tried this before and it didn't work for me.\",\n                                \"Maybe later, but not a priority.\",\n                                \"I prefer my current setup.\"\n                            ]\n                        user_feedback = random.choice(feedback_options)\n\n                suggestion = {\n                    \"id\": generate_uuid(),\n                    \"user_id\": user[\"id\"],\n                    \"title\": template[\"title\"],\n                    \"description\": template[\"description\"],\n                    \"type\": suggestion_type,\n                    \"priority\": priority,\n                    \"status\": status,\n                    \"related_device_ids\": related_device_ids,\n                    \"created\": created,\n                    \"updated\": updated,\n                    \"implemented_date\": implemented_date,\n                    \"user_feedback\": user_feedback\n                }\n\n                suggestions.append(suggestion)\n                suggestion_collection.insert_one(suggestion)\n\n    print(f\"Created {len(suggestions)} suggestions\")\n    return suggestions\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_usage_data","title":"<code>app.seeds.seed_database.create_usage_data(devices)</code>","text":"<p>Create usage data for devices.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_usage_data(devices: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create usage data for devices.\"\"\"\n    usages = []\n\n    for device in devices:\n        # Skip offline devices\n        if device[\"status\"] == \"offline\":\n            continue\n\n        # Number of usage records based on device age (1-50 records)\n        days_since_creation = (datetime(2024, 3, 21) - device[\"created\"]).days\n        num_records = min(50, max(1, int(days_since_creation / 7) + random.randint(1, 5)))\n\n        for _ in range(num_records):\n            # Generate timestamp within device's lifetime\n            timestamp = random_datetime(device[\"created\"], datetime(2024, 3, 21))\n\n            # Generate metrics based on device type\n            metrics = {}\n            duration = None\n            energy_consumed = None\n\n            if device[\"type\"] == \"light\":\n                duration = random.randint(5, 480)  # 5 mins to 8 hours\n                energy_consumed = round(random.uniform(0.01, 0.5), 3)  # kWh\n                metrics = {\n                    \"brightness\": random.randint(10, 100),\n                    \"on_time\": duration,\n                    \"state_changes\": random.randint(1, 10)\n                }\n            elif device[\"type\"] == \"thermostat\":\n                duration = random.randint(30, 1440)  # 30 mins to 24 hours\n                energy_consumed = round(random.uniform(0.5, 5), 2)  # kWh\n                metrics = {\n                    \"ambient_temp\": round(random.uniform(17, 28), 1),\n                    \"target_temp\": round(random.uniform(19, 25), 1),\n                    \"heating_time\": random.randint(0, duration // 2) if random.random() &gt; 0.5 else 0,\n                    \"cooling_time\": random.randint(0, duration // 2) if random.random() &gt; 0.5 else 0\n                }\n            elif device[\"type\"] == \"lock\":\n                duration = random.randint(1, 5)  # 1-5 minutes\n                metrics = {\n                    \"locked\": random.random() &gt; 0.3,\n                    \"unlock_count\": random.randint(0, 10),\n                    \"lock_count\": random.randint(0, 10),\n                    \"auto_lock_triggered\": random.random() &gt; 0.7\n                }\n            elif device[\"type\"] == \"outlet\":\n                duration = random.randint(30, 1440)  # 30 mins to 24 hours\n                energy_consumed = round(random.uniform(0.1, 10), 2)  # kWh\n                metrics = {\n                    \"power_draw\": round(random.uniform(1, 2000), 1),  # watts\n                    \"voltage\": round(random.uniform(110, 120), 1),\n                    \"current\": round(random.uniform(0.1, 15), 2)\n                }\n            else:\n                duration = random.randint(10, 240)  # 10 mins to 4 hours\n                if random.random() &gt; 0.7:  # 30% chance for energy data\n                    energy_consumed = round(random.uniform(0.05, 2), 2)  # kWh\n                metrics = {\n                    \"usage_minutes\": duration,\n                    \"interactions\": random.randint(1, 20)\n                }\n\n            usage = {\n                \"id\": generate_uuid(),\n                \"device_id\": device[\"id\"],\n                \"metrics\": metrics,\n                \"timestamp\": timestamp,\n                \"duration\": duration,\n                \"energy_consumed\": energy_consumed,\n                \"status\": \"active\" if random.random() &gt; 0.1 else \"idle\",\n                \"created\": timestamp,\n                \"updated\": None\n            }\n\n            usages.append(usage)\n            usage_collection.insert_one(usage)\n\n    print(f\"Created {len(usages)} usage records\")\n    return usages\n</code></pre>"},{"location":"api/#app.seeds.seed_database.create_users","title":"<code>app.seeds.seed_database.create_users(count=25)</code>","text":"<p>Create realistic user data.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def create_users(count: int = 25) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create realistic user data.\"\"\"\n    users = []\n    for _ in range(count):\n        first_name = fake.first_name()\n        last_name = fake.last_name()\n        username = f\"{first_name.lower()}.{last_name.lower()}{random.randint(1, 999)}\"\n        email = f\"{username}@{fake.domain_name()}\"\n\n        # Create a strong password that meets requirements\n        password = fake.password(length=12) + \"A1!\"\n\n        user_id = generate_uuid()\n        user = {\n            \"id\": user_id,\n            \"username\": username,\n            \"email\": email,\n            \"hashed_password\": hash_password(password),\n            \"active\": True,\n            \"verified\": random.random() &gt; 0.1,  # 90% are verified\n            \"created\": random_date(datetime(2023, 1, 1), datetime(2023, 12, 31)),\n            \"updated\": None,\n            \"role\": random.choices([\"admin\", \"user\"], weights=[0.2, 0.8])[0]\n        }\n\n        # Add random updated date for some users\n        if random.random() &gt; 0.7:\n            user[\"updated\"] = random_date(user[\"created\"], datetime(2024, 3, 21))\n\n        users.append(user)\n        user_collection.insert_one(user)\n\n    print(f\"Created {len(users)} users\")\n    return users\n</code></pre>"},{"location":"api/#app.seeds.seed_database.generate_uuid","title":"<code>app.seeds.seed_database.generate_uuid()</code>","text":"<p>Generate a UUID string.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def generate_uuid() -&gt; str:\n    \"\"\"Generate a UUID string.\"\"\"\n    return str(uuid.uuid4())\n</code></pre>"},{"location":"api/#app.seeds.seed_database.hash_password","title":"<code>app.seeds.seed_database.hash_password(password)</code>","text":"<p>Create a hashed password.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def hash_password(password: str) -&gt; str:\n    \"\"\"Create a hashed password.\"\"\"\n    return hashlib.sha256(password.encode()).hexdigest()\n</code></pre>"},{"location":"api/#app.seeds.seed_database.random_date","title":"<code>app.seeds.seed_database.random_date(start_date, end_date)</code>","text":"<p>Generate a random date between start_date and end_date.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def random_date(start_date: datetime, end_date: datetime) -&gt; datetime:\n    \"\"\"Generate a random date between start_date and end_date.\"\"\"\n    if start_date &gt;= end_date:\n        return start_date  # Return start_date if range is invalid\n    delta = end_date - start_date\n    random_days = random.randrange(delta.days + 1)  # Add 1 to include end_date\n    return start_date + timedelta(days=random_days)\n</code></pre>"},{"location":"api/#app.seeds.seed_database.random_datetime","title":"<code>app.seeds.seed_database.random_datetime(start_date, end_date)</code>","text":"<p>Generate a random datetime between start_date and end_date.</p> Source code in <code>app/seeds/seed_database.py</code> <pre><code>def random_datetime(start_date: datetime, end_date: datetime) -&gt; datetime:\n    \"\"\"Generate a random datetime between start_date and end_date.\"\"\"\n    if start_date &gt;= end_date:\n        return start_date  # Return start_date if range is invalid\n    delta = end_date - start_date\n    random_seconds = random.randrange(int(delta.total_seconds()) + 1)  # Add 1 to include end_date\n    return start_date + timedelta(seconds=random_seconds)\n</code></pre>"},{"location":"api/#app.services.report_service","title":"<code>app.services.report_service</code>","text":"<p>Service for energy report generation and management.</p>"},{"location":"api/#app.services.report_service.ReportService","title":"<code>app.services.report_service.ReportService</code>","text":"<p>Service for managing energy report generation and storage.</p> Source code in <code>app/services/report_service.py</code> <pre><code>class ReportService:\n    \"\"\"\n    Service for managing energy report generation and storage.\n    \"\"\"\n\n    @staticmethod\n    def create_report(report_data: ReportDB) -&gt; str:\n        \"\"\"\n        Create a report record in the database.\n\n        Args:\n            report_data: Report data to store\n\n        Returns:\n            str: ID of the created report\n        \"\"\"\n        report_dict = report_data.model_dump()\n        result = r_c.insert_one(report_dict)\n        return str(result.inserted_id)\n\n    @staticmethod\n    def get_report(report_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve a report by ID.\n\n        Args:\n            report_id: ID of the report to retrieve\n\n        Returns:\n            Optional[Dict]: Report data if found, None otherwise\n        \"\"\"\n        report = r_c.find_one({\"id\": report_id})\n        return report\n\n    @staticmethod\n    def get_user_reports(user_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Retrieve all reports for a user.\n\n        Args:\n            user_id: ID of the user\n\n        Returns:\n            List[Dict]: List of report data\n        \"\"\"\n        cursor = r_c.find({\"user_id\": user_id}).sort(\"created\", -1)\n        reports = list(cursor)  # Convert cursor to list\n        return reports\n\n    @staticmethod\n    def update_report_status(report_id: str, status: ReportStatus, **kwargs) -&gt; bool:\n        \"\"\"\n        Update the status of a report.\n\n        Args:\n            report_id: ID of the report to update\n            status: New status\n            **kwargs: Additional fields to update\n\n        Returns:\n            bool: True if update was successful, False otherwise\n        \"\"\"\n        update_data = {\"status\": status, \"updated\": datetime.utcnow()}\n        update_data.update(kwargs)\n\n        result = r_c.update_one(\n            {\"id\": report_id},\n            {\"$set\": update_data}\n        )\n\n        return result.modified_count &gt; 0\n\n    @staticmethod\n    def fetch_energy_data(\n        user_id: str,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        device_ids: Optional[List[str]] = None\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Fetch energy usage data from the database.\n\n        Args:\n            user_id: ID of the user\n            start_date: Start date in YYYY-MM-DD format\n            end_date: End date in YYYY-MM-DD format\n            device_ids: List of device IDs to filter by\n\n        Returns:\n            List[Dict]: List of energy usage records\n        \"\"\"\n        # Convert string dates to datetime objects if provided\n        start_datetime = None\n        end_datetime = None\n\n        if start_date:\n            start_datetime = datetime.strptime(start_date, \"%Y-%m-%d\")\n\n        if end_date:\n            # Set end_datetime to the end of the day\n            end_datetime = datetime.strptime(end_date, \"%Y-%m-%d\")\n            end_datetime = end_datetime.replace(hour=23, minute=59, second=59)\n\n        # Build the query\n        query = {}\n\n        # Get all devices owned by the user\n        if device_ids:\n            query[\"device_id\"] = {\"$in\": device_ids}\n        else:\n            # If no specific devices are requested, get all devices for the user\n            user_devices = list(d_c.find({\"user_id\": user_id}))\n            if not user_devices:\n                return []  # User has no devices, return empty list\n\n            user_device_ids = [device[\"id\"] for device in user_devices]\n\n            if user_device_ids:\n                query[\"device_id\"] = {\"$in\": user_device_ids}\n            else:\n                # If user has no devices, return empty list\n                return []\n\n        # Add date range filter if provided\n        if start_datetime or end_datetime:\n            timestamp_query = {}\n            if start_datetime:\n                timestamp_query[\"$gte\"] = start_datetime\n            if end_datetime:\n                timestamp_query[\"$lte\"] = end_datetime\n\n            if timestamp_query:\n                query[\"timestamp\"] = timestamp_query\n\n        # Execute the query\n        print(f\"Query: {query}\")\n        cursor = us_c.find(query).sort(\"timestamp\", 1)\n        print(f\"Cursor type: {type(cursor)}\")\n        usage_data = list(cursor)  # Convert cursor to list\n        print(f\"Usage data type: {type(usage_data)}, length: {len(usage_data)}\")\n\n        # Enhance usage data with device information\n        enhanced_data = []\n        for record in usage_data:\n            # Get device info\n            device_id = record.get(\"device_id\")\n            device = d_c.find_one({\"id\": device_id})\n\n            # Create enhanced record with location\n            enhanced_record = {\n                \"timestamp\": record.get(\"timestamp\").isoformat() if isinstance(record.get(\"timestamp\"), datetime) else record.get(\"timestamp\"),\n                \"device_id\": device_id,\n                \"energy_consumed\": record.get(\"energy_consumed\", 0),\n                \"location\": device.get(\"room_id\") if device else \"Unknown\"\n            }\n\n            enhanced_data.append(enhanced_record)\n\n        return enhanced_data\n\n    @staticmethod\n    def fetch_user_data(user_id: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetch user data for report personalization.\n\n        Args:\n            user_id: ID of the user\n\n        Returns:\n            Dict: User data\n        \"\"\"\n        user = u_c.find_one({\"id\": user_id})\n\n        if not user:\n            return {}\n\n        return {\n            \"email\": user.get(\"email\"),\n            \"username\": user.get(\"username\")\n        }\n\n    @staticmethod\n    def generate_report(report_id: str) -&gt; Tuple[bool, Optional[str], Optional[str]]:\n        \"\"\"\n        Generate a report based on its ID.\n\n        Args:\n            report_id: ID of the report to generate\n\n        Returns:\n            Tuple[bool, Optional[str], Optional[str]]: \n                - Success flag\n                - File path if successful\n                - Error message if failed\n        \"\"\"\n        # Get report data\n        report_data = ReportService.get_report(report_id)\n        if not report_data:\n            return False, None, \"Report not found\"\n\n        try:\n            # Update status to generating\n            ReportService.update_report_status(\n                report_id, \n                ReportStatus.GENERATING\n            )\n\n            # Fetch energy data\n            energy_data = ReportService.fetch_energy_data(\n                user_id=report_data[\"user_id\"],\n                start_date=report_data.get(\"start_date\"),\n                end_date=report_data.get(\"end_date\"),\n                device_ids=report_data.get(\"device_ids\")\n            )\n\n            if not energy_data:\n                error_msg = \"No energy data found for the specified criteria\"\n                ReportService.update_report_status(\n                    report_id, \n                    ReportStatus.FAILED,\n                    error_message=error_msg\n                )\n                return False, None, error_msg\n\n            # Fetch user data for personalization\n            user_data = ReportService.fetch_user_data(report_data[\"user_id\"])\n\n            # Generate the report\n            report_path = generate_energy_report(\n                energy_data=energy_data,\n                user_data=user_data,\n                format=report_data[\"format\"].lower(),\n                start_date=report_data.get(\"start_date\"),\n                end_date=report_data.get(\"end_date\")\n            )\n\n            # Calculate some basic stats for metadata\n            total_energy = sum(record.get(\"energy_consumed\", 0) for record in energy_data)\n            device_count = len(set(record.get(\"device_id\") for record in energy_data))\n\n            # Update the report record with success status\n            ReportService.update_report_status(\n                report_id,\n                ReportStatus.COMPLETED,\n                file_path=report_path,\n                completed=datetime.utcnow(),\n                metadata={\n                    \"total_energy\": total_energy,\n                    \"record_count\": len(energy_data),\n                    \"device_count\": device_count,\n                    \"file_size\": os.path.getsize(report_path) if os.path.exists(report_path) else 0\n                }\n            )\n\n            return True, report_path, None\n\n        except Exception as e:\n            # Update the report record with failure status\n            error_message = str(e)\n            ReportService.update_report_status(\n                report_id,\n                ReportStatus.FAILED,\n                error_message=error_message\n            )\n\n            return False, None, error_message\n\n    @staticmethod\n    def delete_report(report_id: str) -&gt; bool:\n        \"\"\"\n        Delete a report record from the database.\n\n        Args:\n            report_id: ID of the report to delete\n\n        Returns:\n            bool: True if deletion was successful, False otherwise\n        \"\"\"\n        result = r_c.delete_one({\"id\": report_id})\n        return result.deleted_count &gt; 0\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.create_report","title":"<code>app.services.report_service.ReportService.create_report(report_data)</code>  <code>staticmethod</code>","text":"<p>Create a report record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>report_data</code> <code>ReportDB</code> <p>Report data to store</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ID of the created report</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef create_report(report_data: ReportDB) -&gt; str:\n    \"\"\"\n    Create a report record in the database.\n\n    Args:\n        report_data: Report data to store\n\n    Returns:\n        str: ID of the created report\n    \"\"\"\n    report_dict = report_data.model_dump()\n    result = r_c.insert_one(report_dict)\n    return str(result.inserted_id)\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.delete_report","title":"<code>app.services.report_service.ReportService.delete_report(report_id)</code>  <code>staticmethod</code>","text":"<p>Delete a report record from the database.</p> <p>Parameters:</p> Name Type Description Default <code>report_id</code> <code>str</code> <p>ID of the report to delete</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion was successful, False otherwise</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef delete_report(report_id: str) -&gt; bool:\n    \"\"\"\n    Delete a report record from the database.\n\n    Args:\n        report_id: ID of the report to delete\n\n    Returns:\n        bool: True if deletion was successful, False otherwise\n    \"\"\"\n    result = r_c.delete_one({\"id\": report_id})\n    return result.deleted_count &gt; 0\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.fetch_energy_data","title":"<code>app.services.report_service.ReportService.fetch_energy_data(user_id, start_date=None, end_date=None, device_ids=None)</code>  <code>staticmethod</code>","text":"<p>Fetch energy usage data from the database.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>ID of the user</p> required <code>start_date</code> <code>Optional[str]</code> <p>Start date in YYYY-MM-DD format</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>End date in YYYY-MM-DD format</p> <code>None</code> <code>device_ids</code> <code>Optional[List[str]]</code> <p>List of device IDs to filter by</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict]: List of energy usage records</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef fetch_energy_data(\n    user_id: str,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    device_ids: Optional[List[str]] = None\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Fetch energy usage data from the database.\n\n    Args:\n        user_id: ID of the user\n        start_date: Start date in YYYY-MM-DD format\n        end_date: End date in YYYY-MM-DD format\n        device_ids: List of device IDs to filter by\n\n    Returns:\n        List[Dict]: List of energy usage records\n    \"\"\"\n    # Convert string dates to datetime objects if provided\n    start_datetime = None\n    end_datetime = None\n\n    if start_date:\n        start_datetime = datetime.strptime(start_date, \"%Y-%m-%d\")\n\n    if end_date:\n        # Set end_datetime to the end of the day\n        end_datetime = datetime.strptime(end_date, \"%Y-%m-%d\")\n        end_datetime = end_datetime.replace(hour=23, minute=59, second=59)\n\n    # Build the query\n    query = {}\n\n    # Get all devices owned by the user\n    if device_ids:\n        query[\"device_id\"] = {\"$in\": device_ids}\n    else:\n        # If no specific devices are requested, get all devices for the user\n        user_devices = list(d_c.find({\"user_id\": user_id}))\n        if not user_devices:\n            return []  # User has no devices, return empty list\n\n        user_device_ids = [device[\"id\"] for device in user_devices]\n\n        if user_device_ids:\n            query[\"device_id\"] = {\"$in\": user_device_ids}\n        else:\n            # If user has no devices, return empty list\n            return []\n\n    # Add date range filter if provided\n    if start_datetime or end_datetime:\n        timestamp_query = {}\n        if start_datetime:\n            timestamp_query[\"$gte\"] = start_datetime\n        if end_datetime:\n            timestamp_query[\"$lte\"] = end_datetime\n\n        if timestamp_query:\n            query[\"timestamp\"] = timestamp_query\n\n    # Execute the query\n    print(f\"Query: {query}\")\n    cursor = us_c.find(query).sort(\"timestamp\", 1)\n    print(f\"Cursor type: {type(cursor)}\")\n    usage_data = list(cursor)  # Convert cursor to list\n    print(f\"Usage data type: {type(usage_data)}, length: {len(usage_data)}\")\n\n    # Enhance usage data with device information\n    enhanced_data = []\n    for record in usage_data:\n        # Get device info\n        device_id = record.get(\"device_id\")\n        device = d_c.find_one({\"id\": device_id})\n\n        # Create enhanced record with location\n        enhanced_record = {\n            \"timestamp\": record.get(\"timestamp\").isoformat() if isinstance(record.get(\"timestamp\"), datetime) else record.get(\"timestamp\"),\n            \"device_id\": device_id,\n            \"energy_consumed\": record.get(\"energy_consumed\", 0),\n            \"location\": device.get(\"room_id\") if device else \"Unknown\"\n        }\n\n        enhanced_data.append(enhanced_record)\n\n    return enhanced_data\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.fetch_user_data","title":"<code>app.services.report_service.ReportService.fetch_user_data(user_id)</code>  <code>staticmethod</code>","text":"<p>Fetch user data for report personalization.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>ID of the user</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict[str, Any]</code> <p>User data</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef fetch_user_data(user_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetch user data for report personalization.\n\n    Args:\n        user_id: ID of the user\n\n    Returns:\n        Dict: User data\n    \"\"\"\n    user = u_c.find_one({\"id\": user_id})\n\n    if not user:\n        return {}\n\n    return {\n        \"email\": user.get(\"email\"),\n        \"username\": user.get(\"username\")\n    }\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.generate_report","title":"<code>app.services.report_service.ReportService.generate_report(report_id)</code>  <code>staticmethod</code>","text":"<p>Generate a report based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>report_id</code> <code>str</code> <p>ID of the report to generate</p> required <p>Returns:</p> Type Description <code>Tuple[bool, Optional[str], Optional[str]]</code> <p>Tuple[bool, Optional[str], Optional[str]]:  - Success flag - File path if successful - Error message if failed</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef generate_report(report_id: str) -&gt; Tuple[bool, Optional[str], Optional[str]]:\n    \"\"\"\n    Generate a report based on its ID.\n\n    Args:\n        report_id: ID of the report to generate\n\n    Returns:\n        Tuple[bool, Optional[str], Optional[str]]: \n            - Success flag\n            - File path if successful\n            - Error message if failed\n    \"\"\"\n    # Get report data\n    report_data = ReportService.get_report(report_id)\n    if not report_data:\n        return False, None, \"Report not found\"\n\n    try:\n        # Update status to generating\n        ReportService.update_report_status(\n            report_id, \n            ReportStatus.GENERATING\n        )\n\n        # Fetch energy data\n        energy_data = ReportService.fetch_energy_data(\n            user_id=report_data[\"user_id\"],\n            start_date=report_data.get(\"start_date\"),\n            end_date=report_data.get(\"end_date\"),\n            device_ids=report_data.get(\"device_ids\")\n        )\n\n        if not energy_data:\n            error_msg = \"No energy data found for the specified criteria\"\n            ReportService.update_report_status(\n                report_id, \n                ReportStatus.FAILED,\n                error_message=error_msg\n            )\n            return False, None, error_msg\n\n        # Fetch user data for personalization\n        user_data = ReportService.fetch_user_data(report_data[\"user_id\"])\n\n        # Generate the report\n        report_path = generate_energy_report(\n            energy_data=energy_data,\n            user_data=user_data,\n            format=report_data[\"format\"].lower(),\n            start_date=report_data.get(\"start_date\"),\n            end_date=report_data.get(\"end_date\")\n        )\n\n        # Calculate some basic stats for metadata\n        total_energy = sum(record.get(\"energy_consumed\", 0) for record in energy_data)\n        device_count = len(set(record.get(\"device_id\") for record in energy_data))\n\n        # Update the report record with success status\n        ReportService.update_report_status(\n            report_id,\n            ReportStatus.COMPLETED,\n            file_path=report_path,\n            completed=datetime.utcnow(),\n            metadata={\n                \"total_energy\": total_energy,\n                \"record_count\": len(energy_data),\n                \"device_count\": device_count,\n                \"file_size\": os.path.getsize(report_path) if os.path.exists(report_path) else 0\n            }\n        )\n\n        return True, report_path, None\n\n    except Exception as e:\n        # Update the report record with failure status\n        error_message = str(e)\n        ReportService.update_report_status(\n            report_id,\n            ReportStatus.FAILED,\n            error_message=error_message\n        )\n\n        return False, None, error_message\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.get_report","title":"<code>app.services.report_service.ReportService.get_report(report_id)</code>  <code>staticmethod</code>","text":"<p>Retrieve a report by ID.</p> <p>Parameters:</p> Name Type Description Default <code>report_id</code> <code>str</code> <p>ID of the report to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict]: Report data if found, None otherwise</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef get_report(report_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve a report by ID.\n\n    Args:\n        report_id: ID of the report to retrieve\n\n    Returns:\n        Optional[Dict]: Report data if found, None otherwise\n    \"\"\"\n    report = r_c.find_one({\"id\": report_id})\n    return report\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.get_user_reports","title":"<code>app.services.report_service.ReportService.get_user_reports(user_id)</code>  <code>staticmethod</code>","text":"<p>Retrieve all reports for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>ID of the user</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict]: List of report data</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef get_user_reports(user_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Retrieve all reports for a user.\n\n    Args:\n        user_id: ID of the user\n\n    Returns:\n        List[Dict]: List of report data\n    \"\"\"\n    cursor = r_c.find({\"user_id\": user_id}).sort(\"created\", -1)\n    reports = list(cursor)  # Convert cursor to list\n    return reports\n</code></pre>"},{"location":"api/#app.services.report_service.ReportService.update_report_status","title":"<code>app.services.report_service.ReportService.update_report_status(report_id, status, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Update the status of a report.</p> <p>Parameters:</p> Name Type Description Default <code>report_id</code> <code>str</code> <p>ID of the report to update</p> required <code>status</code> <code>ReportStatus</code> <p>New status</p> required <code>**kwargs</code> <p>Additional fields to update</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update was successful, False otherwise</p> Source code in <code>app/services/report_service.py</code> <pre><code>@staticmethod\ndef update_report_status(report_id: str, status: ReportStatus, **kwargs) -&gt; bool:\n    \"\"\"\n    Update the status of a report.\n\n    Args:\n        report_id: ID of the report to update\n        status: New status\n        **kwargs: Additional fields to update\n\n    Returns:\n        bool: True if update was successful, False otherwise\n    \"\"\"\n    update_data = {\"status\": status, \"updated\": datetime.utcnow()}\n    update_data.update(kwargs)\n\n    result = r_c.update_one(\n        {\"id\": report_id},\n        {\"$set\": update_data}\n    )\n\n    return result.modified_count &gt; 0\n</code></pre>"},{"location":"api/#app.utils.report.anomaly_detector","title":"<code>app.utils.report.anomaly_detector</code>","text":"<p>This module provides functionality in detecting usage anomalies.</p>"},{"location":"api/#app.utils.report.anomaly_detector.EnergyAnomalyDetector","title":"<code>app.utils.report.anomaly_detector.EnergyAnomalyDetector</code>","text":"<p>Utility for detecting anomalies in energy consumption data in real-time</p> Source code in <code>app/utils/report/anomaly_detector.py</code> <pre><code>class EnergyAnomalyDetector:\n    \"\"\"\n    Utility for detecting anomalies in energy consumption data in real-time\n    \"\"\"\n\n    def __init__(self, history_days: int = 30, contamination: float = 0.05):\n        \"\"\"\n        Initialize the anomaly detector\n\n        Args:\n            history_days (int): Number of days of historical data to use\n            contamination (float): Expected proportion of anomalies (0.01 to 0.1)\n        \"\"\"\n        self.history_days = history_days\n        self.contamination = contamination\n        self.model = None\n        self.scaler = None\n        self.training_complete = False\n\n    def train(self, historical_data: List[Dict]) -&gt; bool:\n        \"\"\"\n        Train the anomaly detection model using historical data\n\n        Args:\n            historical_data (List[Dict]): Historical energy consumption records\n\n        Returns:\n            bool: True if training was successful, False otherwise\n        \"\"\"\n        if not historical_data:\n            return False\n\n        try:\n            # Convert to DataFrame\n            df = pd.DataFrame(historical_data)\n\n            # Ensure timestamp is a datetime\n            if 'timestamp' in df.columns:\n                df['timestamp'] = pd.to_datetime(df['timestamp'])\n            else:\n                return False\n\n            # Group by day and device to reduce noise\n            df['date'] = df['timestamp'].dt.date\n            daily_data = df.groupby(['date', 'device_id'])['energy_consumed'].sum().reset_index()\n\n            # Prepare features for anomaly detection\n            # For each device, calculate:\n            # 1. Daily consumption\n            # 2. 7-day rolling average\n            # 3. Day of week (to account for weekly patterns)\n\n            devices = daily_data['device_id'].unique()\n            processed_data = []\n\n            for device in devices:\n                device_data = daily_data[daily_data['device_id'] == device]\n                if len(device_data) &lt;= 7:  # Need enough data for rolling average\n                    continue\n\n                # FIX:\n                device_data = device_data.sort_values('date')\n                device_data['day_of_week'] = pd.to_datetime(device_data['date']).dt.dayofweek\n                device_data['rolling_avg_7d'] = device_data['energy_consumed'].rolling(7).mean()\n\n                # Skip the first 7 days (they won't have a complete 7-day average)\n                device_data = device_data.dropna()\n\n                processed_data.append(device_data)\n\n            if not processed_data:\n                return False\n\n            # Combine all devices\n            full_data = pd.concat(processed_data)\n\n            # Features for anomaly detection\n            features = full_data[['energy_consumed', 'rolling_avg_7d', 'day_of_week']]\n\n            # Standardize the features\n            self.scaler = StandardScaler()\n            scaled_features = self.scaler.fit_transform(features)\n\n            # Train the Isolation Forest model\n            self.model = IsolationForest(\n                # FIX:\n                contamination=self.contamination,\n                random_state=42,\n                n_estimators=100\n            )\n            self.model.fit(scaled_features)\n\n            self.training_complete = True\n            return True\n\n        except Exception as e:\n            print(f\"Error training anomaly detection model: {e}\")\n            return False\n\n    def detect_anomalies(self, new_data: List[Dict]) -&gt; List[Dict]:\n        \"\"\"\n        Detect anomalies in new energy consumption data\n\n        Args:\n            new_data (List[Dict]): New energy consumption records to analyze\n\n        Returns:\n            List[Dict]: Records flagged as anomalies with additional metadata\n        \"\"\"\n        if not self.training_complete or not new_data:\n            return []\n\n        try:\n            # Convert to DataFrame\n            df = pd.DataFrame(new_data)\n\n            # Ensure timestamp is a datetime\n            if 'timestamp' in df.columns:\n                df['timestamp'] = pd.to_datetime(df['timestamp'])\n            else:\n                return []\n\n            # Group by day and device to match training data format\n            df['date'] = df['timestamp'].dt.date\n            daily_data = df.groupby(['date', 'device_id'])['energy_consumed'].sum().reset_index()\n\n            # Prepare features for each device\n            devices = daily_data['device_id'].unique()\n            processed_data = []\n\n            for device in devices:\n                device_data = daily_data[daily_data['device_id'] == device].copy()\n                if len(device_data) == 0:\n                    continue\n\n                # Add day of week\n                device_data['day_of_week'] = pd.to_datetime(device_data['date']).dt.dayofweek\n\n                # We need historical data to compute rolling average\n                # For real-time detection, you would need to retrieve this from the database\n                # Here we'll use a placeholder value based on the average energy consumption\n                device_data['rolling_avg_7d'] = device_data['energy_consumed'].mean()\n\n                processed_data.append(device_data)\n\n            if not processed_data:\n                return []\n\n            # Combine all devices\n            full_data = pd.concat(processed_data)\n\n            # Original data for reference\n            original_data = full_data.copy()\n\n            # Features for anomaly detection\n            features = full_data[['energy_consumed', 'rolling_avg_7d', 'day_of_week']]\n\n            # Standardize the features\n            scaled_features = self.scaler.transform(features)\n\n            # Predict anomalies\n            # FIX:\n            predictions = self.model.predict(scaled_features)\n            scores = self.model.decision_function(scaled_features)\n\n            # Add predictions and scores back to the original data\n            original_data['anomaly'] = predictions\n            original_data['anomaly_score'] = scores\n\n            # Filter to only anomalies (prediction of -1 means anomaly)\n            anomalies = original_data[original_data['anomaly'] == -1]\n\n            # Convert back to dictionary format\n            anomaly_records = []\n            for _, row in anomalies.iterrows():\n                anomaly_records.append({\n                    'device_id': row['device_id'],\n                    # FIX:\n                    'date': row['date'].strftime('%Y-%m-%d'),\n                    'energy_consumed': float(row['energy_consumed']),\n                    'anomaly_score': float(row['anomaly_score']),\n                    'severity': 'high' if row['anomaly_score'] &lt; -0.5 else 'medium'\n                })\n\n            return anomaly_records\n\n        except Exception as e:\n            print(f\"Error detecting anomalies: {e}\")\n            return []\n\n    def get_anomaly_description(self, anomaly: Dict) -&gt; str:\n        \"\"\"\n        Generate a human-readable description of an anomaly\n\n        Args:\n            anomaly (Dict): An anomaly record\n\n        Returns:\n            str: Human-readable description\n        \"\"\"\n        device_id = anomaly.get('device_id', 'Unknown device')\n        date = anomaly.get('date', 'Unknown date')\n        energy = anomaly.get('energy_consumed', 0)\n        severity = anomaly.get('severity', 'medium')\n\n        if severity == 'high':\n            return f\"Unusually high energy consumption detected for {device_id} on {date}. \" \\\n                   f\"Consumption of {energy:.2f} kWh is significantly above normal levels.\"\n        else:\n            return f\"Abnormal energy consumption detected for {device_id} on {date}. \" \\\n                   f\"Consumption of {energy:.2f} kWh deviates from expected patterns.\"\n</code></pre>"},{"location":"api/#app.utils.report.anomaly_detector.EnergyAnomalyDetector.__init__","title":"<code>app.utils.report.anomaly_detector.EnergyAnomalyDetector.__init__(history_days=30, contamination=0.05)</code>","text":"<p>Initialize the anomaly detector</p> <p>Parameters:</p> Name Type Description Default <code>history_days</code> <code>int</code> <p>Number of days of historical data to use</p> <code>30</code> <code>contamination</code> <code>float</code> <p>Expected proportion of anomalies (0.01 to 0.1)</p> <code>0.05</code> Source code in <code>app/utils/report/anomaly_detector.py</code> <pre><code>def __init__(self, history_days: int = 30, contamination: float = 0.05):\n    \"\"\"\n    Initialize the anomaly detector\n\n    Args:\n        history_days (int): Number of days of historical data to use\n        contamination (float): Expected proportion of anomalies (0.01 to 0.1)\n    \"\"\"\n    self.history_days = history_days\n    self.contamination = contamination\n    self.model = None\n    self.scaler = None\n    self.training_complete = False\n</code></pre>"},{"location":"api/#app.utils.report.anomaly_detector.EnergyAnomalyDetector.detect_anomalies","title":"<code>app.utils.report.anomaly_detector.EnergyAnomalyDetector.detect_anomalies(new_data)</code>","text":"<p>Detect anomalies in new energy consumption data</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>List[Dict]</code> <p>New energy consumption records to analyze</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: Records flagged as anomalies with additional metadata</p> Source code in <code>app/utils/report/anomaly_detector.py</code> <pre><code>def detect_anomalies(self, new_data: List[Dict]) -&gt; List[Dict]:\n    \"\"\"\n    Detect anomalies in new energy consumption data\n\n    Args:\n        new_data (List[Dict]): New energy consumption records to analyze\n\n    Returns:\n        List[Dict]: Records flagged as anomalies with additional metadata\n    \"\"\"\n    if not self.training_complete or not new_data:\n        return []\n\n    try:\n        # Convert to DataFrame\n        df = pd.DataFrame(new_data)\n\n        # Ensure timestamp is a datetime\n        if 'timestamp' in df.columns:\n            df['timestamp'] = pd.to_datetime(df['timestamp'])\n        else:\n            return []\n\n        # Group by day and device to match training data format\n        df['date'] = df['timestamp'].dt.date\n        daily_data = df.groupby(['date', 'device_id'])['energy_consumed'].sum().reset_index()\n\n        # Prepare features for each device\n        devices = daily_data['device_id'].unique()\n        processed_data = []\n\n        for device in devices:\n            device_data = daily_data[daily_data['device_id'] == device].copy()\n            if len(device_data) == 0:\n                continue\n\n            # Add day of week\n            device_data['day_of_week'] = pd.to_datetime(device_data['date']).dt.dayofweek\n\n            # We need historical data to compute rolling average\n            # For real-time detection, you would need to retrieve this from the database\n            # Here we'll use a placeholder value based on the average energy consumption\n            device_data['rolling_avg_7d'] = device_data['energy_consumed'].mean()\n\n            processed_data.append(device_data)\n\n        if not processed_data:\n            return []\n\n        # Combine all devices\n        full_data = pd.concat(processed_data)\n\n        # Original data for reference\n        original_data = full_data.copy()\n\n        # Features for anomaly detection\n        features = full_data[['energy_consumed', 'rolling_avg_7d', 'day_of_week']]\n\n        # Standardize the features\n        scaled_features = self.scaler.transform(features)\n\n        # Predict anomalies\n        # FIX:\n        predictions = self.model.predict(scaled_features)\n        scores = self.model.decision_function(scaled_features)\n\n        # Add predictions and scores back to the original data\n        original_data['anomaly'] = predictions\n        original_data['anomaly_score'] = scores\n\n        # Filter to only anomalies (prediction of -1 means anomaly)\n        anomalies = original_data[original_data['anomaly'] == -1]\n\n        # Convert back to dictionary format\n        anomaly_records = []\n        for _, row in anomalies.iterrows():\n            anomaly_records.append({\n                'device_id': row['device_id'],\n                # FIX:\n                'date': row['date'].strftime('%Y-%m-%d'),\n                'energy_consumed': float(row['energy_consumed']),\n                'anomaly_score': float(row['anomaly_score']),\n                'severity': 'high' if row['anomaly_score'] &lt; -0.5 else 'medium'\n            })\n\n        return anomaly_records\n\n    except Exception as e:\n        print(f\"Error detecting anomalies: {e}\")\n        return []\n</code></pre>"},{"location":"api/#app.utils.report.anomaly_detector.EnergyAnomalyDetector.get_anomaly_description","title":"<code>app.utils.report.anomaly_detector.EnergyAnomalyDetector.get_anomaly_description(anomaly)</code>","text":"<p>Generate a human-readable description of an anomaly</p> <p>Parameters:</p> Name Type Description Default <code>anomaly</code> <code>Dict</code> <p>An anomaly record</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable description</p> Source code in <code>app/utils/report/anomaly_detector.py</code> <pre><code>def get_anomaly_description(self, anomaly: Dict) -&gt; str:\n    \"\"\"\n    Generate a human-readable description of an anomaly\n\n    Args:\n        anomaly (Dict): An anomaly record\n\n    Returns:\n        str: Human-readable description\n    \"\"\"\n    device_id = anomaly.get('device_id', 'Unknown device')\n    date = anomaly.get('date', 'Unknown date')\n    energy = anomaly.get('energy_consumed', 0)\n    severity = anomaly.get('severity', 'medium')\n\n    if severity == 'high':\n        return f\"Unusually high energy consumption detected for {device_id} on {date}. \" \\\n               f\"Consumption of {energy:.2f} kWh is significantly above normal levels.\"\n    else:\n        return f\"Abnormal energy consumption detected for {device_id} on {date}. \" \\\n               f\"Consumption of {energy:.2f} kWh deviates from expected patterns.\"\n</code></pre>"},{"location":"api/#app.utils.report.anomaly_detector.EnergyAnomalyDetector.train","title":"<code>app.utils.report.anomaly_detector.EnergyAnomalyDetector.train(historical_data)</code>","text":"<p>Train the anomaly detection model using historical data</p> <p>Parameters:</p> Name Type Description Default <code>historical_data</code> <code>List[Dict]</code> <p>Historical energy consumption records</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if training was successful, False otherwise</p> Source code in <code>app/utils/report/anomaly_detector.py</code> <pre><code>def train(self, historical_data: List[Dict]) -&gt; bool:\n    \"\"\"\n    Train the anomaly detection model using historical data\n\n    Args:\n        historical_data (List[Dict]): Historical energy consumption records\n\n    Returns:\n        bool: True if training was successful, False otherwise\n    \"\"\"\n    if not historical_data:\n        return False\n\n    try:\n        # Convert to DataFrame\n        df = pd.DataFrame(historical_data)\n\n        # Ensure timestamp is a datetime\n        if 'timestamp' in df.columns:\n            df['timestamp'] = pd.to_datetime(df['timestamp'])\n        else:\n            return False\n\n        # Group by day and device to reduce noise\n        df['date'] = df['timestamp'].dt.date\n        daily_data = df.groupby(['date', 'device_id'])['energy_consumed'].sum().reset_index()\n\n        # Prepare features for anomaly detection\n        # For each device, calculate:\n        # 1. Daily consumption\n        # 2. 7-day rolling average\n        # 3. Day of week (to account for weekly patterns)\n\n        devices = daily_data['device_id'].unique()\n        processed_data = []\n\n        for device in devices:\n            device_data = daily_data[daily_data['device_id'] == device]\n            if len(device_data) &lt;= 7:  # Need enough data for rolling average\n                continue\n\n            # FIX:\n            device_data = device_data.sort_values('date')\n            device_data['day_of_week'] = pd.to_datetime(device_data['date']).dt.dayofweek\n            device_data['rolling_avg_7d'] = device_data['energy_consumed'].rolling(7).mean()\n\n            # Skip the first 7 days (they won't have a complete 7-day average)\n            device_data = device_data.dropna()\n\n            processed_data.append(device_data)\n\n        if not processed_data:\n            return False\n\n        # Combine all devices\n        full_data = pd.concat(processed_data)\n\n        # Features for anomaly detection\n        features = full_data[['energy_consumed', 'rolling_avg_7d', 'day_of_week']]\n\n        # Standardize the features\n        self.scaler = StandardScaler()\n        scaled_features = self.scaler.fit_transform(features)\n\n        # Train the Isolation Forest model\n        self.model = IsolationForest(\n            # FIX:\n            contamination=self.contamination,\n            random_state=42,\n            n_estimators=100\n        )\n        self.model.fit(scaled_features)\n\n        self.training_complete = True\n        return True\n\n    except Exception as e:\n        print(f\"Error training anomaly detection model: {e}\")\n        return False\n</code></pre>"},{"location":"api/#app.utils.report.report_generator","title":"<code>app.utils.report.report_generator</code>","text":"<p>This module provides report generation feature &amp; functionality</p>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator","title":"<code>app.utils.report.report_generator.EnergyReportGenerator</code>","text":"<p>Enhanced energy report generator with advanced analytics and visualizations</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>class EnergyReportGenerator:\n    \"\"\"\n    Enhanced energy report generator with advanced analytics and visualizations\n    \"\"\"\n\n    def __init__(self, energy_data: List[Dict], user_data: Optional[Dict] = None):\n        \"\"\"\n        Initialize the report generator with energy consumption data\n\n        Args:\n            energy_data (List[Dict]): Energy consumption records\n            user_data (Optional[Dict]): User information for personalization\n        \"\"\"\n        # Convert data to pandas DataFrame for easier analysis\n        self.df = pd.DataFrame(energy_data)\n\n        # Ensure timestamp is datetime\n        if 'timestamp' in self.df.columns:\n            self.df['timestamp'] = pd.to_datetime(self.df['timestamp'])\n            self.df.sort_values('timestamp', inplace=True)\n\n        self.user_data = user_data or {}\n        self.device_names = self._get_device_names()\n\n    def _get_device_names(self) -&gt; Dict[str, str]:\n        \"\"\"\n        Map device IDs to more readable names\n        This would ideally pull from a devices collection\n\n        Returns:\n            Dict[str, str]: Mapping of device_id to readable name\n        \"\"\"\n        # This is a placeholder - in production, you would query the database\n        # to get actual device names based on the device_ids in the energy data\n\n        device_ids = self.df['device_id'].unique() if 'device_id' in self.df.columns else []\n\n        # Create a mapping of device_id to readable names\n        # In production, this would come from the devices collection\n        return {device_id: f\"Device {i+1}\" for i, device_id in enumerate(device_ids)}\n\n    def calculate_total_energy_usage(self) -&gt; float:\n        \"\"\"\n        Calculate the total energy consumption in kWh\n\n        Returns:\n            float: Total energy consumption\n        \"\"\"\n        if 'energy_consumed' in self.df.columns:\n            return float(self.df['energy_consumed'].sum())\n        return 0.0\n\n    def calculate_total_cost(self, cost_per_kwh: float = DEFAULT_ENERGY_COST) -&gt; float:\n        \"\"\"\n        Calculate the total cost based on energy consumption\n\n        Args:\n            cost_per_kwh (float): Cost per kWh in local currency\n\n        Returns:\n            float: Total estimated cost\n        \"\"\"\n        total_energy = self.calculate_total_energy_usage()\n        return total_energy * cost_per_kwh\n\n    def analyze_trends(self, interval: str = 'day') -&gt; pd.DataFrame:\n        \"\"\"\n        Analyze energy consumption trends over time\n\n        Args:\n            interval (str): Time grouping interval ('hour', 'day', 'week', 'month')\n\n        Returns:\n            pd.DataFrame: Aggregated energy consumption by time period\n        \"\"\"\n        if 'timestamp' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n            return pd.DataFrame()\n\n        # Group by the specified time interval\n        if interval == 'hour':\n            grouper = pd.Grouper(key='timestamp', freq='H')\n        elif interval == 'day':\n            grouper = pd.Grouper(key='timestamp', freq='D')\n        elif interval == 'week':\n            grouper = pd.Grouper(key='timestamp', freq='W')\n        elif interval == 'month':\n            grouper = pd.Grouper(key='timestamp', freq='M')\n        else:\n            grouper = pd.Grouper(key='timestamp', freq='D')  # Default to daily\n\n        # Aggregate by the interval\n        trends = self.df.groupby(grouper)['energy_consumed'].sum().reset_index()\n        trends.columns = ['period', 'energy_consumed']\n\n        # Calculate the percentage change between consecutive periods\n        trends['change_pct'] = trends['energy_consumed'].pct_change() * 100\n\n        return trends\n\n    def analyze_by_device(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Analyze energy consumption by device\n\n        Returns:\n            pd.DataFrame: Energy consumption aggregated by device\n        \"\"\"\n        if 'device_id' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n            return pd.DataFrame()\n\n        # Group by device_id\n        device_usage = self.df.groupby('device_id')['energy_consumed'].sum().reset_index()\n\n        # Add readable device names\n        # FIX:\n        device_usage['device_name'] = device_usage['device_id'].map(self.device_names)\n\n        # Calculate percentage of total\n        total = device_usage['energy_consumed'].sum()\n        if total &gt; 0:\n            device_usage['percentage'] = (device_usage['energy_consumed'] / total) * 100\n        else:\n            device_usage['percentage'] = 0\n\n        return device_usage\n\n    def analyze_by_location(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Analyze energy consumption by location\n\n        Returns:\n            pd.DataFrame: Energy consumption aggregated by location\n        \"\"\"\n        if 'location' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n            return pd.DataFrame()\n\n        # Fill missing locations\n        location_df = self.df.copy()\n        location_df['location'] = location_df['location'].fillna('Unknown')\n\n        # Group by location\n        location_usage = location_df.groupby('location')['energy_consumed'].sum().reset_index()\n\n        # Calculate percentage of total\n        total = location_usage['energy_consumed'].sum()\n        if total &gt; 0:\n            location_usage['percentage'] = (location_usage['energy_consumed'] / total) * 100\n        else:\n            location_usage['percentage'] = 0\n\n        return location_usage\n\n    def identify_peak_usage_times(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Identify peak energy usage times\n\n        Returns:\n            pd.DataFrame: Hours of the day ranked by energy consumption\n        \"\"\"\n        if 'timestamp' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n            return pd.DataFrame()\n\n        # Extract hour from timestamp\n        hour_df = self.df.copy()\n        hour_df['hour'] = hour_df['timestamp'].dt.hour\n\n        # Group by hour\n        hourly_usage = hour_df.groupby('hour')['energy_consumed'].sum().reset_index()\n\n        # Sort by energy consumption (descending)\n        hourly_usage.sort_values('energy_consumed', ascending=False, inplace=True)\n\n        return hourly_usage\n\n    def detect_anomalies(self) -&gt; Tuple[pd.DataFrame, float]:\n        \"\"\"\n        Detect anomalies in energy consumption using Isolation Forest\n\n        Returns:\n            Tuple[pd.DataFrame, float]: DataFrame with anomaly scores and anomaly threshold\n        \"\"\"\n        if len(self.df) &lt; 10 or 'energy_consumed' not in self.df.columns:\n            return pd.DataFrame(), 0.0\n\n        try:\n            # Prepare data for anomaly detection\n            data = self.df[['energy_consumed']].copy()\n\n            # Standardize the data\n            scaler = StandardScaler()\n            scaled_data = scaler.fit_transform(data)\n\n            # Use Isolation Forest for anomaly detection\n            # FIX:\n            model = IsolationForest(contamination=0.05, random_state=42)\n            data['anomaly_score'] = model.fit_predict(scaled_data)\n\n            # Convert to anomaly score (higher is more anomalous)\n            # FIX:\n            data['anomaly_score'] = data['anomaly_score'].map({1: 0, -1: 1})\n\n            # Add timestamp\n            data['timestamp'] = self.df['timestamp']\n\n            # Get the anomaly threshold (for plotting)\n            anomaly_threshold = data[data['anomaly_score'] &gt; 0]['energy_consumed'].min()\n\n            # FIX:\n            return data, anomaly_threshold\n        except Exception as e:\n            print(f\"Error in anomaly detection: {e}\")\n            return pd.DataFrame(), 0.0\n\n    def forecast_future_usage(self, days_ahead: int = 7) -&gt; pd.DataFrame:\n        \"\"\"\n        Forecast future energy consumption using ARIMA\n\n        Args:\n            days_ahead (int): Number of days to forecast\n\n        Returns:\n            pd.DataFrame: Forecasted energy consumption\n        \"\"\"\n        if len(self.df) &lt; 14 or 'timestamp' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n            return pd.DataFrame()\n\n        try:\n            # Prepare data for forecasting\n            # Group by day to reduce noise\n            daily_data = self.df.groupby(pd.Grouper(key='timestamp', freq='D'))['energy_consumed'].sum()\n\n            # Ensure we have enough data points\n            if len(daily_data) &lt; 7:\n                return pd.DataFrame()\n\n            # Fit ARIMA model\n            # Using a simple model for demonstration; would need tuning in production\n            # FIX:\n            model = ARIMA(daily_data, order=(1, 1, 1))\n            model_fit = model.fit()\n\n            # Generate forecast\n            forecast = model_fit.forecast(steps=days_ahead)\n\n            # Create forecasted dates\n            last_date = daily_data.index[-1]\n            # FIX:\n            forecast_dates = [last_date + timedelta(days=i+1) for i in range(days_ahead)]\n\n            # Create result DataFrame\n            forecast_df = pd.DataFrame({\n                'timestamp': forecast_dates,\n                'forecasted_energy': forecast.values,\n                'type': 'forecast'\n            })\n\n            # Add the historical data\n            historical_df = pd.DataFrame({\n                'timestamp': daily_data.index,\n                'forecasted_energy': daily_data.values,\n                'type': 'historical'\n            })\n\n            # Combine historical and forecast\n            result = pd.concat([historical_df, forecast_df])\n\n            return result\n\n        except Exception as e:\n            print(f\"Error in forecasting: {e}\")\n            return pd.DataFrame()\n\n    def generate_energy_saving_tips(self) -&gt; List[str]:\n        \"\"\"\n        Generate personalized energy-saving tips based on usage patterns\n\n        Returns:\n            List[str]: Energy-saving recommendations\n        \"\"\"\n        tips = [\n            \"Consider using smart power strips to eliminate phantom energy use from devices on standby.\",\n            \"Replace high-energy appliances with energy-efficient models (look for ENERGY STAR ratings).\",\n            \"Install a programmable thermostat to optimize heating and cooling.\",\n            \"Use natural light when possible and replace incandescent bulbs with LEDs.\",\n            \"Ensure proper insulation in your home to reduce heating and cooling costs.\"\n        ]\n\n        # Add personalized tips based on patterns in the data\n        device_usage = self.analyze_by_device()\n        if not device_usage.empty:\n            # Identify the device with highest energy consumption\n            top_device = device_usage.iloc[0]\n            tips.append(f\"Your {top_device['device_name']} consumes {top_device['percentage']:.1f}% of your energy. \"\n                        f\"Consider upgrading to a more efficient model or adjusting usage patterns.\")\n\n        # Add tips based on peak hours\n        peak_hours = self.identify_peak_usage_times()\n        if not peak_hours.empty and len(peak_hours) &gt; 0:\n            top_hour = peak_hours.iloc[0]['hour']\n            tips.append(f\"Your peak energy usage occurs around {top_hour}:00. \"\n                        f\"Consider shifting energy-intensive activities to off-peak hours.\")\n\n        return tips\n\n    def create_pdf_report(self) -&gt; str:\n        \"\"\"\n        Generate a comprehensive PDF report with visualizations\n\n        Returns:\n            str: Path to the generated PDF report\n        \"\"\"\n        # Generate report filename\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.pdf\"\n\n        # Create the PDF document\n        doc = SimpleDocTemplate(filename, pagesize=A4)\n        styles = getSampleStyleSheet()\n\n        # Create a title style\n        title_style = ParagraphStyle(\n            'Title',\n            parent=styles['Heading1'],\n            fontSize=18,\n            alignment=1,  # Center alignment\n            spaceAfter=12\n        )\n\n        # Create a subtitle style\n        subtitle_style = ParagraphStyle(\n            'Subtitle',\n            parent=styles['Heading2'],\n            fontSize=14,\n            spaceAfter=10\n        )\n\n        # Create normal text style\n        normal_style = styles['Normal']\n\n        # Start building the document\n        elements = []\n\n        # Title and introduction\n        elements.append(Paragraph(\"Energy Consumption Report\", title_style))\n        elements.append(Spacer(1, 0.2 * inch))\n\n        report_date = datetime.now().strftime(\"%B %d, %Y\")\n        elements.append(Paragraph(f\"Generated on {report_date}\", normal_style))\n        elements.append(Spacer(1, 0.3 * inch))\n\n        # Summary section\n        elements.append(Paragraph(\"Summary\", subtitle_style))\n\n        total_energy = self.calculate_total_energy_usage()\n        total_cost = self.calculate_total_cost()\n\n        summary_data = [\n            [\"Total Energy Consumption\", f\"{total_energy:.2f} kWh\"],\n            [\"Estimated Cost\", f\"{total_cost:.2f} AED\"],\n        ]\n\n        # Add date range if available\n        if 'timestamp' in self.df.columns and not self.df.empty:\n            start_date = self.df['timestamp'].min().strftime(\"%Y-%m-%d\")\n            end_date = self.df['timestamp'].max().strftime(\"%Y-%m-%d\")\n            summary_data.append([\"Date Range\", f\"{start_date} to {end_date}\"])\n\n        summary_table = Table(summary_data, colWidths=[2.5*inch, 2.5*inch])\n        summary_table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n            ('PADDING', (0, 0), (-1, -1), 6),\n        ]))\n        elements.append(summary_table)\n        elements.append(Spacer(1, 0.3 * inch))\n\n        # Add trend analysis\n        elements.append(Paragraph(\"Energy Consumption Trends\", subtitle_style))\n\n        trends = self.analyze_trends(interval='day')\n        if not trends.empty and len(trends) &gt; 1:\n            # Create trend visualization\n            plt.figure(figsize=(8, 4))\n            plt.plot(trends['period'], trends['energy_consumed'], marker='o', linestyle='-')\n            plt.xlabel('Date')\n            plt.ylabel('Energy (kWh)')\n            plt.title('Daily Energy Consumption')\n            plt.grid(True, alpha=0.3)\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Add trend insights\n            avg_change = trends['change_pct'].mean()\n            last_change = trends['change_pct'].iloc[-1] if len(trends) &gt; 1 else 0\n\n            if not np.isnan(avg_change) and not np.isnan(last_change):\n                trend_text = f\"Your average daily change in energy consumption is {avg_change:.1f}%. \"\n                trend_text += f\"Your most recent change was {last_change:.1f}%.\"\n                elements.append(Paragraph(trend_text, normal_style))\n        else:\n            elements.append(Paragraph(\"Insufficient data to analyze trends.\", normal_style))\n\n        elements.append(Spacer(1, 0.3 * inch))\n\n        # Device breakdown\n        elements.append(Paragraph(\"Energy Consumption by Device\", subtitle_style))\n\n        device_usage = self.analyze_by_device()\n        if not device_usage.empty:\n            # Create device visualization\n            plt.figure(figsize=(8, 4))\n\n            # Sort by energy consumed\n            device_usage = device_usage.sort_values('energy_consumed', ascending=False)\n\n            # Use device names for better readability\n            labels = device_usage['device_name'].tolist()\n            sizes = device_usage['energy_consumed'].tolist()\n\n            # Create pie chart\n            plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90, shadow=True)\n            plt.axis('equal')\n            plt.title('Energy Consumption by Device')\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Add table with detailed breakdown\n            device_table_data = [[\"Device\", \"Energy (kWh)\", \"Percentage\", \"Cost ($)\"]]\n            for _, row in device_usage.iterrows():\n                device_table_data.append([\n                    # FIX:\n                    row['device_name'],\n                    f\"{row['energy_consumed']:.2f}\",\n                    f\"{row['percentage']:.1f}%\",\n                    f\"${row['energy_consumed'] * DEFAULT_ENERGY_COST:.2f}\"\n                ])\n\n            device_table = Table(device_table_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])\n            device_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),\n                ('GRID', (0, 0), (-1, -1), 1, colors.black),\n                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),\n                ('PADDING', (0, 0), (-1, -1), 6),\n            ]))\n            elements.append(device_table)\n        else:\n            elements.append(Paragraph(\"Insufficient data to analyze device usage.\", normal_style))\n\n        elements.append(Spacer(1, 0.3 * inch))\n\n        # Add usage patterns\n        elements.append(Paragraph(\"Usage Patterns\", subtitle_style))\n\n        hourly_usage = self.identify_peak_usage_times()\n        if not hourly_usage.empty:\n            # Create hourly pattern visualization\n            plt.figure(figsize=(8, 4))\n\n            # Sort by hour for better visualization\n            hourly_usage = hourly_usage.sort_values('hour')\n\n            plt.bar(hourly_usage['hour'], hourly_usage['energy_consumed'])\n            plt.xlabel('Hour of Day')\n            plt.ylabel('Energy (kWh)')\n            plt.title('Energy Consumption by Hour of Day')\n            plt.xticks(range(0, 24, 2))  # Show every 2 hours\n            plt.grid(True, alpha=0.3, axis='y')\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Add peak usage insight\n            top_hours = hourly_usage.sort_values('energy_consumed', ascending=False).head(3)\n            peak_hours_str = \", \".join([f\"{hour}:00\" for hour in top_hours['hour']])\n            elements.append(Paragraph(f\"Your peak energy usage occurs at: {peak_hours_str}\", normal_style))\n        else:\n            elements.append(Paragraph(\"Insufficient data to analyze usage patterns.\", normal_style))\n\n        elements.append(PageBreak())\n\n        # Anomaly detection\n        elements.append(Paragraph(\"Anomaly Detection\", subtitle_style))\n\n        anomaly_data, threshold = self.detect_anomalies()\n        if not anomaly_data.empty and 'anomaly_score' in anomaly_data.columns:\n            # Create anomaly visualization\n            plt.figure(figsize=(8, 4))\n\n            # Plot normal points\n            normal = anomaly_data[anomaly_data['anomaly_score'] == 0]\n            plt.scatter(normal['timestamp'], normal['energy_consumed'], \n                       color='blue', label='Normal', alpha=0.5)\n\n            # Plot anomalies\n            anomalies = anomaly_data[anomaly_data['anomaly_score'] &gt; 0]\n            plt.scatter(anomalies['timestamp'], anomalies['energy_consumed'], \n                       color='red', label='Anomaly', alpha=0.8)\n\n            plt.xlabel('Date')\n            plt.ylabel('Energy (kWh)')\n            plt.title('Anomaly Detection in Energy Consumption')\n            plt.legend()\n            plt.grid(True, alpha=0.3)\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Add anomaly insights\n            anomaly_count = len(anomalies)\n            if anomaly_count &gt; 0:\n                # FIX:\n                anomaly_dates = anomalies['timestamp'].dt.strftime('%Y-%m-%d').tolist()\n                anomaly_text = f\"We detected {anomaly_count} anomalies in your energy consumption. \"\n                if anomaly_count &lt;= 3:\n                    anomaly_text += f\"Unusual consumption occurred on: {', '.join(anomaly_dates)}.\"\n                elements.append(Paragraph(anomaly_text, normal_style))\n            else:\n                elements.append(Paragraph(\"No anomalies detected in your energy consumption pattern.\", normal_style))\n        else:\n            elements.append(Paragraph(\"Insufficient data to perform anomaly detection.\", normal_style))\n\n        elements.append(Spacer(1, 0.3 * inch))\n\n        # Forecasting\n        elements.append(Paragraph(\"Energy Consumption Forecast\", subtitle_style))\n\n        forecast_data = self.forecast_future_usage(days_ahead=7)\n        if not forecast_data.empty:\n            # Create forecast visualization\n            plt.figure(figsize=(8, 4))\n\n            # Plot historical data\n            historical = forecast_data[forecast_data['type'] == 'historical']\n            plt.plot(historical['timestamp'], historical['forecasted_energy'], \n                    'b-', label='Historical', alpha=0.7)\n\n            # Plot forecasted data\n            forecast = forecast_data[forecast_data['type'] == 'forecast']\n            plt.plot(forecast['timestamp'], forecast['forecasted_energy'], \n                    'r--', label='Forecast', alpha=0.7)\n\n            plt.xlabel('Date')\n            plt.ylabel('Energy (kWh)')\n            plt.title('7-Day Energy Consumption Forecast')\n            plt.legend()\n            plt.grid(True, alpha=0.3)\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Add forecast insights\n            forecasted_total = forecast['forecasted_energy'].sum()\n            forecasted_cost = forecasted_total * DEFAULT_ENERGY_COST\n            forecast_text = f\"Forecasted energy consumption for the next 7 days: {forecasted_total:.2f} kWh. \"\n            forecast_text += f\"Estimated cost: ${forecasted_cost:.2f}.\"\n            elements.append(Paragraph(forecast_text, normal_style))\n        else:\n            elements.append(Paragraph(\"Insufficient data to generate forecast.\", normal_style))\n\n        elements.append(Spacer(1, 0.3 * inch))\n\n        # Energy saving recommendations\n        elements.append(Paragraph(\"Energy Saving Recommendations\", subtitle_style))\n\n        tips = self.generate_energy_saving_tips()\n        for tip in tips:\n            elements.append(Paragraph(f\"\u2022 {tip}\", normal_style))\n            elements.append(Spacer(1, 0.1 * inch))\n\n        # Build the PDF\n        doc.build(elements)\n\n        return filename\n\n    def create_csv_report(self) -&gt; str:\n        \"\"\"\n        Generate a comprehensive CSV report with multiple sheets\n\n        Returns:\n            str: Path to the generated CSV (Excel) report\n        \"\"\"\n        # Generate report filename\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.xlsx\"\n\n        # Create Excel writer\n        with pd.ExcelWriter(filename, engine='xlsxwriter') as writer:\n            # Summary sheet\n            summary_data = {\n                'Metric': ['Total Energy Consumption (kWh)', 'Estimated Cost ($)'],\n                'Value': [\n                    f\"{self.calculate_total_energy_usage():.2f}\",\n                    f\"{self.calculate_total_cost():.2f}\"\n                ]\n            }\n\n            # Add date range if available\n            if 'timestamp' in self.df.columns and not self.df.empty:\n                start_date = self.df['timestamp'].min().strftime(\"%Y-%m-%d\")\n                end_date = self.df['timestamp'].max().strftime(\"%Y-%m-%d\")\n                summary_data['Metric'].append('Date Range')\n                summary_data['Value'].append(f\"{start_date} to {end_date}\")\n\n            summary_df = pd.DataFrame(summary_data)\n            summary_df.to_excel(writer, sheet_name='Summary', index=False)\n\n            # Trend analysis\n            trends = self.analyze_trends(interval='day')\n            if not trends.empty:\n                trends.to_excel(writer, sheet_name='Daily Trends', index=False)\n\n            # Device breakdown\n            device_usage = self.analyze_by_device()\n            if not device_usage.empty:\n                # Add cost column\n                device_usage['estimated_cost'] = device_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n                device_usage.to_excel(writer, sheet_name='Device Breakdown', index=False)\n\n            # Location breakdown\n            location_usage = self.analyze_by_location()\n            if not location_usage.empty:\n                # Add cost column\n                location_usage['estimated_cost'] = location_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n                location_usage.to_excel(writer, sheet_name='Location Breakdown', index=False)\n\n            # Hourly patterns\n            hourly_usage = self.identify_peak_usage_times()\n            if not hourly_usage.empty:\n                hourly_usage.to_excel(writer, sheet_name='Hourly Patterns', index=False)\n\n            # Anomalies\n            anomaly_data, _ = self.detect_anomalies()\n            if not anomaly_data.empty and 'anomaly_score' in anomaly_data.columns:\n                anomaly_data.to_excel(writer, sheet_name='Anomalies', index=False)\n\n            # Forecast\n            forecast_data = self.forecast_future_usage(days_ahead=7)\n            if not forecast_data.empty:\n                forecast_data.to_excel(writer, sheet_name='Forecast', index=False)\n\n            # Energy saving tips\n            tips = self.generate_energy_saving_tips()\n            tips_df = pd.DataFrame({'Energy Saving Tips': tips})\n            tips_df.to_excel(writer, sheet_name='Recommendations', index=False)\n\n            # Raw data\n            if not self.df.empty:\n                # Format the timestamp for readability\n                raw_data = self.df.copy()\n                if 'timestamp' in raw_data.columns:\n                    raw_data['timestamp'] = raw_data['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')\n                raw_data.to_excel(writer, sheet_name='Raw Data', index=False)\n\n        return filename\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.__init__","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.__init__(energy_data, user_data=None)</code>","text":"<p>Initialize the report generator with energy consumption data</p> <p>Parameters:</p> Name Type Description Default <code>energy_data</code> <code>List[Dict]</code> <p>Energy consumption records</p> required <code>user_data</code> <code>Optional[Dict]</code> <p>User information for personalization</p> <code>None</code> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def __init__(self, energy_data: List[Dict], user_data: Optional[Dict] = None):\n    \"\"\"\n    Initialize the report generator with energy consumption data\n\n    Args:\n        energy_data (List[Dict]): Energy consumption records\n        user_data (Optional[Dict]): User information for personalization\n    \"\"\"\n    # Convert data to pandas DataFrame for easier analysis\n    self.df = pd.DataFrame(energy_data)\n\n    # Ensure timestamp is datetime\n    if 'timestamp' in self.df.columns:\n        self.df['timestamp'] = pd.to_datetime(self.df['timestamp'])\n        self.df.sort_values('timestamp', inplace=True)\n\n    self.user_data = user_data or {}\n    self.device_names = self._get_device_names()\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator._get_device_names","title":"<code>app.utils.report.report_generator.EnergyReportGenerator._get_device_names()</code>","text":"<p>Map device IDs to more readable names This would ideally pull from a devices collection</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: Mapping of device_id to readable name</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def _get_device_names(self) -&gt; Dict[str, str]:\n    \"\"\"\n    Map device IDs to more readable names\n    This would ideally pull from a devices collection\n\n    Returns:\n        Dict[str, str]: Mapping of device_id to readable name\n    \"\"\"\n    # This is a placeholder - in production, you would query the database\n    # to get actual device names based on the device_ids in the energy data\n\n    device_ids = self.df['device_id'].unique() if 'device_id' in self.df.columns else []\n\n    # Create a mapping of device_id to readable names\n    # In production, this would come from the devices collection\n    return {device_id: f\"Device {i+1}\" for i, device_id in enumerate(device_ids)}\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.analyze_by_device","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.analyze_by_device()</code>","text":"<p>Analyze energy consumption by device</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Energy consumption aggregated by device</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def analyze_by_device(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Analyze energy consumption by device\n\n    Returns:\n        pd.DataFrame: Energy consumption aggregated by device\n    \"\"\"\n    if 'device_id' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n        return pd.DataFrame()\n\n    # Group by device_id\n    device_usage = self.df.groupby('device_id')['energy_consumed'].sum().reset_index()\n\n    # Add readable device names\n    # FIX:\n    device_usage['device_name'] = device_usage['device_id'].map(self.device_names)\n\n    # Calculate percentage of total\n    total = device_usage['energy_consumed'].sum()\n    if total &gt; 0:\n        device_usage['percentage'] = (device_usage['energy_consumed'] / total) * 100\n    else:\n        device_usage['percentage'] = 0\n\n    return device_usage\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.analyze_by_location","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.analyze_by_location()</code>","text":"<p>Analyze energy consumption by location</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Energy consumption aggregated by location</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def analyze_by_location(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Analyze energy consumption by location\n\n    Returns:\n        pd.DataFrame: Energy consumption aggregated by location\n    \"\"\"\n    if 'location' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n        return pd.DataFrame()\n\n    # Fill missing locations\n    location_df = self.df.copy()\n    location_df['location'] = location_df['location'].fillna('Unknown')\n\n    # Group by location\n    location_usage = location_df.groupby('location')['energy_consumed'].sum().reset_index()\n\n    # Calculate percentage of total\n    total = location_usage['energy_consumed'].sum()\n    if total &gt; 0:\n        location_usage['percentage'] = (location_usage['energy_consumed'] / total) * 100\n    else:\n        location_usage['percentage'] = 0\n\n    return location_usage\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.analyze_trends","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.analyze_trends(interval='day')</code>","text":"<p>Analyze energy consumption trends over time</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>Time grouping interval ('hour', 'day', 'week', 'month')</p> <code>'day'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Aggregated energy consumption by time period</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def analyze_trends(self, interval: str = 'day') -&gt; pd.DataFrame:\n    \"\"\"\n    Analyze energy consumption trends over time\n\n    Args:\n        interval (str): Time grouping interval ('hour', 'day', 'week', 'month')\n\n    Returns:\n        pd.DataFrame: Aggregated energy consumption by time period\n    \"\"\"\n    if 'timestamp' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n        return pd.DataFrame()\n\n    # Group by the specified time interval\n    if interval == 'hour':\n        grouper = pd.Grouper(key='timestamp', freq='H')\n    elif interval == 'day':\n        grouper = pd.Grouper(key='timestamp', freq='D')\n    elif interval == 'week':\n        grouper = pd.Grouper(key='timestamp', freq='W')\n    elif interval == 'month':\n        grouper = pd.Grouper(key='timestamp', freq='M')\n    else:\n        grouper = pd.Grouper(key='timestamp', freq='D')  # Default to daily\n\n    # Aggregate by the interval\n    trends = self.df.groupby(grouper)['energy_consumed'].sum().reset_index()\n    trends.columns = ['period', 'energy_consumed']\n\n    # Calculate the percentage change between consecutive periods\n    trends['change_pct'] = trends['energy_consumed'].pct_change() * 100\n\n    return trends\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.calculate_total_cost","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.calculate_total_cost(cost_per_kwh=DEFAULT_ENERGY_COST)</code>","text":"<p>Calculate the total cost based on energy consumption</p> <p>Parameters:</p> Name Type Description Default <code>cost_per_kwh</code> <code>float</code> <p>Cost per kWh in local currency</p> <code>DEFAULT_ENERGY_COST</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Total estimated cost</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def calculate_total_cost(self, cost_per_kwh: float = DEFAULT_ENERGY_COST) -&gt; float:\n    \"\"\"\n    Calculate the total cost based on energy consumption\n\n    Args:\n        cost_per_kwh (float): Cost per kWh in local currency\n\n    Returns:\n        float: Total estimated cost\n    \"\"\"\n    total_energy = self.calculate_total_energy_usage()\n    return total_energy * cost_per_kwh\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.calculate_total_energy_usage","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.calculate_total_energy_usage()</code>","text":"<p>Calculate the total energy consumption in kWh</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Total energy consumption</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def calculate_total_energy_usage(self) -&gt; float:\n    \"\"\"\n    Calculate the total energy consumption in kWh\n\n    Returns:\n        float: Total energy consumption\n    \"\"\"\n    if 'energy_consumed' in self.df.columns:\n        return float(self.df['energy_consumed'].sum())\n    return 0.0\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.create_csv_report","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.create_csv_report()</code>","text":"<p>Generate a comprehensive CSV report with multiple sheets</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated CSV (Excel) report</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def create_csv_report(self) -&gt; str:\n    \"\"\"\n    Generate a comprehensive CSV report with multiple sheets\n\n    Returns:\n        str: Path to the generated CSV (Excel) report\n    \"\"\"\n    # Generate report filename\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.xlsx\"\n\n    # Create Excel writer\n    with pd.ExcelWriter(filename, engine='xlsxwriter') as writer:\n        # Summary sheet\n        summary_data = {\n            'Metric': ['Total Energy Consumption (kWh)', 'Estimated Cost ($)'],\n            'Value': [\n                f\"{self.calculate_total_energy_usage():.2f}\",\n                f\"{self.calculate_total_cost():.2f}\"\n            ]\n        }\n\n        # Add date range if available\n        if 'timestamp' in self.df.columns and not self.df.empty:\n            start_date = self.df['timestamp'].min().strftime(\"%Y-%m-%d\")\n            end_date = self.df['timestamp'].max().strftime(\"%Y-%m-%d\")\n            summary_data['Metric'].append('Date Range')\n            summary_data['Value'].append(f\"{start_date} to {end_date}\")\n\n        summary_df = pd.DataFrame(summary_data)\n        summary_df.to_excel(writer, sheet_name='Summary', index=False)\n\n        # Trend analysis\n        trends = self.analyze_trends(interval='day')\n        if not trends.empty:\n            trends.to_excel(writer, sheet_name='Daily Trends', index=False)\n\n        # Device breakdown\n        device_usage = self.analyze_by_device()\n        if not device_usage.empty:\n            # Add cost column\n            device_usage['estimated_cost'] = device_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n            device_usage.to_excel(writer, sheet_name='Device Breakdown', index=False)\n\n        # Location breakdown\n        location_usage = self.analyze_by_location()\n        if not location_usage.empty:\n            # Add cost column\n            location_usage['estimated_cost'] = location_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n            location_usage.to_excel(writer, sheet_name='Location Breakdown', index=False)\n\n        # Hourly patterns\n        hourly_usage = self.identify_peak_usage_times()\n        if not hourly_usage.empty:\n            hourly_usage.to_excel(writer, sheet_name='Hourly Patterns', index=False)\n\n        # Anomalies\n        anomaly_data, _ = self.detect_anomalies()\n        if not anomaly_data.empty and 'anomaly_score' in anomaly_data.columns:\n            anomaly_data.to_excel(writer, sheet_name='Anomalies', index=False)\n\n        # Forecast\n        forecast_data = self.forecast_future_usage(days_ahead=7)\n        if not forecast_data.empty:\n            forecast_data.to_excel(writer, sheet_name='Forecast', index=False)\n\n        # Energy saving tips\n        tips = self.generate_energy_saving_tips()\n        tips_df = pd.DataFrame({'Energy Saving Tips': tips})\n        tips_df.to_excel(writer, sheet_name='Recommendations', index=False)\n\n        # Raw data\n        if not self.df.empty:\n            # Format the timestamp for readability\n            raw_data = self.df.copy()\n            if 'timestamp' in raw_data.columns:\n                raw_data['timestamp'] = raw_data['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')\n            raw_data.to_excel(writer, sheet_name='Raw Data', index=False)\n\n    return filename\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.create_pdf_report","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.create_pdf_report()</code>","text":"<p>Generate a comprehensive PDF report with visualizations</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated PDF report</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def create_pdf_report(self) -&gt; str:\n    \"\"\"\n    Generate a comprehensive PDF report with visualizations\n\n    Returns:\n        str: Path to the generated PDF report\n    \"\"\"\n    # Generate report filename\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.pdf\"\n\n    # Create the PDF document\n    doc = SimpleDocTemplate(filename, pagesize=A4)\n    styles = getSampleStyleSheet()\n\n    # Create a title style\n    title_style = ParagraphStyle(\n        'Title',\n        parent=styles['Heading1'],\n        fontSize=18,\n        alignment=1,  # Center alignment\n        spaceAfter=12\n    )\n\n    # Create a subtitle style\n    subtitle_style = ParagraphStyle(\n        'Subtitle',\n        parent=styles['Heading2'],\n        fontSize=14,\n        spaceAfter=10\n    )\n\n    # Create normal text style\n    normal_style = styles['Normal']\n\n    # Start building the document\n    elements = []\n\n    # Title and introduction\n    elements.append(Paragraph(\"Energy Consumption Report\", title_style))\n    elements.append(Spacer(1, 0.2 * inch))\n\n    report_date = datetime.now().strftime(\"%B %d, %Y\")\n    elements.append(Paragraph(f\"Generated on {report_date}\", normal_style))\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Summary section\n    elements.append(Paragraph(\"Summary\", subtitle_style))\n\n    total_energy = self.calculate_total_energy_usage()\n    total_cost = self.calculate_total_cost()\n\n    summary_data = [\n        [\"Total Energy Consumption\", f\"{total_energy:.2f} kWh\"],\n        [\"Estimated Cost\", f\"{total_cost:.2f} AED\"],\n    ]\n\n    # Add date range if available\n    if 'timestamp' in self.df.columns and not self.df.empty:\n        start_date = self.df['timestamp'].min().strftime(\"%Y-%m-%d\")\n        end_date = self.df['timestamp'].max().strftime(\"%Y-%m-%d\")\n        summary_data.append([\"Date Range\", f\"{start_date} to {end_date}\"])\n\n    summary_table = Table(summary_data, colWidths=[2.5*inch, 2.5*inch])\n    summary_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n        ('PADDING', (0, 0), (-1, -1), 6),\n    ]))\n    elements.append(summary_table)\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Add trend analysis\n    elements.append(Paragraph(\"Energy Consumption Trends\", subtitle_style))\n\n    trends = self.analyze_trends(interval='day')\n    if not trends.empty and len(trends) &gt; 1:\n        # Create trend visualization\n        plt.figure(figsize=(8, 4))\n        plt.plot(trends['period'], trends['energy_consumed'], marker='o', linestyle='-')\n        plt.xlabel('Date')\n        plt.ylabel('Energy (kWh)')\n        plt.title('Daily Energy Consumption')\n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n\n        # Save the plot to a BytesIO object\n        img_data = BytesIO()\n        plt.savefig(img_data, format='png')\n        img_data.seek(0)\n        plt.close()\n\n        # Add the image to the PDF\n        img = Image(img_data, width=6*inch, height=3*inch)\n        elements.append(img)\n        elements.append(Spacer(1, 0.2 * inch))\n\n        # Add trend insights\n        avg_change = trends['change_pct'].mean()\n        last_change = trends['change_pct'].iloc[-1] if len(trends) &gt; 1 else 0\n\n        if not np.isnan(avg_change) and not np.isnan(last_change):\n            trend_text = f\"Your average daily change in energy consumption is {avg_change:.1f}%. \"\n            trend_text += f\"Your most recent change was {last_change:.1f}%.\"\n            elements.append(Paragraph(trend_text, normal_style))\n    else:\n        elements.append(Paragraph(\"Insufficient data to analyze trends.\", normal_style))\n\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Device breakdown\n    elements.append(Paragraph(\"Energy Consumption by Device\", subtitle_style))\n\n    device_usage = self.analyze_by_device()\n    if not device_usage.empty:\n        # Create device visualization\n        plt.figure(figsize=(8, 4))\n\n        # Sort by energy consumed\n        device_usage = device_usage.sort_values('energy_consumed', ascending=False)\n\n        # Use device names for better readability\n        labels = device_usage['device_name'].tolist()\n        sizes = device_usage['energy_consumed'].tolist()\n\n        # Create pie chart\n        plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90, shadow=True)\n        plt.axis('equal')\n        plt.title('Energy Consumption by Device')\n        plt.tight_layout()\n\n        # Save the plot to a BytesIO object\n        img_data = BytesIO()\n        plt.savefig(img_data, format='png')\n        img_data.seek(0)\n        plt.close()\n\n        # Add the image to the PDF\n        img = Image(img_data, width=6*inch, height=3*inch)\n        elements.append(img)\n        elements.append(Spacer(1, 0.2 * inch))\n\n        # Add table with detailed breakdown\n        device_table_data = [[\"Device\", \"Energy (kWh)\", \"Percentage\", \"Cost ($)\"]]\n        for _, row in device_usage.iterrows():\n            device_table_data.append([\n                # FIX:\n                row['device_name'],\n                f\"{row['energy_consumed']:.2f}\",\n                f\"{row['percentage']:.1f}%\",\n                f\"${row['energy_consumed'] * DEFAULT_ENERGY_COST:.2f}\"\n            ])\n\n        device_table = Table(device_table_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])\n        device_table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),\n            ('PADDING', (0, 0), (-1, -1), 6),\n        ]))\n        elements.append(device_table)\n    else:\n        elements.append(Paragraph(\"Insufficient data to analyze device usage.\", normal_style))\n\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Add usage patterns\n    elements.append(Paragraph(\"Usage Patterns\", subtitle_style))\n\n    hourly_usage = self.identify_peak_usage_times()\n    if not hourly_usage.empty:\n        # Create hourly pattern visualization\n        plt.figure(figsize=(8, 4))\n\n        # Sort by hour for better visualization\n        hourly_usage = hourly_usage.sort_values('hour')\n\n        plt.bar(hourly_usage['hour'], hourly_usage['energy_consumed'])\n        plt.xlabel('Hour of Day')\n        plt.ylabel('Energy (kWh)')\n        plt.title('Energy Consumption by Hour of Day')\n        plt.xticks(range(0, 24, 2))  # Show every 2 hours\n        plt.grid(True, alpha=0.3, axis='y')\n        plt.tight_layout()\n\n        # Save the plot to a BytesIO object\n        img_data = BytesIO()\n        plt.savefig(img_data, format='png')\n        img_data.seek(0)\n        plt.close()\n\n        # Add the image to the PDF\n        img = Image(img_data, width=6*inch, height=3*inch)\n        elements.append(img)\n        elements.append(Spacer(1, 0.2 * inch))\n\n        # Add peak usage insight\n        top_hours = hourly_usage.sort_values('energy_consumed', ascending=False).head(3)\n        peak_hours_str = \", \".join([f\"{hour}:00\" for hour in top_hours['hour']])\n        elements.append(Paragraph(f\"Your peak energy usage occurs at: {peak_hours_str}\", normal_style))\n    else:\n        elements.append(Paragraph(\"Insufficient data to analyze usage patterns.\", normal_style))\n\n    elements.append(PageBreak())\n\n    # Anomaly detection\n    elements.append(Paragraph(\"Anomaly Detection\", subtitle_style))\n\n    anomaly_data, threshold = self.detect_anomalies()\n    if not anomaly_data.empty and 'anomaly_score' in anomaly_data.columns:\n        # Create anomaly visualization\n        plt.figure(figsize=(8, 4))\n\n        # Plot normal points\n        normal = anomaly_data[anomaly_data['anomaly_score'] == 0]\n        plt.scatter(normal['timestamp'], normal['energy_consumed'], \n                   color='blue', label='Normal', alpha=0.5)\n\n        # Plot anomalies\n        anomalies = anomaly_data[anomaly_data['anomaly_score'] &gt; 0]\n        plt.scatter(anomalies['timestamp'], anomalies['energy_consumed'], \n                   color='red', label='Anomaly', alpha=0.8)\n\n        plt.xlabel('Date')\n        plt.ylabel('Energy (kWh)')\n        plt.title('Anomaly Detection in Energy Consumption')\n        plt.legend()\n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n\n        # Save the plot to a BytesIO object\n        img_data = BytesIO()\n        plt.savefig(img_data, format='png')\n        img_data.seek(0)\n        plt.close()\n\n        # Add the image to the PDF\n        img = Image(img_data, width=6*inch, height=3*inch)\n        elements.append(img)\n        elements.append(Spacer(1, 0.2 * inch))\n\n        # Add anomaly insights\n        anomaly_count = len(anomalies)\n        if anomaly_count &gt; 0:\n            # FIX:\n            anomaly_dates = anomalies['timestamp'].dt.strftime('%Y-%m-%d').tolist()\n            anomaly_text = f\"We detected {anomaly_count} anomalies in your energy consumption. \"\n            if anomaly_count &lt;= 3:\n                anomaly_text += f\"Unusual consumption occurred on: {', '.join(anomaly_dates)}.\"\n            elements.append(Paragraph(anomaly_text, normal_style))\n        else:\n            elements.append(Paragraph(\"No anomalies detected in your energy consumption pattern.\", normal_style))\n    else:\n        elements.append(Paragraph(\"Insufficient data to perform anomaly detection.\", normal_style))\n\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Forecasting\n    elements.append(Paragraph(\"Energy Consumption Forecast\", subtitle_style))\n\n    forecast_data = self.forecast_future_usage(days_ahead=7)\n    if not forecast_data.empty:\n        # Create forecast visualization\n        plt.figure(figsize=(8, 4))\n\n        # Plot historical data\n        historical = forecast_data[forecast_data['type'] == 'historical']\n        plt.plot(historical['timestamp'], historical['forecasted_energy'], \n                'b-', label='Historical', alpha=0.7)\n\n        # Plot forecasted data\n        forecast = forecast_data[forecast_data['type'] == 'forecast']\n        plt.plot(forecast['timestamp'], forecast['forecasted_energy'], \n                'r--', label='Forecast', alpha=0.7)\n\n        plt.xlabel('Date')\n        plt.ylabel('Energy (kWh)')\n        plt.title('7-Day Energy Consumption Forecast')\n        plt.legend()\n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n\n        # Save the plot to a BytesIO object\n        img_data = BytesIO()\n        plt.savefig(img_data, format='png')\n        img_data.seek(0)\n        plt.close()\n\n        # Add the image to the PDF\n        img = Image(img_data, width=6*inch, height=3*inch)\n        elements.append(img)\n        elements.append(Spacer(1, 0.2 * inch))\n\n        # Add forecast insights\n        forecasted_total = forecast['forecasted_energy'].sum()\n        forecasted_cost = forecasted_total * DEFAULT_ENERGY_COST\n        forecast_text = f\"Forecasted energy consumption for the next 7 days: {forecasted_total:.2f} kWh. \"\n        forecast_text += f\"Estimated cost: ${forecasted_cost:.2f}.\"\n        elements.append(Paragraph(forecast_text, normal_style))\n    else:\n        elements.append(Paragraph(\"Insufficient data to generate forecast.\", normal_style))\n\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Energy saving recommendations\n    elements.append(Paragraph(\"Energy Saving Recommendations\", subtitle_style))\n\n    tips = self.generate_energy_saving_tips()\n    for tip in tips:\n        elements.append(Paragraph(f\"\u2022 {tip}\", normal_style))\n        elements.append(Spacer(1, 0.1 * inch))\n\n    # Build the PDF\n    doc.build(elements)\n\n    return filename\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.detect_anomalies","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.detect_anomalies()</code>","text":"<p>Detect anomalies in energy consumption using Isolation Forest</p> <p>Returns:</p> Type Description <code>Tuple[DataFrame, float]</code> <p>Tuple[pd.DataFrame, float]: DataFrame with anomaly scores and anomaly threshold</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def detect_anomalies(self) -&gt; Tuple[pd.DataFrame, float]:\n    \"\"\"\n    Detect anomalies in energy consumption using Isolation Forest\n\n    Returns:\n        Tuple[pd.DataFrame, float]: DataFrame with anomaly scores and anomaly threshold\n    \"\"\"\n    if len(self.df) &lt; 10 or 'energy_consumed' not in self.df.columns:\n        return pd.DataFrame(), 0.0\n\n    try:\n        # Prepare data for anomaly detection\n        data = self.df[['energy_consumed']].copy()\n\n        # Standardize the data\n        scaler = StandardScaler()\n        scaled_data = scaler.fit_transform(data)\n\n        # Use Isolation Forest for anomaly detection\n        # FIX:\n        model = IsolationForest(contamination=0.05, random_state=42)\n        data['anomaly_score'] = model.fit_predict(scaled_data)\n\n        # Convert to anomaly score (higher is more anomalous)\n        # FIX:\n        data['anomaly_score'] = data['anomaly_score'].map({1: 0, -1: 1})\n\n        # Add timestamp\n        data['timestamp'] = self.df['timestamp']\n\n        # Get the anomaly threshold (for plotting)\n        anomaly_threshold = data[data['anomaly_score'] &gt; 0]['energy_consumed'].min()\n\n        # FIX:\n        return data, anomaly_threshold\n    except Exception as e:\n        print(f\"Error in anomaly detection: {e}\")\n        return pd.DataFrame(), 0.0\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.forecast_future_usage","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.forecast_future_usage(days_ahead=7)</code>","text":"<p>Forecast future energy consumption using ARIMA</p> <p>Parameters:</p> Name Type Description Default <code>days_ahead</code> <code>int</code> <p>Number of days to forecast</p> <code>7</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Forecasted energy consumption</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def forecast_future_usage(self, days_ahead: int = 7) -&gt; pd.DataFrame:\n    \"\"\"\n    Forecast future energy consumption using ARIMA\n\n    Args:\n        days_ahead (int): Number of days to forecast\n\n    Returns:\n        pd.DataFrame: Forecasted energy consumption\n    \"\"\"\n    if len(self.df) &lt; 14 or 'timestamp' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n        return pd.DataFrame()\n\n    try:\n        # Prepare data for forecasting\n        # Group by day to reduce noise\n        daily_data = self.df.groupby(pd.Grouper(key='timestamp', freq='D'))['energy_consumed'].sum()\n\n        # Ensure we have enough data points\n        if len(daily_data) &lt; 7:\n            return pd.DataFrame()\n\n        # Fit ARIMA model\n        # Using a simple model for demonstration; would need tuning in production\n        # FIX:\n        model = ARIMA(daily_data, order=(1, 1, 1))\n        model_fit = model.fit()\n\n        # Generate forecast\n        forecast = model_fit.forecast(steps=days_ahead)\n\n        # Create forecasted dates\n        last_date = daily_data.index[-1]\n        # FIX:\n        forecast_dates = [last_date + timedelta(days=i+1) for i in range(days_ahead)]\n\n        # Create result DataFrame\n        forecast_df = pd.DataFrame({\n            'timestamp': forecast_dates,\n            'forecasted_energy': forecast.values,\n            'type': 'forecast'\n        })\n\n        # Add the historical data\n        historical_df = pd.DataFrame({\n            'timestamp': daily_data.index,\n            'forecasted_energy': daily_data.values,\n            'type': 'historical'\n        })\n\n        # Combine historical and forecast\n        result = pd.concat([historical_df, forecast_df])\n\n        return result\n\n    except Exception as e:\n        print(f\"Error in forecasting: {e}\")\n        return pd.DataFrame()\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.generate_energy_saving_tips","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.generate_energy_saving_tips()</code>","text":"<p>Generate personalized energy-saving tips based on usage patterns</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Energy-saving recommendations</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def generate_energy_saving_tips(self) -&gt; List[str]:\n    \"\"\"\n    Generate personalized energy-saving tips based on usage patterns\n\n    Returns:\n        List[str]: Energy-saving recommendations\n    \"\"\"\n    tips = [\n        \"Consider using smart power strips to eliminate phantom energy use from devices on standby.\",\n        \"Replace high-energy appliances with energy-efficient models (look for ENERGY STAR ratings).\",\n        \"Install a programmable thermostat to optimize heating and cooling.\",\n        \"Use natural light when possible and replace incandescent bulbs with LEDs.\",\n        \"Ensure proper insulation in your home to reduce heating and cooling costs.\"\n    ]\n\n    # Add personalized tips based on patterns in the data\n    device_usage = self.analyze_by_device()\n    if not device_usage.empty:\n        # Identify the device with highest energy consumption\n        top_device = device_usage.iloc[0]\n        tips.append(f\"Your {top_device['device_name']} consumes {top_device['percentage']:.1f}% of your energy. \"\n                    f\"Consider upgrading to a more efficient model or adjusting usage patterns.\")\n\n    # Add tips based on peak hours\n    peak_hours = self.identify_peak_usage_times()\n    if not peak_hours.empty and len(peak_hours) &gt; 0:\n        top_hour = peak_hours.iloc[0]['hour']\n        tips.append(f\"Your peak energy usage occurs around {top_hour}:00. \"\n                    f\"Consider shifting energy-intensive activities to off-peak hours.\")\n\n    return tips\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.EnergyReportGenerator.identify_peak_usage_times","title":"<code>app.utils.report.report_generator.EnergyReportGenerator.identify_peak_usage_times()</code>","text":"<p>Identify peak energy usage times</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Hours of the day ranked by energy consumption</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def identify_peak_usage_times(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Identify peak energy usage times\n\n    Returns:\n        pd.DataFrame: Hours of the day ranked by energy consumption\n    \"\"\"\n    if 'timestamp' not in self.df.columns or 'energy_consumed' not in self.df.columns:\n        return pd.DataFrame()\n\n    # Extract hour from timestamp\n    hour_df = self.df.copy()\n    hour_df['hour'] = hour_df['timestamp'].dt.hour\n\n    # Group by hour\n    hourly_usage = hour_df.groupby('hour')['energy_consumed'].sum().reset_index()\n\n    # Sort by energy consumption (descending)\n    hourly_usage.sort_values('energy_consumed', ascending=False, inplace=True)\n\n    return hourly_usage\n</code></pre>"},{"location":"api/#app.utils.report.report_generator.generate_energy_report","title":"<code>app.utils.report.report_generator.generate_energy_report(energy_data, user_data=None, format='pdf', start_date=None, end_date=None)</code>","text":"<p>Generate a comprehensive energy consumption report</p> <p>Parameters:</p> Name Type Description Default <code>energy_data</code> <code>List[Dict]</code> <p>Energy consumption records</p> required <code>user_data</code> <code>Optional[Dict]</code> <p>User information for personalization</p> <code>None</code> <code>format</code> <code>str</code> <p>Report format ('pdf' or 'csv')</p> <code>'pdf'</code> <code>start_date</code> <code>Optional[str]</code> <p>Start date filter in YYYY-MM-DD format</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>End date filter in YYYY-MM-DD format</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated report file</p> Source code in <code>app/utils/report/report_generator.py</code> <pre><code>def generate_energy_report(\n    energy_data: List[Dict], \n    user_data: Optional[Dict] = None,\n    format: str = 'pdf',\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n) -&gt; str:\n    \"\"\"\n    Generate a comprehensive energy consumption report\n\n    Args:\n        energy_data (List[Dict]): Energy consumption records\n        user_data (Optional[Dict]): User information for personalization\n        format (str): Report format ('pdf' or 'csv')\n        start_date (Optional[str]): Start date filter in YYYY-MM-DD format\n        end_date (Optional[str]): End date filter in YYYY-MM-DD format\n\n    Returns:\n        str: Path to the generated report file\n    \"\"\"\n    # Filter data by date range if provided\n    if start_date and end_date:\n        try:\n            start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n            end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n            filtered_data = [\n                record for record in energy_data \n                if start_dt &lt;= datetime.fromisoformat(str(record['timestamp'])) &lt;= end_dt\n            ]\n        except (ValueError, KeyError):\n            # If there's an error in filtering, use all data\n            filtered_data = energy_data\n    else:\n        filtered_data = energy_data\n\n    # Create report generator\n    report_generator = EnergyReportGenerator(filtered_data, user_data)\n\n    # Generate report based on format\n    if format.lower() == 'csv':\n        return report_generator.create_csv_report()\n    else:\n        return report_generator.create_pdf_report()\n</code></pre>"},{"location":"api/#app.utils.report.report_utils","title":"<code>app.utils.report.report_utils</code>","text":"<p>Utilities for generating enhanced energy reports with visualizations and analytics</p>"},{"location":"api/#app.utils.report.report_utils.calculate_tiered_cost","title":"<code>app.utils.report.report_utils.calculate_tiered_cost(energy_consumption)</code>","text":"<p>Calculate energy cost using UAE's tiered pricing structure</p> <p>Parameters:</p> Name Type Description Default <code>energy_consumption</code> <code>float</code> <p>Total energy consumption in kWh</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated cost in AED</p> Source code in <code>app/utils/report/report_utils.py</code> <pre><code>def calculate_tiered_cost(energy_consumption: float) -&gt; float:\n    \"\"\"\n    Calculate energy cost using UAE's tiered pricing structure\n\n    Args:\n        energy_consumption (float): Total energy consumption in kWh\n\n    Returns:\n        float: Estimated cost in AED\n    \"\"\"\n    # Convert kWh tiers to actual kWh values\n    # These are rough estimates and should be adjusted based on actual utility rates\n    tier1_limit = 2000 / 0.23  # ~8696 kWh\n    tier2_limit = 4000 / 0.28  # ~14286 kWh\n    tier3_limit = 6000 / 0.32  # ~18750 kWh\n\n    if energy_consumption &lt;= tier1_limit:\n        return energy_consumption * 0.23\n    elif energy_consumption &lt;= tier2_limit:\n        return (tier1_limit * 0.23) + ((energy_consumption - tier1_limit) * 0.28)\n    elif energy_consumption &lt;= tier3_limit:\n        return (tier1_limit * 0.23) + ((tier2_limit - tier1_limit) * 0.28) + ((energy_consumption - tier2_limit) * 0.32)\n    else:\n        return (tier1_limit * 0.23) + ((tier2_limit - tier1_limit) * 0.28) + ((tier3_limit - tier2_limit) * 0.32) + ((energy_consumption - tier3_limit) * 0.36)\n</code></pre>"},{"location":"api/#app.utils.report.report_utils.generate_enhanced_csv_report","title":"<code>app.utils.report.report_utils.generate_enhanced_csv_report(energy_data, user_data=None, start_date=None, end_date=None)</code>","text":"<p>Generate a comprehensive CSV report with multiple tables</p> <p>Parameters:</p> Name Type Description Default <code>energy_data</code> <code>List[Dict]</code> <p>Energy consumption records</p> required <code>user_data</code> <code>Optional[Dict]</code> <p>User information for personalization</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>Start date for filtering data</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>End date for filtering data</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated CSV report</p> Source code in <code>app/utils/report/report_utils.py</code> <pre><code>def generate_enhanced_csv_report(\n    energy_data: List[Dict], \n    user_data: Optional[Dict] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n) -&gt; str:\n    \"\"\"\n    Generate a comprehensive CSV report with multiple tables\n\n    Args:\n        energy_data (List[Dict]): Energy consumption records\n        user_data (Optional[Dict]): User information for personalization\n        start_date (Optional[str]): Start date for filtering data\n        end_date (Optional[str]): End date for filtering data\n\n    Returns:\n        str: Path to the generated CSV report\n    \"\"\"\n    # Generate report filename\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.csv\"\n\n    # Convert to DataFrame for analysis\n    df = pd.DataFrame(energy_data)\n\n    # Ensure timestamp is datetime\n    if 'timestamp' in df.columns:\n        df['timestamp'] = pd.to_datetime(df['timestamp'])\n        df.sort_values('timestamp', inplace=True)\n\n    # Create a CSV with multiple sections\n    with open(filename, 'w') as f:\n        # Section 1: Summary\n        f.write(\"ENERGY CONSUMPTION SUMMARY\\n\")\n        f.write(f\"Generated on,{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n\n        if user_data and user_data.get('email'):\n            f.write(f\"User,{user_data.get('email')}\\n\")\n\n        total_energy = df['energy_consumed'].sum() if 'energy_consumed' in df.columns else 0\n        total_cost = calculate_tiered_cost(total_energy)\n\n        f.write(f\"Total Energy Consumption (kWh),{total_energy:.2f}\\n\")\n        f.write(f\"Estimated Cost (AED),{total_cost:.2f}\\n\")\n\n        if 'timestamp' in df.columns and not df.empty:\n            start_date_str = df['timestamp'].min().strftime(\"%Y-%m-%d\")\n            end_date_str = df['timestamp'].max().strftime(\"%Y-%m-%d\")\n            f.write(f\"Date Range,{start_date_str} to {end_date_str}\\n\")\n\n        f.write(\"\\n\\n\")\n\n        # Section 2: Daily Consumption\n        f.write(\"DAILY ENERGY CONSUMPTION\\n\")\n        if 'timestamp' in df.columns and 'energy_consumed' in df.columns:\n            daily_data = df.groupby(pd.Grouper(key='timestamp', freq='D'))['energy_consumed'].sum().reset_index()\n            daily_data['date'] = daily_data['timestamp'].dt.strftime('%Y-%m-%d')\n            daily_data['change_pct'] = daily_data['energy_consumed'].pct_change() * 100\n            daily_data = daily_data.fillna(0)\n\n            f.write(\"Date,Energy (kWh),Day-over-Day Change (%),Estimated Cost (AED)\\n\")\n            for _, row in daily_data.iterrows():\n                f.write(f\"{row['date']},{row['energy_consumed']:.2f},{row['change_pct']:.1f},{row['energy_consumed'] * DEFAULT_ENERGY_COST:.2f}\\n\")\n        else:\n            f.write(\"No daily consumption data available.\\n\")\n\n        f.write(\"\\n\\n\")\n\n        # Section 3: Device Breakdown\n        f.write(\"DEVICE ENERGY CONSUMPTION\\n\")\n        if 'device_id' in df.columns and 'energy_consumed' in df.columns:\n            device_usage = df.groupby('device_id')['energy_consumed'].sum().reset_index()\n            device_names = get_device_names(device_usage['device_id'].unique())\n            device_usage['device_name'] = device_usage['device_id'].map(device_names)\n\n            # Calculate percentage and cost\n            total = device_usage['energy_consumed'].sum()\n            if total &gt; 0:\n                device_usage['percentage'] = (device_usage['energy_consumed'] / total) * 100\n                device_usage['cost'] = device_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n\n                f.write(\"Device,Energy (kWh),Percentage (%),Estimated Cost (AED)\\n\")\n                for _, row in device_usage.sort_values('energy_consumed', ascending=False).iterrows():\n                    f.write(f\"{row['device_name']},{row['energy_consumed']:.2f},{row['percentage']:.1f},{row['cost']:.2f}\\n\")\n            else:\n                f.write(\"No device consumption data available.\\n\")\n        else:\n            f.write(\"No device information available.\\n\")\n\n        f.write(\"\\n\\n\")\n\n        # Section 4: Hourly Patterns\n        f.write(\"HOURLY ENERGY CONSUMPTION PATTERNS\\n\")\n        if 'timestamp' in df.columns and 'energy_consumed' in df.columns:\n            df['hour'] = df['timestamp'].dt.hour\n            hourly_usage = df.groupby('hour')['energy_consumed'].sum().reset_index()\n\n            if not hourly_usage.empty:\n                f.write(\"Hour,Energy (kWh),Percentage of Total (%)\\n\")\n                total = hourly_usage['energy_consumed'].sum()\n                for _, row in hourly_usage.sort_values('hour').iterrows():\n                    percentage = (row['energy_consumed'] / total) * 100 if total &gt; 0 else 0\n                    f.write(f\"{int(row['hour'])}:00,{row['energy_consumed']:.2f},{percentage:.1f}\\n\")\n            else:\n                f.write(\"No hourly pattern data available.\\n\")\n        else:\n            f.write(\"No timestamp information available for hourly analysis.\\n\")\n\n        f.write(\"\\n\\n\")\n\n        # Section 5: Location Analysis (if available)\n        if 'location' in df.columns and 'energy_consumed' in df.columns:\n            f.write(\"LOCATION ENERGY CONSUMPTION\\n\")\n            df_loc = df.copy()\n            df_loc['location'] = df_loc['location'].fillna('Unknown')\n            location_usage = df_loc.groupby('location')['energy_consumed'].sum().reset_index()\n\n            if not location_usage.empty:\n                total = location_usage['energy_consumed'].sum()\n                if total &gt; 0:\n                    location_usage['percentage'] = (location_usage['energy_consumed'] / total) * 100\n                    location_usage['cost'] = location_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n\n                    f.write(\"Location,Energy (kWh),Percentage (%),Estimated Cost (AED)\\n\")\n                    for _, row in location_usage.sort_values('energy_consumed', ascending=False).iterrows():\n                        f.write(f\"{row['location']},{row['energy_consumed']:.2f},{row['percentage']:.1f},{row['cost']:.2f}\\n\")\n                else:\n                    f.write(\"No location consumption data available.\\n\")\n            else:\n                f.write(\"No location data available.\\n\")\n\n            f.write(\"\\n\\n\")\n\n        # Section 6: Raw Data\n        f.write(\"RAW ENERGY CONSUMPTION DATA\\n\")\n        if not df.empty:\n            # Create a copy of the DataFrame for output\n            output_df = df.copy()\n\n            # Format timestamp for readability if it exists\n            if 'timestamp' in output_df.columns:\n                output_df['timestamp'] = output_df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')\n\n            # Write header\n            headers = ','.join(output_df.columns)\n            f.write(f\"{headers}\\n\")\n\n            # Write data rows\n            for _, row in output_df.iterrows():\n                f.write(','.join([str(value) for value in row.values]) + '\\n')\n        else:\n            f.write(\"No raw data available.\\n\")\n\n    return filename\n</code></pre>"},{"location":"api/#app.utils.report.report_utils.generate_enhanced_pdf_report","title":"<code>app.utils.report.report_utils.generate_enhanced_pdf_report(energy_data, user_data=None, start_date=None, end_date=None)</code>","text":"<p>Generate a comprehensive PDF report with visualizations</p> <p>Parameters:</p> Name Type Description Default <code>energy_data</code> <code>List[Dict]</code> <p>Energy consumption records</p> required <code>user_data</code> <code>Optional[Dict]</code> <p>User information for personalization</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>Start date for filtering data</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>End date for filtering data</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated PDF report</p> Source code in <code>app/utils/report/report_utils.py</code> <pre><code>def generate_enhanced_pdf_report(\n    energy_data: List[Dict], \n    user_data: Optional[Dict] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n) -&gt; str:\n    \"\"\"\n    Generate a comprehensive PDF report with visualizations\n\n    Args:\n        energy_data (List[Dict]): Energy consumption records\n        user_data (Optional[Dict]): User information for personalization\n        start_date (Optional[str]): Start date for filtering data\n        end_date (Optional[str]): End date for filtering data\n\n    Returns:\n        str: Path to the generated PDF report\n    \"\"\"\n    # Generate report filename\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.pdf\"\n\n    # Convert to DataFrame for analysis\n    df = pd.DataFrame(energy_data)\n\n    # Ensure timestamp is datetime\n    if 'timestamp' in df.columns:\n        df['timestamp'] = pd.to_datetime(df['timestamp'])\n        df.sort_values('timestamp', inplace=True)\n\n    # Create the PDF document\n    doc = SimpleDocTemplate(filename, pagesize=A4)\n    styles = getSampleStyleSheet()\n\n    # Create a title style\n    title_style = ParagraphStyle(\n        'Title',\n        parent=styles['Heading1'],\n        fontSize=18,\n        alignment=1,  # Center alignment\n        spaceAfter=12\n    )\n\n    # Create a subtitle style\n    subtitle_style = ParagraphStyle(\n        'Subtitle',\n        parent=styles['Heading2'],\n        fontSize=14,\n        spaceAfter=10\n    )\n\n    # Create normal text style\n    normal_style = styles['Normal']\n\n    # Start building the document\n    elements = []\n\n    # Title and introduction\n    elements.append(Paragraph(\"Smart Home Energy Consumption Report\", title_style))\n    elements.append(Spacer(1, 0.2 * inch))\n\n    report_date = datetime.now().strftime(\"%B %d, %Y\")\n\n    # Add user info if available\n    if user_data and user_data.get('email'):\n        elements.append(Paragraph(f\"Report for: {user_data.get('email')}\", normal_style))\n\n    elements.append(Paragraph(f\"Generated on: {report_date}\", normal_style))\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Summary section\n    elements.append(Paragraph(\"Summary\", subtitle_style))\n\n    # Calculate total energy and cost\n    total_energy = df['energy_consumed'].sum() if 'energy_consumed' in df.columns else 0\n    total_cost = calculate_tiered_cost(total_energy)\n\n    summary_data = [\n        [\"Total Energy Consumption\", f\"{total_energy:.2f} kWh\"],\n        [\"Estimated Cost\", f\"{total_cost:.2f} AED\"],\n    ]\n\n    # Add date range if available\n    if 'timestamp' in df.columns and not df.empty:\n        start_date_str = df['timestamp'].min().strftime(\"%Y-%m-%d\")\n        end_date_str = df['timestamp'].max().strftime(\"%Y-%m-%d\")\n        summary_data.append([\"Date Range\", f\"{start_date_str} to {end_date_str}\"])\n\n    summary_table = Table(summary_data, colWidths=[2.5*inch, 2.5*inch])\n    summary_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n        ('PADDING', (0, 0), (-1, -1), 6),\n    ]))\n    elements.append(summary_table)\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Add trend analysis\n    elements.append(Paragraph(\"Energy Consumption Trends\", subtitle_style))\n\n    if 'timestamp' in df.columns and len(df) &gt; 1 and 'energy_consumed' in df.columns:\n        # Group by day\n        daily_data = df.groupby(pd.Grouper(key='timestamp', freq='D'))['energy_consumed'].sum().reset_index()\n\n        if len(daily_data) &gt; 1:\n            # Create trend visualization\n            plt.figure(figsize=(8, 4))\n            plt.plot(daily_data['timestamp'], daily_data['energy_consumed'], marker='o', linestyle='-')\n            plt.xlabel('Date')\n            plt.ylabel('Energy (kWh)')\n            plt.title('Daily Energy Consumption')\n            plt.grid(True, alpha=0.3)\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Add trend insights\n            if len(daily_data) &gt; 1:\n                daily_data['change'] = daily_data['energy_consumed'].pct_change() * 100\n                avg_change = daily_data['change'].mean()\n                if not np.isnan(avg_change):\n                    trend_text = f\"Your average daily change in energy consumption is {avg_change:.1f}%.\"\n                    elements.append(Paragraph(trend_text, normal_style))\n\n                # Identify highest and lowest consumption days\n                max_day = daily_data.loc[daily_data['energy_consumed'].idxmax()]\n                min_day = daily_data.loc[daily_data['energy_consumed'].idxmin()]\n                elements.append(Paragraph(f\"Highest usage: {max_day['energy_consumed']:.2f} kWh on {max_day['timestamp'].strftime('%Y-%m-%d')}\", normal_style))\n                elements.append(Paragraph(f\"Lowest usage: {min_day['energy_consumed']:.2f} kWh on {min_day['timestamp'].strftime('%Y-%m-%d')}\", normal_style))\n        else:\n            elements.append(Paragraph(\"Insufficient data to analyze trends. At least two days of data are required.\", normal_style))\n    else:\n        elements.append(Paragraph(\"Insufficient data to analyze trends.\", normal_style))\n\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Device breakdown\n    elements.append(Paragraph(\"Energy Consumption by Device\", subtitle_style))\n\n    if 'device_id' in df.columns and 'energy_consumed' in df.columns:\n        device_usage = df.groupby('device_id')['energy_consumed'].sum().reset_index()\n\n        if not device_usage.empty:\n            # Get device names\n            device_names = get_device_names(device_usage['device_id'].unique())\n            device_usage['device_name'] = device_usage['device_id'].map(device_names)\n\n            # Sort by energy consumed (descending)\n            device_usage = device_usage.sort_values('energy_consumed', ascending=False)\n\n            # Calculate percentage of total\n            total = device_usage['energy_consumed'].sum()\n            if total &gt; 0:\n                device_usage['percentage'] = (device_usage['energy_consumed'] / total) * 100\n                device_usage['cost'] = device_usage['energy_consumed'] * DEFAULT_ENERGY_COST\n\n                # Create pie chart for top devices\n                if len(device_usage) &gt; 6:\n                    # Show top 5 + \"Others\"\n                    top_devices = device_usage.head(5)\n                    others_energy = device_usage.iloc[5:]['energy_consumed'].sum()\n\n                    # Create a new DataFrame with Others row\n                    pie_data = pd.concat([\n                        top_devices,\n                        pd.DataFrame({\n                            'device_id': ['others'],\n                            'energy_consumed': [others_energy],\n                            'device_name': ['Others'],\n                            'percentage': [(others_energy / total) * 100],\n                            'cost': [others_energy * DEFAULT_ENERGY_COST]\n                        })\n                    ])\n                else:\n                    pie_data = device_usage\n\n                # Create pie chart\n                plt.figure(figsize=(8, 5))\n\n                # Use device names for better readability\n                labels = pie_data['device_name'].tolist()\n                sizes = pie_data['energy_consumed'].tolist()\n                explode = [0.1 if i == 0 else 0 for i in range(len(labels))]  # Explode the largest slice\n\n                plt.pie(sizes, labels=labels, explode=explode, autopct='%1.1f%%', \n                        shadow=True, startangle=90)\n                plt.axis('equal')\n                plt.title('Energy Consumption by Device')\n                plt.tight_layout()\n\n                # Save the plot to a BytesIO object\n                img_data = BytesIO()\n                plt.savefig(img_data, format='png')\n                img_data.seek(0)\n                plt.close()\n\n                # Add the image to the PDF\n                img = Image(img_data, width=6*inch, height=4*inch)\n                elements.append(img)\n                elements.append(Spacer(1, 0.2 * inch))\n\n                # Add table with detailed breakdown\n                device_table_data = [[\"Device\", \"Energy (kWh)\", \"Percentage\", \"Cost (AED)\"]]\n                for _, row in device_usage.iterrows():\n                    device_table_data.append([\n                        row['device_name'],\n                        f\"{row['energy_consumed']:.2f}\",\n                        f\"{row['percentage']:.1f}%\",\n                        f\"{row['cost']:.2f}\"\n                    ])\n\n                device_table = Table(device_table_data, colWidths=[1.5*inch, 1.5*inch, 1.5*inch, 1.5*inch])\n                device_table.setStyle(TableStyle([\n                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),\n                    ('GRID', (0, 0), (-1, -1), 1, colors.black),\n                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                    ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),\n                    ('PADDING', (0, 0), (-1, -1), 6),\n                ]))\n                elements.append(device_table)\n\n                # Add insights\n                elements.append(Spacer(1, 0.2 * inch))\n                top_device = device_usage.iloc[0]\n                elements.append(Paragraph(\n                    f\"Your {top_device['device_name']} is using {top_device['percentage']:.1f}% of your total energy. \"\n                    f\"This costs approximately {top_device['cost']:.2f} AED during this period.\", \n                    normal_style\n                ))\n            else:\n                elements.append(Paragraph(\"No energy consumption recorded for any device.\", normal_style))\n        else:\n            elements.append(Paragraph(\"No device data available.\", normal_style))\n    else:\n        elements.append(Paragraph(\"Device information not available in the data.\", normal_style))\n\n    elements.append(Spacer(1, 0.3 * inch))\n\n    # Usage patterns by time of day\n    elements.append(Paragraph(\"Usage Patterns by Hour of Day\", subtitle_style))\n\n    if 'timestamp' in df.columns and 'energy_consumed' in df.columns:\n        # Extract hour from timestamp\n        df['hour'] = df['timestamp'].dt.hour\n\n        # Group by hour\n        hourly_usage = df.groupby('hour')['energy_consumed'].sum().reset_index()\n\n        if not hourly_usage.empty:\n            # Sort by hour for visualization\n            hourly_usage = hourly_usage.sort_values('hour')\n\n            # Create bar chart\n            plt.figure(figsize=(8, 4))\n            plt.bar(hourly_usage['hour'], hourly_usage['energy_consumed'], color='skyblue')\n            plt.xlabel('Hour of Day')\n            plt.ylabel('Energy Consumption (kWh)')\n            plt.title('Energy Consumption by Hour of Day')\n            plt.xticks(range(0, 24, 2))\n            plt.grid(True, alpha=0.3, axis='y')\n            plt.tight_layout()\n\n            # Save the plot to a BytesIO object\n            img_data = BytesIO()\n            plt.savefig(img_data, format='png')\n            img_data.seek(0)\n            plt.close()\n\n            # Add the image to the PDF\n            img = Image(img_data, width=6*inch, height=3*inch)\n            elements.append(img)\n            elements.append(Spacer(1, 0.2 * inch))\n\n            # Identify peak usage hours\n            sorted_hours = hourly_usage.sort_values('energy_consumed', ascending=False)\n            peak_hours = sorted_hours.head(3)\n\n            # Format peak hours for display (e.g., \"18:00\" instead of just \"18\")\n            peak_hours_str = \", \".join([f\"{int(hour)}:00\" for hour in peak_hours['hour']])\n            elements.append(Paragraph(f\"Your peak energy usage occurs at: {peak_hours_str}\", normal_style))\n\n            # Add recommendations based on peak hours\n            if any(h in peak_hours['hour'].values for h in [17, 18, 19, 20]):  # Evening peak hours\n                elements.append(Paragraph(\n                    \"You have high energy usage during evening peak hours. Consider shifting some activities to off-peak times to reduce energy costs.\",\n                    normal_style\n                ))\n        else:\n            elements.append(Paragraph(\"Insufficient data to analyze hourly usage patterns.\", normal_style))\n    else:\n        elements.append(Paragraph(\"Timestamp information not available for hourly analysis.\", normal_style))\n\n    elements.append(PageBreak())\n\n    # Location-based analysis (if available)\n    if 'location' in df.columns and 'energy_consumed' in df.columns:\n        elements.append(Paragraph(\"Energy Consumption by Location\", subtitle_style))\n\n        # Fill missing locations\n        df_loc = df.copy()\n        df_loc['location'] = df_loc['location'].fillna('Unknown')\n\n        # Group by location\n        location_usage = df_loc.groupby('location')['energy_consumed'].sum().reset_index()\n\n        if not location_usage.empty and len(location_usage) &gt; 1:  # Only show if multiple locations\n            # Sort by energy consumed (descending)\n            location_usage = location_usage.sort_values('energy_consumed', ascending=False)\n\n            # Calculate percentage\n            total = location_usage['energy_consumed'].sum()\n            if total &gt; 0:\n                location_usage['percentage'] = (location_usage['energy_consumed'] / total) * 100\n\n                # Create bar chart\n                plt.figure(figsize=(8, 4))\n                bars = plt.bar(location_usage['location'], location_usage['energy_consumed'], color='lightgreen')\n                plt.xlabel('Location')\n                plt.ylabel('Energy Consumption (kWh)')\n                plt.title('Energy Consumption by Location')\n                plt.xticks(rotation=45, ha='right')\n                plt.grid(True, alpha=0.3, axis='y')\n                plt.tight_layout()\n\n                # Add percentage labels on bars\n                for bar, percentage in zip(bars, location_usage['percentage']):\n                    plt.text(\n                        bar.get_x() + bar.get_width()/2,\n                        bar.get_height() + 0.1,\n                        f\"{percentage:.1f}%\",\n                        ha='center'\n                    )\n\n                # Save the plot to a BytesIO object\n                img_data = BytesIO()\n                plt.savefig(img_data, format='png')\n                img_data.seek(0)\n                plt.close()\n\n                # Add the image to the PDF\n                img = Image(img_data, width=6*inch, height=3*inch)\n                elements.append(img)\n                elements.append(Spacer(1, 0.2 * inch))\n\n                # Add insights\n                top_location = location_usage.iloc[0]\n                elements.append(Paragraph(\n                    f\"Your highest energy consumption is in the {top_location['location']} area, \"\n                    f\"accounting for {top_location['percentage']:.1f}% of your total energy use.\",\n                    normal_style\n                ))\n            else:\n                elements.append(Paragraph(\"No energy consumption recorded for any location.\", normal_style))\n        else:\n            elements.append(Paragraph(\"Insufficient location data for analysis.\", normal_style))\n\n        elements.append(Spacer(1, 0.3 * inch))\n\n    # Energy-saving recommendations\n    elements.append(Paragraph(\"Energy Saving Recommendations\", subtitle_style))\n\n    # Generate general recommendations\n    recommendations = [\n        \"Install LED bulbs which use up to 80% less energy than traditional incandescent bulbs.\",\n        \"Use smart power strips to eliminate phantom energy use from devices on standby.\",\n        \"Set your air conditioner to 24\u00b0C or higher during summer to optimize energy efficiency.\",\n        \"Clean or replace AC filters regularly to maintain efficiency and reduce energy consumption.\",\n        \"Use natural light when possible and turn off lights when leaving a room.\"\n    ]\n\n    # Add personalized recommendations based on data analysis\n    if 'device_id' in df.columns and 'energy_consumed' in df.columns:\n        device_usage = df.groupby('device_id')['energy_consumed'].sum().reset_index()\n\n        if not device_usage.empty:\n            device_names = get_device_names(device_usage['device_id'].unique())\n            device_usage['device_name'] = device_usage['device_id'].map(device_names)\n            top_device = device_usage.sort_values('energy_consumed', ascending=False).iloc[0]\n\n            # Add device-specific recommendation\n            if \"ac\" in top_device['device_id'].lower() or \"air\" in top_device['device_id'].lower():\n                recommendations.append(\n                    f\"Your {top_device['device_name']} is your highest energy consumer. Consider setting the temperature \"\n                    f\"1-2 degrees higher to save up to 10% on cooling costs.\"\n                )\n            elif \"refrigerator\" in top_device['device_name'].lower() or \"fridge\" in top_device['device_name'].lower():\n                recommendations.append(\n                    f\"Your {top_device['device_name']} is using a significant amount of energy. Ensure the door seals are tight, \"\n                    f\"and the temperature is set to the manufacturer's recommended level (usually 3-4\u00b0C for the fridge and -18\u00b0C for the freezer).\"\n                )\n            elif \"water\" in top_device['device_name'].lower():\n                recommendations.append(\n                    f\"Your {top_device['device_name']} is a major energy consumer. Consider lowering the temperature setting \"\n                    f\"or installing a timer to heat water only when needed.\"\n                )\n            else:\n                recommendations.append(\n                    f\"Your {top_device['device_name']} is your highest energy consumer. Consider upgrading to a more \"\n                    f\"energy-efficient model or adjusting usage patterns.\"\n                )\n\n    # Add time-based recommendation based on hourly analysis\n    if 'timestamp' in df.columns and 'energy_consumed' in df.columns:\n        df['hour'] = df['timestamp'].dt.hour\n        hourly_usage = df.groupby('hour')['energy_consumed'].sum().reset_index()\n\n        if not hourly_usage.empty:\n            peak_hour = hourly_usage.loc[hourly_usage['energy_consumed'].idxmax(), 'hour']\n            recommendations.append(\n                f\"Your peak energy usage occurs around {int(peak_hour)}:00. Try to shift energy-intensive \"\n                f\"activities to off-peak hours to reduce demand charges and overall energy costs.\"\n            )\n\n    # Add weekly pattern recommendation\n    if 'timestamp' in df.columns and 'energy_consumed' in df.columns:\n        df['day_of_week'] = df['timestamp'].dt.dayofweek  # 0=Monday, 6=Sunday\n        daily_usage = df.groupby('day_of_week')['energy_consumed'].sum().reset_index()\n\n        if not daily_usage.empty:\n            peak_day_num = daily_usage.loc[daily_usage['energy_consumed'].idxmax(), 'day_of_week']\n            days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n            peak_day = days[peak_day_num]\n\n            recommendations.append(\n                f\"Your highest energy consumption is on {peak_day}. Consider rescheduling energy-intensive \"\n                f\"activities to distribute energy usage more evenly throughout the week.\"\n            )\n\n    # Add the recommendations to the PDF\n    for i, recommendation in enumerate(recommendations, 1):\n        elements.append(Paragraph(f\"{i}. {recommendation}\", normal_style))\n        elements.append(Spacer(1, 0.1 * inch))\n\n    # Build the PDF\n    doc.build(elements)\n\n    return filename\n</code></pre>"},{"location":"api/#app.utils.report.report_utils.generate_enhanced_report","title":"<code>app.utils.report.report_utils.generate_enhanced_report(energy_data, format='pdf', user_data=None, start_date=None, end_date=None)</code>","text":"<p>Generate an enhanced energy report in the specified format</p> <p>Parameters:</p> Name Type Description Default <code>energy_data</code> <code>List[Dict]</code> <p>Energy consumption records</p> required <code>format</code> <code>str</code> <p>Report format ('pdf' or 'csv')</p> <code>'pdf'</code> <code>user_data</code> <code>Optional[Dict]</code> <p>User information for personalization</p> <code>None</code> <code>start_date</code> <code>Optional[str]</code> <p>Start date for filtering data</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>End date for filtering data</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated report</p> Source code in <code>app/utils/report/report_utils.py</code> <pre><code>def generate_enhanced_report(\n    energy_data: List[Dict], \n    format: str = 'pdf',\n    user_data: Optional[Dict] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n) -&gt; str:\n    \"\"\"\n    Generate an enhanced energy report in the specified format\n\n    Args:\n        energy_data (List[Dict]): Energy consumption records\n        format (str): Report format ('pdf' or 'csv')\n        user_data (Optional[Dict]): User information for personalization\n        start_date (Optional[str]): Start date for filtering data\n        end_date (Optional[str]): End date for filtering data\n\n    Returns:\n        str: Path to the generated report\n    \"\"\"\n    if format.lower() == 'csv':\n        return generate_enhanced_csv_report(energy_data, user_data, start_date, end_date)\n    else:\n        return generate_enhanced_pdf_report(energy_data, user_data, start_date, end_date)\n</code></pre>"},{"location":"api/#app.utils.report.report_utils.get_device_names","title":"<code>app.utils.report.report_utils.get_device_names(device_ids)</code>","text":"<p>Generate readable device names from device IDs This is a placeholder - in a real implementation, you would query the devices collection</p> <p>Parameters:</p> Name Type Description Default <code>device_ids</code> <code>List[str]</code> <p>List of device IDs</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: Mapping of device_id to readable name</p> Source code in <code>app/utils/report/report_utils.py</code> <pre><code>def get_device_names(device_ids: List[str]) -&gt; Dict[str, str]:\n    \"\"\"\n    Generate readable device names from device IDs\n    This is a placeholder - in a real implementation, you would query the devices collection\n\n    Args:\n        device_ids (List[str]): List of device IDs\n\n    Returns:\n        Dict[str, str]: Mapping of device_id to readable name\n    \"\"\"\n    # In production, this would query your devices collection\n    # For now, generate readable names based on ID\n    device_names = {}\n    for i, device_id in enumerate(device_ids):\n        if \"light\" in device_id.lower():\n            device_names[device_id] = f\"Light {i+1}\"\n        elif \"therm\" in device_id.lower():\n            device_names[device_id] = f\"Thermostat {i+1}\"\n        elif \"fridge\" in device_id.lower() or \"refrig\" in device_id.lower():\n            device_names[device_id] = f\"Refrigerator {i+1}\"\n        elif \"tv\" in device_id.lower() or \"television\" in device_id.lower():\n            device_names[device_id] = f\"Television {i+1}\"\n        elif \"ac\" in device_id.lower() or \"air\" in device_id.lower():\n            device_names[device_id] = f\"Air Conditioner {i+1}\"\n        elif \"wash\" in device_id.lower():\n            device_names[device_id] = f\"Washing Machine {i+1}\"\n        elif \"dryer\" in device_id.lower():\n            device_names[device_id] = f\"Dryer {i+1}\"\n        elif \"oven\" in device_id.lower() or \"stove\" in device_id.lower():\n            device_names[device_id] = f\"Oven/Stove {i+1}\"\n        elif \"dishwash\" in device_id.lower():\n            device_names[device_id] = f\"Dishwasher {i+1}\"\n        elif \"water\" in device_id.lower():\n            device_names[device_id] = f\"Water Heater {i+1}\"\n        else:\n            device_names[device_id] = f\"Device {i+1}\"\n\n    return device_names\n</code></pre>"}]}