{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sync Smart Home API Documentation","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#app.main","title":"<code>app.main</code>","text":"<p>This module acts as a middlepoint between the database and the frontend.</p>"},{"location":"api/#app.main.lifespan","title":"<code>app.main.lifespan(app_context)</code>  <code>async</code>","text":"<p>Defines application lifespan event handler</p> Source code in <code>app/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app_context: FastAPI):\n    \"\"\"Defines application lifespan event handler\"\"\"\n    try:\n        await init_db()\n        app_context.state.custom_attribute = \"value\"    # Placeholder for future app-wide state\n        logger.info(\"Application startup complete.\")\n        yield\n    except Exception as e:\n        logger.error(\"Failed to initialize the database: %e.\")\n        raise e\n    finally:\n        logger.info(\"Application is shutting down.\")\n</code></pre>"},{"location":"api/#app.main.read_root","title":"<code>app.main.read_root()</code>","text":"<p>Root endpoint.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/\", response_model = RootResponse)\ndef read_root() -&gt; RootResponse:\n    \"\"\"Root endpoint.\"\"\"\n    return RootResponse(message = \"Welcome to the Sync Smart Home.\")\n</code></pre>"},{"location":"api/#app.routes.user_routes","title":"<code>app.routes.user_routes</code>","text":"<p>This module routes data to the database from registration</p>"},{"location":"api/#app.routes.user_routes.login","title":"<code>app.routes.user_routes.login(form_data=Depends())</code>  <code>async</code>","text":"<p>Authenticate user &amp; return a JWT token.</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.post(\"/token\")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"\n    Authenticate user &amp; return a JWT token.\n    \"\"\"\n    user = users_collection.find_one({\"email\": form_data.username})\n    if not user or not verify_password(form_data.password, user[\"password_hash\"]):\n        raise HTTPException(status_code = 400, detail = \"Invalid username or password\")\n\n    access_token = create_access_token(\n        data = {\"sub\": user[\"email\"], \"role\": user.get(\"role\", \"user\")},\n        expires_delta = timedelta(minutes = 30)\n    )\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"api/#app.routes.user_routes.register_user","title":"<code>app.routes.user_routes.register_user(user)</code>  <code>async</code>","text":"<p>Registers a new user to the database.</p> Source code in <code>app/routes/user_routes.py</code> <pre><code>@router.post(\"/register\", response_model = UserResponse)\nasync def register_user(user: UserCreate):\n    \"\"\"Registers a new user to the database.\"\"\"\n    # Check if email exists already\n    if users_collection.find_one({\"email\": user.email}):\n        raise HTTPException(status_code = 400, detail = \"Registration failed, please try again.\")\n\n    # Data that will be collected\n    user_data = {\n        \"email\": user.email,\n        \"password_hash\": hash_password(user.password),\n        \"is_verified\": False,\n        \"created_at\": datetime.now(timezone.utc),\n        \"updated_at\": datetime.now(timezone.utc),\n        \"role\": user.role or \"user\"\n    }\n\n    # Database user insert\n    try:\n        result = users_collection.insert_one(user_data)\n    except Exception as e:\n        raise HTTPException(status_code = 500, detail = f\"Failed to register user: {e}\") from e\n\n    return UserResponse(\n        id = str(result.inserted_id),\n        role = user_data[\"role\"],\n        email = user.email,\n        is_verified = False,\n        created_at = user_data[\"created_at\"]\n    )\n</code></pre>"},{"location":"api/#app.routes.data_routes","title":"<code>app.routes.data_routes</code>","text":""},{"location":"api/#app.routes.data_routes.add_energy_data","title":"<code>app.routes.data_routes.add_energy_data(data)</code>  <code>async</code>","text":"<p>API to add new energy data to the database.</p> Source code in <code>app/routes/data_routes.py</code> <pre><code>@router.post(\"/add\", dependencies = [Depends(role_required(\"admin\"))])\nasync def add_energy_data(data: EnergyData):\n    \"\"\"API to add new energy data to the database.\"\"\"\n    # energy_collection.insert_one(data.dict())       # Insert into MongoDB\n    energy_collection.insert_one(data.model_dump())       # Insert into MongoDB\n    return {\"message\": \"Energy data added successfully\"}\n</code></pre>"},{"location":"api/#app.routes.data_routes.get_aggregated_data","title":"<code>app.routes.data_routes.get_aggregated_data(start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'), device_id=Query(None, description='Device ID filter'), location=Query(None, description='Location filter'), interval='day')</code>  <code>async</code>","text":"<p>Fetch aggregated energy data based on filters</p> Source code in <code>app/routes/data_routes.py</code> <pre><code>@router.get(\"/aggregate\")\nasync def get_aggregated_data(\n    start_date: Optional[str] = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n    end_date: Optional[str] = Query(None, description = \"End date (YYYY-MM-DD)\"),\n    device_id: Optional[str] = Query(None, description = \"Device ID filter\"),\n    location: Optional[str] = Query(None, description = \"Location filter\"),\n    interval: Literal[\"hour\", \"day\", \"week\"] = \"day\",\n):\n    \"\"\"Fetch aggregated energy data based on filters\"\"\"\n    query = {}\n\n    if start_date and end_date:\n        query[\"timestamp\"] = {\n            \"$gte\": datetime.strptime(start_date, \"%Y-%m-%d\"),\n            \"$lte\": datetime.strptime(end_date, \"%Y-%m-%d\")\n        }\n    if device_id:\n        query[\"device_id\"] = device_id\n    if location:\n        query[\"location\"] = location\n\n    time_group = {\n        \"year\": {\"$year\": \"$timestamp\"},\n        \"month\": {\"$month\": \"$timestamp\"},\n        \"day\": {\"$dayOfMonth\": \"$timestamp\"}\n    }\n\n    if interval == \"hour\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"month\": {\"$month\": \"$timestamp\"},\n            \"day\": {\"$dayOfMonth\": \"$timestamp\"},\n            \"hour\": {\"$hour\": \"$timestamp\"}\n        }\n    elif interval == \"day\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"month\": {\"$month\": \"$timestamp\"},\n            \"day\": {\"$dayOfMonth\": \"$timestamp\"}\n        }\n    elif interval == \"week\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"week\": {\"$isoWeek\": \"$timestamp\"}\n        }\n\n    aggregation_pipeline = [\n        {\"$match\": query},\n        {\"$group\": {\n            \"_id\": {\n                \"device_id\": \"$device_id\",  # Group by device\n                **time_group                # Group by time interval\n            }, \"total_energy\": {\"$sum\": \"$energy_consumed\"}\n        }}\n    ]\n\n    result = list(energy_collection.aggregate(aggregation_pipeline))\n\n    return {\"aggregated_data\": result}\n</code></pre>"},{"location":"api/#app.routes.report_routes","title":"<code>app.routes.report_routes</code>","text":""},{"location":"api/#app.routes.report_routes.generate_report","title":"<code>app.routes.report_routes.generate_report(format=Query('csv', enum=['csv', 'pdf']), start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'))</code>  <code>async</code>","text":"<p>Generate an energy consumption report in CSV or PDF format, optionally filtered by date range.</p> Source code in <code>app/routes/report_routes.py</code> <pre><code>@router.post(\"/report\", dependencies = [Depends(role_required(\"admin\"))])\nasync def generate_report(\n        format: str = Query(\"csv\", enum = [\"csv\", \"pdf\"]),\n        start_date: str = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n        end_date: str = Query(None, description = \"End date (YYYY-MM-DD)\")\n):\n    \"\"\"\n    Generate an energy consumption report in CSV or PDF format,\n    optionally filtered by date range.\n    \"\"\"\n    try:\n        energy_data = get_energy_data(start_date, end_date)\n    except ValueError as exc:\n        raise HTTPException(status_code = 400, detail = str(exc)) from exc\n\n    if not energy_data:\n        raise HTTPException(status_code = 404, detail = \"No energy data available for the selected range.\")\n\n    timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.{format}\"\n\n    if format == \"csv\":\n        df = pd.DataFrame(energy_data)\n        df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"]).dt.strftime(\"%Y-%m-%d %H:%M:%S\")  # Format timestamp\n        df.columns = [\"Device ID\", \"Timestamp\", \"Energy Consumed (kWh)\", \"Location\"]\n        df.to_csv(filename, index = False)\n    elif format == \"pdf\":\n        doc = SimpleDocTemplate(filename, pagesize=letter)\n        elements = []\n\n        # Prepare table data\n        data = [[\"Device ID\", \"Timestamp\", \"Energy Cosumed (kWh)\", \"Location\"]]\n        for entry in energy_data:\n            data.append([\n                entry.get(\"device_id\", \"N/A\"),\n                entry.get(\"timestamp\", \"\").strftime('%Y-%m-%d %H:%M:%S') if entry.get(\"timestamp\") else \"N/A\",\n                entry.get(\"energy_consumed\", \"N/A\"),\n                entry.get(\"location\", \"N/A\")\n            ])\n\n        # Create &amp; style table\n        table = Table(data)\n        table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, 0), 12),\n            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.whitesmoke, colors.lightgrey])\n        ]))\n\n        elements.append(table)\n        doc.build(elements)\n\n    return FileResponse(\n        path  = os.path.abspath(filename),\n        filename = os.path.basename(filename),\n        media_type = \"application/octet-stream\"\n    )\n</code></pre>"},{"location":"api/#app.models.user","title":"<code>app.models.user</code>","text":"<p>This model defines user-related data models for account creation &amp; response handling</p> <p>It includes: - <code>UserCreate</code>: A model for user registration input with email &amp; password validation - <code>UserResponse</code>: A model for returning user details in API responses</p>"},{"location":"api/#app.models.user.UserCreate","title":"<code>app.models.user.UserCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for user registration input</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>EmailStr</code> <p>The user's email address</p> <code>password</code> <code>str</code> <p>The user's password (validated for strength)</p> <code>role</code> <code>Optional[str]</code> <p>The user's role, defaulting to \"user\"</p> Source code in <code>app/models/user.py</code> <pre><code>class UserCreate(BaseModel):\n    '''\n    Pydantic model for user registration input\n\n    Attributes:\n        email (EmailStr): The user's email address\n        password (str): The user's password (validated for strength)\n        role (Optional[str]): The user's role, defaulting to \"user\"\n    '''\n    email: EmailStr\n    password: str\n    role: Optional[str] = \"user\"    # Default role\n\n    @field_validator(\"password\")\n    @classmethod\n    def validate_password(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the password to ensure it meets security requirements\n\n        Args:\n            value (str): The password provided by the user\n\n        Returns:\n            str: The validated password\n\n        Raises:\n            ValueError: If the password doesn't meet security requirements\n        \"\"\"\n        if len(value) &lt; 8:\n            raise ValueError(\"Password must be at least 8 characters long.\")\n        if not any(char.isdigit() for char in value):\n            raise ValueError(\"Password must contain at least 1 number.\")\n        if not any(char.isalpha() for char in value):\n            raise ValueError(\"Password must contain at least 1 letter.\")\n        if not any(char.islower() for char in value):\n            raise ValueError(\"Password must contain at least 1 lower letter.\")\n        if not any(char.isupper() for char in value):\n            raise ValueError(\"Password must contain at least 1 upper letter.\")\n        if not any(char in '!@#$%^&amp;*()_+-=[]{}|;\\':\",.&lt;&gt;?/' for char in value):\n            raise ValueError(\"Password must contain at least 1 special character.\")\n        return value\n\n    @field_validator(\"email\")\n    @classmethod\n    def validate_email(cls, value: EmailStr) -&gt; EmailStr:\n        \"\"\"\n        Validate the user's email address\n\n        Args:\n            value (EmailStr): The email address provided\n\n        Returns:\n            EmailStr: The validated email\n\n        Raises:\n            ValueError: If the email doesn't contain `@` or a valid domain\n        \"\"\"\n        if not \"@\" in value:\n            raise ValueError(\"Email must contain @.\")\n        if not \".\" in value.split(\"@\")[1]:\n            raise ValueError(\"Email must contain a dot.\")\n        return value\n</code></pre>"},{"location":"api/#app.models.user.UserCreate.validate_email","title":"<code>app.models.user.UserCreate.validate_email(value)</code>  <code>classmethod</code>","text":"<p>Validate the user's email address</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>EmailStr</code> <p>The email address provided</p> required <p>Returns:</p> Name Type Description <code>EmailStr</code> <code>EmailStr</code> <p>The validated email</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the email doesn't contain <code>@</code> or a valid domain</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"email\")\n@classmethod\ndef validate_email(cls, value: EmailStr) -&gt; EmailStr:\n    \"\"\"\n    Validate the user's email address\n\n    Args:\n        value (EmailStr): The email address provided\n\n    Returns:\n        EmailStr: The validated email\n\n    Raises:\n        ValueError: If the email doesn't contain `@` or a valid domain\n    \"\"\"\n    if not \"@\" in value:\n        raise ValueError(\"Email must contain @.\")\n    if not \".\" in value.split(\"@\")[1]:\n        raise ValueError(\"Email must contain a dot.\")\n    return value\n</code></pre>"},{"location":"api/#app.models.user.UserCreate.validate_password","title":"<code>app.models.user.UserCreate.validate_password(value)</code>  <code>classmethod</code>","text":"<p>Validate the password to ensure it meets security requirements</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The password provided by the user</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated password</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the password doesn't meet security requirements</p> Source code in <code>app/models/user.py</code> <pre><code>@field_validator(\"password\")\n@classmethod\ndef validate_password(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the password to ensure it meets security requirements\n\n    Args:\n        value (str): The password provided by the user\n\n    Returns:\n        str: The validated password\n\n    Raises:\n        ValueError: If the password doesn't meet security requirements\n    \"\"\"\n    if len(value) &lt; 8:\n        raise ValueError(\"Password must be at least 8 characters long.\")\n    if not any(char.isdigit() for char in value):\n        raise ValueError(\"Password must contain at least 1 number.\")\n    if not any(char.isalpha() for char in value):\n        raise ValueError(\"Password must contain at least 1 letter.\")\n    if not any(char.islower() for char in value):\n        raise ValueError(\"Password must contain at least 1 lower letter.\")\n    if not any(char.isupper() for char in value):\n        raise ValueError(\"Password must contain at least 1 upper letter.\")\n    if not any(char in '!@#$%^&amp;*()_+-=[]{}|;\\':\",.&lt;&gt;?/' for char in value):\n        raise ValueError(\"Password must contain at least 1 special character.\")\n    return value\n</code></pre>"},{"location":"api/#app.models.user.UserResponse","title":"<code>app.models.user.UserResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for user response data</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the user</p> <code>role</code> <code>str</code> <p>The assigned role of the user</p> <code>email</code> <code>EmailStr</code> <p>The user's email address</p> <code>is_verified</code> <code>bool</code> <p>Indicates whether the user's email address is verified (defaults to False)</p> <code>created_at</code> <code>Optional[datetime]</code> <p>Timestamp of the user account creation</p> Source code in <code>app/models/user.py</code> <pre><code>class UserResponse(BaseModel):\n    \"\"\"\n    Pydantic model for user response data\n\n    Attributes:\n        id (str): Unique identifier for the user\n        role (str): The assigned role of the user\n        email (EmailStr): The user's email address\n        is_verified (bool): Indicates whether the user's email address is verified (defaults to False)\n        created_at (Optional[datetime]): Timestamp of the user account creation\n    \"\"\"\n    id: str\n    role: str\n    email: EmailStr\n    is_verified: bool = False\n    created_at: Optional[datetime]\n\n    model_config = ConfigDict(from_attributes = True)\n</code></pre>"},{"location":"api/#app.models.energy_data","title":"<code>app.models.energy_data</code>","text":"<p>This module defines the EnergyData model used for storing energy consumption records</p> <p>The model: - Represents energy consumption data for a specific device - Includes metadata such as timestamp &amp; location</p>"},{"location":"api/#app.models.energy_data.EnergyData","title":"<code>app.models.energy_data.EnergyData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing energy consumption data for a smart device</p> <p>Attributes:</p> Name Type Description <code>device_id</code> <code>str</code> <p>Unique identifier for the device</p> <code>timestamp</code> <code>datetime</code> <p>The date &amp; time of the recorded energy consumption</p> <code>energy_consumed</code> <code>float</code> <p>The amount of energy consumed in kilowatt-hours (kWh)</p> <code>location</code> <code>Optional[str]</code> <p>The optional physical location of the device</p> Source code in <code>app/models/energy_data.py</code> <pre><code>class EnergyData(BaseModel):\n    \"\"\"\n    Pydantic model representing energy consumption data for a smart device\n\n    Attributes:\n        device_id (str): Unique identifier for the device\n        timestamp (datetime): The date &amp; time of the recorded energy consumption\n        energy_consumed (float): The amount of energy consumed in kilowatt-hours (kWh)\n        location (Optional[str]): The optional physical location of the device\n    \"\"\"\n    device_id: str\n    timestamp: datetime\n    energy_consumed: float          # tracking in kWh (kilowatt hours)\n    location: Optional[str] = None\n</code></pre>"},{"location":"api/#app.db.database","title":"<code>app.db.database</code>","text":"<p>This module handles MongoDB database connections &amp; operations</p> <p>It provides: - Initialization of MongoDB collections &amp; indexes - Functions to fetch energy consumption data with optional filtering</p>"},{"location":"api/#app.db.database.get_energy_data","title":"<code>app.db.database.get_energy_data(start_date=None, end_date=None)</code>","text":"<p>Fetch energy data consumption from MongoDB with optional date filtering</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Start date in <code>YYYY-MM-DD</code> format</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date in <code>YYYY-MM-DD</code> format</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of energy consumption records</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided date format is incorrect</p> Source code in <code>app/db/database.py</code> <pre><code>def get_energy_data(start_date: str = None, end_date: str = None) -&gt; List[Dict]:\n    \"\"\"\n    Fetch energy data consumption from MongoDB with optional date filtering\n\n    Args:\n        start_date (str, optional): Start date in `YYYY-MM-DD` format\n        end_date (str, optional): End date in `YYYY-MM-DD` format\n\n    Returns:\n        List[Dict]: A list of energy consumption records\n\n    Raises:\n        ValueError: If the provided date format is incorrect\n    \"\"\"\n    query = {}\n\n    if start_date and end_date:\n        try:\n            start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n            end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n            query[\"timestamp\"] = {\"$gte\": start_dt, \"$lte\": end_dt}\n        except ValueError as exc:\n            raise ValueError(\"Invalid date format. Use `YYYY-MM-DD`.\") from exc\n\n    energy_data = list(energy_collection.find(query, {\"_id\": 0}))   # Exclude MongoDB _id field\n\n    return energy_data\n</code></pre>"},{"location":"api/#app.db.database.init_db","title":"<code>app.db.database.init_db()</code>  <code>async</code>","text":"<p>Initialize the database by creating necessary indexes</p> <p>This function ensures: - Unique email constraint for users - Indexes on <code>device_id</code> &amp; <code>timestamp</code> in the energy collection for optimized queries</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is an error during database initialization</p> Source code in <code>app/db/database.py</code> <pre><code>async def init_db():\n    \"\"\"\n    Initialize the database by creating necessary indexes\n\n    This function ensures:\n    - Unique email constraint for users\n    - Indexes on `device_id` &amp; `timestamp` in the energy collection for optimized queries\n\n    Raises:\n        RuntimeError: If there is an error during database initialization\n    \"\"\"\n    try:\n        # Create uniqueness of user emails\n        users_collection.create_index(\"email\", unique = True)\n\n        # Optimize queries by creating indexes on frequently queried fields\n        energy_collection.create_index(\"device_id\")\n        energy_collection.create_index(\"timestamp\")\n\n        print(\"Database initialized successfully.\")\n    except Exception as e:\n        raise RuntimeError(f\"Error during database initialization: {e}\") from e\n</code></pre>"},{"location":"api/#app.core.config","title":"<code>app.core.config</code>","text":""},{"location":"api/#app.core.security","title":"<code>app.core.security</code>","text":"<p>This module implements security features</p> <p>Features include: - Password hashing - JWT token creation &amp; verification - Role-based access control</p>"},{"location":"api/#app.core.security.create_access_token","title":"<code>app.core.security.create_access_token(data, expires_delta=None)</code>","text":"<p>Create a JWT token with an expiration time</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The payload to encode in the token</p> required <code>expires_delta</code> <code>Optional[timedelta]</code> <p>The expiration time delta Defaults to <code>ACCESS_TOKEN_EXPIRE_MINUTES</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The encoded JWT token</p> Source code in <code>app/core/security.py</code> <pre><code>def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"\n    Create a JWT token with an expiration time\n\n    Args:\n        data (dict): The payload to encode in the token\n        expires_delta (Optional[timedelta], optional): The expiration time delta\n            Defaults to `ACCESS_TOKEN_EXPIRE_MINUTES`\n\n    Returns:\n        str: The encoded JWT token\n    \"\"\"\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes = ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM)\n</code></pre>"},{"location":"api/#app.core.security.get_current_user","title":"<code>app.core.security.get_current_user(token=Depends(oauth2_scheme))</code>","text":"<p>Extract &amp; validate the current user's JWT token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The OAuth2 token obtained from authentication</p> <code>Depends(oauth2_scheme)</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The decoded token payload</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the token is invalid or missing required fields</p> Source code in <code>app/core/security.py</code> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)) -&gt; dict:\n    \"\"\"\n    Extract &amp; validate the current user's JWT token\n\n    Args:\n        token (str): The OAuth2 token obtained from authentication\n\n    Returns:\n        dict: The decoded token payload\n\n    Raises:\n        HTTPException: If the token is invalid or missing required fields\n    \"\"\"\n    payload = verify_access_token(token)\n    if not payload or \"role\" not in payload:\n        raise HTTPException(status_code = status.HTTP_401_UNAUTHORIZED, detail = \"Invalid token\")\n    return payload\n</code></pre>"},{"location":"api/#app.core.security.hash_password","title":"<code>app.core.security.hash_password(password)</code>","text":"<p>Hash a plain-text password using bcrypt</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to hash</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hashed password</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs during hashing</p> Source code in <code>app/core/security.py</code> <pre><code>def hash_password(password: str) -&gt; str:\n    \"\"\"\n    Hash a plain-text password using bcrypt\n\n    Args:\n        password (str): The password to hash\n\n    Returns:\n        str: The hashed password\n\n    Raises:\n        ValueError: If an error occurs during hashing\n    \"\"\"\n    try:\n        return pwd_context.hash(password)\n    except Exception as e:\n        raise ValueError(f\"Error hashing password: {e}\") from e\n</code></pre>"},{"location":"api/#app.core.security.needs_rehash","title":"<code>app.core.security.needs_rehash(hashed_password)</code>","text":"<p>Check if a stored hashed password required rehashing</p> <p>Parameters:</p> Name Type Description Default <code>hashed_password</code> <code>str</code> <p>The existing hashed password</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if rehashing is required &amp; False if otherwise</p> Source code in <code>app/core/security.py</code> <pre><code>def needs_rehash(hashed_password: str) -&gt; bool:\n    \"\"\"\n    Check if a stored hashed password required rehashing\n\n    Args:\n        hashed_password (str): The existing hashed password\n\n    Returns:\n        bool: True if rehashing is required &amp; False if otherwise\n    \"\"\"\n    return pwd_context.needs_update(hashed_password)\n</code></pre>"},{"location":"api/#app.core.security.role_required","title":"<code>app.core.security.role_required(required_role)</code>","text":"<p>Dependency function to check to enforce role-based access control</p> <p>Parameters:</p> Name Type Description Default <code>required_role</code> <code>str</code> <p>The required user role</p> required <p>Returns:</p> Name Type Description <code>function</code> <p>A dependency function that verifies the user's role</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user lacks the required role</p> Source code in <code>app/core/security.py</code> <pre><code>def role_required(required_role: str):\n    \"\"\"\n    Dependency function to check to enforce role-based access control\n\n    Args:\n        required_role (str): The required user role\n\n    Returns:\n        function: A dependency function that verifies the user's role\n\n    Raises:\n        HTTPException: If the user lacks the required role\n    \"\"\"\n    def role_checker(current_user: dict = Depends(get_current_user)):\n        if current_user.get(\"role\") != required_role:\n            raise HTTPException(\n                status_code = status.HTTP_403_FORBIDDEN,\n                detail = f\"Permission denied: {required_role} role required\"\n            )\n        return current_user\n    return role_checker\n</code></pre>"},{"location":"api/#app.core.security.verify_access_token","title":"<code>app.core.security.verify_access_token(token)</code>","text":"<p>Verify &amp; decode a JWT access token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token to verify</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: The decoded token payload if valid, otherwise None</p> Source code in <code>app/core/security.py</code> <pre><code>def verify_access_token(token: str) -&gt; Optional[dict]:\n    \"\"\"\n    Verify &amp; decode a JWT access token\n\n    Args:\n        token (str): The JWT token to verify\n\n    Returns:\n        Optional[dict]: The decoded token payload if valid, otherwise None\n    \"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms = [ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n</code></pre>"},{"location":"api/#app.core.security.verify_password","title":"<code>app.core.security.verify_password(plain_password, hashed_password)</code>","text":"<p>Verify a plain-text password against a hashed password</p> <p>Parameters:</p> Name Type Description Default <code>plain_password</code> <code>str</code> <p>The input password</p> required <code>hashed_password</code> <code>str</code> <p>The stored hashed password</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the password matches &amp; False if otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs during verification</p> Source code in <code>app/core/security.py</code> <pre><code>def verify_password(plain_password: str, hashed_password: str) -&gt; bool:\n    \"\"\"\n    Verify a plain-text password against a hashed password\n\n    Args:\n        plain_password (str): The input password\n        hashed_password (str): The stored hashed password\n\n    Returns:\n        bool: True if the password matches &amp; False if otherwise\n\n    Raises:\n        ValueError: If an error occurs during verification\n    \"\"\"\n    try:\n        return pwd_context.verify(plain_password, hashed_password)\n    except Exception as e:\n        raise ValueError(f\"Error verifying password: {e}\") from e\n</code></pre>"}]}