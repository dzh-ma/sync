"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/statistics/page",{

/***/ "(app-pages-browser)/./components/generate-enhanced-reports.tsx":
/*!**************************************************!*\
  !*** ./components/generate-enhanced-reports.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Simple utility function to download enhanced reports from the backend\n// with fallback to client-side generation\nconst generateEnhancedReport = async (timeRange, toast)=>{\n    try {\n        // Convert time range to date range\n        const endDate = new Date().toISOString().split('T')[0]; // Today in YYYY-MM-DD format\n        let startDate;\n        switch(timeRange){\n            case 'week':\n                startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n                break;\n            case 'month':\n                startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n                break;\n            case 'year':\n                startDate = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n                break;\n            default:\n                startDate = new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n        }\n        // Get auth token from localStorage with error handling\n        let token = \"\";\n        try {\n            // Try different possible token storage locations\n            const authToken = localStorage.getItem(\"authToken\");\n            const jwtToken = localStorage.getItem(\"jwtToken\");\n            const userStr = localStorage.getItem(\"currentUser\");\n            if (authToken) {\n                token = authToken;\n            } else if (jwtToken) {\n                token = jwtToken;\n            } else if (userStr) {\n                const user = JSON.parse(userStr);\n                token = user.token || \"\";\n            }\n        } catch (error) {\n            console.error(\"Error accessing authentication token:\", error);\n        }\n        // If no token, fall back to client-side generation\n        if (!token) {\n            console.warn(\"No authentication token found, falling back to client-side PDF generation\");\n            return false; // Signal to use fallback method\n        }\n        // Prepare the auth header\n        const authHeader = token.startsWith('Bearer ') ? token : \"Bearer \".concat(token);\n        // Call the backend API\n        console.log(\"Downloading report for \".concat(startDate, \" to \").concat(endDate));\n        try {\n            const response = await fetch(\"/api/v1/reports/report?format=pdf&start_date=\".concat(startDate, \"&end_date=\").concat(endDate), {\n                method: 'POST',\n                headers: {\n                    'Authorization': authHeader,\n                    'Accept': 'application/octet-stream'\n                }\n            });\n            if (!response.ok) {\n                // If the API call fails, fall back to client-side generation\n                console.warn(\"API error: \".concat(response.status, \". Falling back to client-side PDF generation\"));\n                return false; // Signal to use fallback method\n            }\n            // Process the file download\n            const blob = await response.blob();\n            const fileURL = window.URL.createObjectURL(blob);\n            const downloadLink = document.createElement('a');\n            downloadLink.href = fileURL;\n            downloadLink.download = \"energy_report_\".concat(new Date().toISOString().split('T')[0], \".pdf\");\n            document.body.appendChild(downloadLink);\n            downloadLink.click();\n            document.body.removeChild(downloadLink);\n            if (toast) {\n                toast({\n                    title: \"Report Downloaded\",\n                    description: \"Your enhanced energy report has been downloaded.\"\n                });\n            }\n            return true; // Signal successful download\n        } catch (fetchError) {\n            console.error(\"Error fetching report:\", fetchError);\n            return false; // Signal to use fallback method\n        }\n    } catch (error) {\n        console.error(\"Error in report generation:\", error);\n        // Fall back to client-side generation on any error\n        return false; // Signal to use fallback method\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateEnhancedReport);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZ2VuZXJhdGUtZW5oYW5jZWQtcmVwb3J0cy50c3giLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdFQUF3RTtBQUN4RSwwQ0FBMEM7QUFDMUMsTUFBTUEseUJBQXlCLE9BQU9DLFdBQW1CQztJQUN2RCxJQUFJO1FBQ0YsbUNBQW1DO1FBQ25DLE1BQU1DLFVBQVUsSUFBSUMsT0FBT0MsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSw2QkFBNkI7UUFDckYsSUFBSUM7UUFFSixPQUFRTjtZQUNOLEtBQUs7Z0JBQ0hNLFlBQVksSUFBSUgsS0FBS0EsS0FBS0ksR0FBRyxLQUFLLElBQUksS0FBSyxLQUFLLEtBQUssTUFBTUgsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3RGO1lBQ0YsS0FBSztnQkFDSEMsWUFBWSxJQUFJSCxLQUFLQSxLQUFLSSxHQUFHLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNSCxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdkY7WUFDRixLQUFLO2dCQUNIQyxZQUFZLElBQUlILEtBQUtBLEtBQUtJLEdBQUcsS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLE1BQU1ILFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN4RjtZQUNGO2dCQUNFQyxZQUFZLElBQUlILEtBQUtBLEtBQUtJLEdBQUcsS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLLE1BQU1ILFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzFGO1FBRUEsdURBQXVEO1FBQ3ZELElBQUlHLFFBQVE7UUFDWixJQUFJO1lBQ0YsaURBQWlEO1lBQ2pELE1BQU1DLFlBQVlDLGFBQWFDLE9BQU8sQ0FBQztZQUN2QyxNQUFNQyxXQUFXRixhQUFhQyxPQUFPLENBQUM7WUFDdEMsTUFBTUUsVUFBVUgsYUFBYUMsT0FBTyxDQUFDO1lBRXJDLElBQUlGLFdBQVc7Z0JBQ2JELFFBQVFDO1lBQ1YsT0FBTyxJQUFJRyxVQUFVO2dCQUNuQkosUUFBUUk7WUFDVixPQUFPLElBQUlDLFNBQVM7Z0JBQ2xCLE1BQU1DLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0g7Z0JBQ3hCTCxRQUFRTSxLQUFLTixLQUFLLElBQUk7WUFDeEI7UUFDRixFQUFFLE9BQU9TLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlDQUF5Q0E7UUFDekQ7UUFFQSxtREFBbUQ7UUFDbkQsSUFBSSxDQUFDVCxPQUFPO1lBQ1ZVLFFBQVFDLElBQUksQ0FBQztZQUNiLE9BQU8sT0FBTyxnQ0FBZ0M7UUFDaEQ7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTUMsYUFBYVosTUFBTWEsVUFBVSxDQUFDLGFBQWFiLFFBQVEsVUFBZ0IsT0FBTkE7UUFFbkUsdUJBQXVCO1FBQ3ZCVSxRQUFRSSxHQUFHLENBQUMsMEJBQTBDcEIsT0FBaEJJLFdBQVUsUUFBYyxPQUFSSjtRQUN0RCxJQUFJO1lBQ0YsTUFBTXFCLFdBQVcsTUFBTUMsTUFBTSxnREFBc0V0QixPQUF0QkksV0FBVSxjQUFvQixPQUFSSixVQUFXO2dCQUM1R3VCLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsaUJBQWlCTjtvQkFDakIsVUFBVTtnQkFDWjtZQUNGO1lBRUEsSUFBSSxDQUFDRyxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLDZEQUE2RDtnQkFDN0RULFFBQVFDLElBQUksQ0FBQyxjQUE4QixPQUFoQkksU0FBU0ssTUFBTSxFQUFDO2dCQUMzQyxPQUFPLE9BQU8sZ0NBQWdDO1lBQ2hEO1lBRUEsNEJBQTRCO1lBQzVCLE1BQU1DLE9BQU8sTUFBTU4sU0FBU00sSUFBSTtZQUNoQyxNQUFNQyxVQUFVQyxPQUFPQyxHQUFHLENBQUNDLGVBQWUsQ0FBQ0o7WUFDM0MsTUFBTUssZUFBZUMsU0FBU0MsYUFBYSxDQUFDO1lBQzVDRixhQUFhRyxJQUFJLEdBQUdQO1lBQ3BCSSxhQUFhSSxRQUFRLEdBQUcsaUJBQXdELE9BQXZDLElBQUluQyxPQUFPQyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFDO1lBQ2hGOEIsU0FBU0ksSUFBSSxDQUFDQyxXQUFXLENBQUNOO1lBQzFCQSxhQUFhTyxLQUFLO1lBQ2xCTixTQUFTSSxJQUFJLENBQUNHLFdBQVcsQ0FBQ1I7WUFFMUIsSUFBSWpDLE9BQU87Z0JBQ1RBLE1BQU07b0JBQ0owQyxPQUFPO29CQUNQQyxhQUFhO2dCQUNmO1lBQ0Y7WUFFQSxPQUFPLE1BQU0sNkJBQTZCO1FBQzVDLEVBQUUsT0FBT0MsWUFBWTtZQUNuQjNCLFFBQVFELEtBQUssQ0FBQywwQkFBMEI0QjtZQUN4QyxPQUFPLE9BQU8sZ0NBQWdDO1FBQ2hEO0lBRUYsRUFBRSxPQUFPNUIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxtREFBbUQ7UUFDbkQsT0FBTyxPQUFPLGdDQUFnQztJQUNoRDtBQUNGO0FBRUEsaUVBQWVsQixzQkFBc0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2R6aC1tYS9Xb3JrL3N5bmMvY29tcG9uZW50cy9nZW5lcmF0ZS1lbmhhbmNlZC1yZXBvcnRzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGUgdXRpbGl0eSBmdW5jdGlvbiB0byBkb3dubG9hZCBlbmhhbmNlZCByZXBvcnRzIGZyb20gdGhlIGJhY2tlbmRcbi8vIHdpdGggZmFsbGJhY2sgdG8gY2xpZW50LXNpZGUgZ2VuZXJhdGlvblxuY29uc3QgZ2VuZXJhdGVFbmhhbmNlZFJlcG9ydCA9IGFzeW5jICh0aW1lUmFuZ2U6IHN0cmluZywgdG9hc3Q6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICB0cnkge1xuICAgIC8vIENvbnZlcnQgdGltZSByYW5nZSB0byBkYXRlIHJhbmdlXG4gICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdOyAvLyBUb2RheSBpbiBZWVlZLU1NLUREIGZvcm1hdFxuICAgIGxldCBzdGFydERhdGU7XG4gICAgXG4gICAgc3dpdGNoICh0aW1lUmFuZ2UpIHtcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBzdGFydERhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgc3RhcnREYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBkYXlcbiAgICAgICAgc3RhcnREYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIDEgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBhdXRoIHRva2VuIGZyb20gbG9jYWxTdG9yYWdlIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgdG9rZW4gPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgZGlmZmVyZW50IHBvc3NpYmxlIHRva2VuIHN0b3JhZ2UgbG9jYXRpb25zXG4gICAgICBjb25zdCBhdXRoVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImF1dGhUb2tlblwiKTtcbiAgICAgIGNvbnN0IGp3dFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJqd3RUb2tlblwiKTtcbiAgICAgIGNvbnN0IHVzZXJTdHIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImN1cnJlbnRVc2VyXCIpO1xuICAgICAgXG4gICAgICBpZiAoYXV0aFRva2VuKSB7XG4gICAgICAgIHRva2VuID0gYXV0aFRva2VuO1xuICAgICAgfSBlbHNlIGlmIChqd3RUb2tlbikge1xuICAgICAgICB0b2tlbiA9IGp3dFRva2VuO1xuICAgICAgfSBlbHNlIGlmICh1c2VyU3RyKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHVzZXJTdHIpO1xuICAgICAgICB0b2tlbiA9IHVzZXIudG9rZW4gfHwgXCJcIjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFjY2Vzc2luZyBhdXRoZW50aWNhdGlvbiB0b2tlbjpcIiwgZXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBubyB0b2tlbiwgZmFsbCBiYWNrIHRvIGNsaWVudC1zaWRlIGdlbmVyYXRpb25cbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJObyBhdXRoZW50aWNhdGlvbiB0b2tlbiBmb3VuZCwgZmFsbGluZyBiYWNrIHRvIGNsaWVudC1zaWRlIFBERiBnZW5lcmF0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTaWduYWwgdG8gdXNlIGZhbGxiYWNrIG1ldGhvZFxuICAgIH1cbiAgICBcbiAgICAvLyBQcmVwYXJlIHRoZSBhdXRoIGhlYWRlclxuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSB0b2tlbi5zdGFydHNXaXRoKCdCZWFyZXIgJykgPyB0b2tlbiA6IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIGJhY2tlbmQgQVBJXG4gICAgY29uc29sZS5sb2coYERvd25sb2FkaW5nIHJlcG9ydCBmb3IgJHtzdGFydERhdGV9IHRvICR7ZW5kRGF0ZX1gKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS92MS9yZXBvcnRzL3JlcG9ydD9mb3JtYXQ9cGRmJnN0YXJ0X2RhdGU9JHtzdGFydERhdGV9JmVuZF9kYXRlPSR7ZW5kRGF0ZX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBhdXRoSGVhZGVyLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gSWYgdGhlIEFQSSBjYWxsIGZhaWxzLCBmYWxsIGJhY2sgdG8gY2xpZW50LXNpZGUgZ2VuZXJhdGlvblxuICAgICAgICBjb25zb2xlLndhcm4oYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9LiBGYWxsaW5nIGJhY2sgdG8gY2xpZW50LXNpZGUgUERGIGdlbmVyYXRpb25gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTaWduYWwgdG8gdXNlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIHRoZSBmaWxlIGRvd25sb2FkXG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgY29uc3QgZmlsZVVSTCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgY29uc3QgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSBmaWxlVVJMO1xuICAgICAgZG93bmxvYWRMaW5rLmRvd25sb2FkID0gYGVuZXJneV9yZXBvcnRfJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX0ucGRmYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgIGRvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZExpbmspO1xuICAgICAgXG4gICAgICBpZiAodG9hc3QpIHtcbiAgICAgICAgdG9hc3Qoe1xuICAgICAgICAgIHRpdGxlOiBcIlJlcG9ydCBEb3dubG9hZGVkXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiWW91ciBlbmhhbmNlZCBlbmVyZ3kgcmVwb3J0IGhhcyBiZWVuIGRvd25sb2FkZWQuXCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gU2lnbmFsIHN1Y2Nlc3NmdWwgZG93bmxvYWRcbiAgICB9IGNhdGNoIChmZXRjaEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgcmVwb3J0OlwiLCBmZXRjaEVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gU2lnbmFsIHRvIHVzZSBmYWxsYmFjayBtZXRob2RcbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHJlcG9ydCBnZW5lcmF0aW9uOlwiLCBlcnJvcik7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNsaWVudC1zaWRlIGdlbmVyYXRpb24gb24gYW55IGVycm9yXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBTaWduYWwgdG8gdXNlIGZhbGxiYWNrIG1ldGhvZFxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZW5lcmF0ZUVuaGFuY2VkUmVwb3J0O1xuIl0sIm5hbWVzIjpbImdlbmVyYXRlRW5oYW5jZWRSZXBvcnQiLCJ0aW1lUmFuZ2UiLCJ0b2FzdCIsImVuZERhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInN0YXJ0RGF0ZSIsIm5vdyIsInRva2VuIiwiYXV0aFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImp3dFRva2VuIiwidXNlclN0ciIsInVzZXIiLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiYXV0aEhlYWRlciIsInN0YXJ0c1dpdGgiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIm9rIiwic3RhdHVzIiwiYmxvYiIsImZpbGVVUkwiLCJ3aW5kb3ciLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJkb3dubG9hZExpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImZldGNoRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/generate-enhanced-reports.tsx\n"));

/***/ })

});