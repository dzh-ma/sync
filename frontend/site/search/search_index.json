{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sync Smart Home API Documentation","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#backend.main","title":"<code>backend.main</code>","text":"<p>This module initializes &amp; configures the FastAPI application</p> <p>It acts as a middleware between the front-end &amp; database, handling: - API route inclusion - CORS middleware for front-end communication - Database initialization &amp; application life-cycle management</p>"},{"location":"api/#backend.main.RootResponse","title":"<code>backend.main.RootResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the root endpoint</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Welcome message</p> Source code in <code>backend/main.py</code> <pre><code>class RootResponse(BaseModel):\n    \"\"\"\n    Response model for the root endpoint\n\n    Attributes:\n        message (str): Welcome message\n    \"\"\"\n    message: str\n</code></pre>"},{"location":"api/#backend.main.lifespan","title":"<code>backend.main.lifespan(app_context)</code>  <code>async</code>","text":"<p>Defines application's lifespan event handler</p> <ul> <li>Initialization the database at startup</li> <li>Sets up application-wide state variables</li> <li>Logs startup &amp; shutdown events</li> </ul> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <code>FastAPI</code> <p>The FastAPI application instance</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If database initialization fails</p> Source code in <code>backend/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app_context: FastAPI):\n    \"\"\"\n    Defines application's lifespan event handler\n\n    - Initialization the database at startup\n    - Sets up application-wide state variables\n    - Logs startup &amp; shutdown events\n\n    Args:\n        app_context (FastAPI): The FastAPI application instance\n\n    Raises:\n        Exception: If database initialization fails\n    \"\"\"\n    try:\n        await init_db()\n        app_context.state.custom_attribute = \"value\"    # Placeholder for future app-wide state\n        logger.info(\"Application startup complete.\")\n        yield\n    except Exception as e:\n        logger.error(\"Failed to initialize the database: %e.\")\n        raise e\n    finally:\n        logger.info(\"Application is shutting down.\")\n</code></pre>"},{"location":"api/#backend.main.read_root","title":"<code>backend.main.read_root()</code>","text":"<p>Root endpoint</p> <p>Returns:</p> Name Type Description <code>RootResponse</code> <code>RootResponse</code> <p>A welcome message for the API</p> Source code in <code>backend/main.py</code> <pre><code>@app.get(\"/\", response_model = RootResponse)\ndef read_root() -&gt; RootResponse:\n    \"\"\"\n    Root endpoint\n\n    Returns:\n        RootResponse: A welcome message for the API\n    \"\"\"\n    return RootResponse(message = \"Welcome to the Sync Smart Home.\")\n</code></pre>"},{"location":"api/#backend.routes.user_routes","title":"<code>backend.routes.user_routes</code>","text":"<p>This module defines user-related API routes for registration, authentication &amp; role-based access</p> <p>It includes: - User registration with hashed password storage - User authentication &amp; JWT token issuance - Admin dashboard access (restricted to users with the \"admin\" role)</p>"},{"location":"api/#backend.routes.user_routes.get_admin_dashboard","title":"<code>backend.routes.user_routes.get_admin_dashboard()</code>  <code>async</code>","text":"<p>Admin dashboard  endpoint (restricted access)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A welcome message confirming admin access</p> Source code in <code>backend/routes/user_routes.py</code> <pre><code>@router.get(\"/admin/dashboard\", dependencies = [Depends(role_required(\"admin\"))])\nasync def get_admin_dashboard() -&gt; dict:\n    \"\"\"\n    Admin dashboard  endpoint (restricted access)\n\n    Returns:\n        dict: A welcome message confirming admin access\n    \"\"\"\n    return {\"message\": \"Welcome, admin!\"}\n</code></pre>"},{"location":"api/#backend.routes.user_routes.login","title":"<code>backend.routes.user_routes.login(form_data=Depends())</code>  <code>async</code>","text":"<p>Authenticate user &amp; return a JWT token</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>OAuth2PasswordRequestForm</code> <p>User-provided login credentials</p> <code>Depends()</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the access token &amp; token type</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If the username or password is incorrect</p> Source code in <code>backend/routes/user_routes.py</code> <pre><code>@router.post(\"/token\")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()) -&gt; dict:\n    \"\"\"\n    Authenticate user &amp; return a JWT token\n\n    Args:\n        form_data (OAuth2PasswordRequestForm): User-provided login credentials\n\n    Returns:\n        dict: A dictionary containing the access token &amp; token type\n\n    Raises:\n        HTTPException (400): If the username or password is incorrect\n    \"\"\"\n    user = users_collection.find_one({\"email\": form_data.username})\n    if not user or not verify_password(form_data.password, user[\"password_hash\"]):\n        raise HTTPException(status_code = 400, detail = \"Invalid username or password\")\n\n    access_token = create_access_token(\n        data = {\"sub\": user[\"email\"], \"role\": user.get(\"role\", \"user\")},\n        expires_delta = timedelta(minutes = 30)\n    )\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"api/#backend.routes.user_routes.register_user","title":"<code>backend.routes.user_routes.register_user(user, background_tasks)</code>  <code>async</code>","text":"<p>Register a new user in the database</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserCreate</code> <p>User registration data including email, password &amp; optional role</p> required <p>Returns:</p> Name Type Description <code>UserResponse</code> <code>UserResponse</code> <p>The created user information excluding password</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If the email is already registered</p> <code>HTTPException(500)</code> <p>If there is an error inserted the user into the database</p> Source code in <code>backend/routes/user_routes.py</code> <pre><code>@router.post(\"/register\", response_model = UserResponse)\nasync def register_user(user: UserCreate, background_tasks: BackgroundTasks) -&gt; UserResponse:\n    \"\"\"\n    Register a new user in the database\n\n    Args:\n        user (UserCreate): User registration data including email, password &amp; optional role\n\n    Returns:\n        UserResponse: The created user information excluding password\n\n    Raises:\n        HTTPException (400): If the email is already registered\n        HTTPException (500): If there is an error inserted the user into the database\n    \"\"\"\n    # Check if email exists already\n    if users_collection.find_one({\"email\": user.email}):\n        raise HTTPException(status_code = 400, detail = \"Registration failed, please try again.\")\n\n    # Prepare user data for insertion\n    user_data = {\n        \"email\": user.email,\n        \"password_hash\": hash_password(user.password),\n        \"is_verified\": False,\n        \"created_at\": datetime.now(timezone.utc),\n        \"updated_at\": datetime.now(timezone.utc),\n        \"role\": user.role or \"user\"\n    }\n\n    # Database user insert\n    try:\n        result = users_collection.insert_one(user_data)\n    except Exception as exc:\n        raise HTTPException(status_code = 500, detail = f\"Failed to register user: {exc}\") from exc\n\n    # Generate verification token &amp; schedule when verification email sends\n    token = generate_verification_token(user.email)\n    background_tasks.add_task(send_verification_email, user.email, token)\n\n    return UserResponse(\n        id = str(result.inserted_id),\n        role = user_data[\"role\"],\n        email = user.email,\n        is_verified = False,\n        created_at = user_data[\"created_at\"]\n    )\n</code></pre>"},{"location":"api/#backend.routes.data_routes","title":"<code>backend.routes.data_routes</code>","text":"<p>This module defines API routes for managing &amp; retrieving energy consumption data</p> <p>It includes: - An endpoint for adding new energy data (admin-only access) - An endpoint for fetching aggregated energy consumption data with filtering options - An admin dashboard route (restricted to users with an \"admin\" role)</p>"},{"location":"api/#backend.routes.data_routes.add_energy_data","title":"<code>backend.routes.data_routes.add_energy_data(data)</code>  <code>async</code>","text":"<p>Add new energy consumption data to the database (admin-only)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>EnergyData</code> <p>The energy data record to be added</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A confirmation message upon successfully insertion</p> Source code in <code>backend/routes/data_routes.py</code> <pre><code>@router.post(\"/add\", dependencies = [Depends(role_required(\"admin\"))])\nasync def add_energy_data(data: EnergyData) -&gt; dict:\n    \"\"\"\n    Add new energy consumption data to the database (admin-only)\n\n    Args:\n        data (EnergyData): The energy data record to be added\n\n    Returns:\n        dict: A confirmation message upon successfully insertion\n    \"\"\"\n    energy_collection.insert_one(data.model_dump())       # Insert into MongoDB\n    return {\"message\": \"Energy data added successfully\"}\n</code></pre>"},{"location":"api/#backend.routes.data_routes.get_admin_dashboard","title":"<code>backend.routes.data_routes.get_admin_dashboard()</code>  <code>async</code>","text":"<p>Admin dashboard endpoint (restricted access)</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A welcome message confirming admin access</p> Source code in <code>backend/routes/data_routes.py</code> <pre><code>@router.get(\"/admin/dashboard\", dependencies = [Depends(role_required(\"admin\"))])\nasync def get_admin_dashboard() -&gt; dict:\n    \"\"\"\n    Admin dashboard endpoint (restricted access)\n\n    Returns:\n        dict: A welcome message confirming admin access\n    \"\"\"\n    return {\"message\": \"Welcome, admin!\"}\n</code></pre>"},{"location":"api/#backend.routes.data_routes.get_aggregated_data","title":"<code>backend.routes.data_routes.get_aggregated_data(start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'), device_id=Query(None, description='Device ID filter'), location=Query(None, description='Location filter'), interval='day')</code>  <code>async</code>","text":"<p>Retrieve aggregated energy consumption data based on time interval &amp; filters</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[str]</code> <p>The start date for filtering (YYYY-MM-DD)</p> <code>Query(None, description='Start date (YYYY-MM-DD)')</code> <code>end_date</code> <code>Optional[str]</code> <p>The end date for filtering (YYYY-MM-DD)</p> <code>Query(None, description='End date (YYYY-MM-DD)')</code> <code>device_id</code> <code>Optional[str]</code> <p>The ID of the device to filter data</p> <code>Query(None, description='Device ID filter')</code> <code>location</code> <code>Optional[str]</code> <p>The location filter</p> <code>Query(None, description='Location filter')</code> <code>interval</code> <code>Literal['hour', 'day', 'week']</code> <p>The time interval for aggregation (defaults to \"day\")</p> <code>'day'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Aggregated energy consumption data grouped by the selected interval</p> Source code in <code>backend/routes/data_routes.py</code> <pre><code>@router.get(\"/aggregate\")\nasync def get_aggregated_data(\n    start_date: Optional[str] = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n    end_date: Optional[str] = Query(None, description = \"End date (YYYY-MM-DD)\"),\n    device_id: Optional[str] = Query(None, description = \"Device ID filter\"),\n    location: Optional[str] = Query(None, description = \"Location filter\"),\n    interval: Literal[\"hour\", \"day\", \"week\"] = \"day\",\n) -&gt; dict:\n    \"\"\"\n    Retrieve aggregated energy consumption data based on time interval &amp; filters\n\n    Args:\n        start_date (Optional[str]): The start date for filtering (YYYY-MM-DD)\n        end_date (Optional[str]): The end date for filtering (YYYY-MM-DD)\n        device_id (Optional[str]): The ID of the device to filter data\n        location (Optional[str]): The location filter\n        interval (Literal[\"hour\", \"day\", \"week\"]): The time interval for aggregation (defaults to \"day\")\n\n    Returns:\n        dict: Aggregated energy consumption data grouped by the selected interval\n    \"\"\"\n    query = {}\n\n    if start_date and end_date:\n        query[\"timestamp\"] = {\n            \"$gte\": datetime.strptime(start_date, \"%Y-%m-%d\"),\n            \"$lte\": datetime.strptime(end_date, \"%Y-%m-%d\")\n        }\n    if device_id:\n        query[\"device_id\"] = device_id\n    if location:\n        query[\"location\"] = location\n\n    time_group = {\n        \"year\": {\"$year\": \"$timestamp\"},\n        \"month\": {\"$month\": \"$timestamp\"},\n        \"day\": {\"$dayOfMonth\": \"$timestamp\"}\n    }\n\n    if interval == \"hour\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"month\": {\"$month\": \"$timestamp\"},\n            \"day\": {\"$dayOfMonth\": \"$timestamp\"},\n            \"hour\": {\"$hour\": \"$timestamp\"}\n        }\n    elif interval == \"day\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"month\": {\"$month\": \"$timestamp\"},\n            \"day\": {\"$dayOfMonth\": \"$timestamp\"}\n        }\n    elif interval == \"week\":\n        time_group = {\n            \"device_id\": \"$device_id\",\n            \"year\": {\"$year\": \"$timestamp\"},\n            \"week\": {\"$isoWeek\": \"$timestamp\"}\n        }\n\n    aggregation_pipeline = [\n        {\"$match\": query},\n        {\"$group\": {\n            \"_id\": {\n                \"device_id\": \"$device_id\",  # Group by device\n                **time_group                # Group by time interval\n            }, \"total_energy\": {\"$sum\": \"$energy_consumed\"}\n        }}\n    ]\n\n    result = list(energy_collection.aggregate(aggregation_pipeline))\n\n    return {\"aggregated_data\": result}\n</code></pre>"},{"location":"api/#backend.routes.data_routes.get_user_energy_data","title":"<code>backend.routes.data_routes.get_user_energy_data(start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'), device_id=Query(None, description='Device ID filter'), _=Depends(profile_permission_required('can_access_energy_data')))</code>  <code>async</code>","text":"<p>Retrieve energy data for profiles with energy data access permission</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[str]</code> <p>Start date for filtering</p> <code>Query(None, description='Start date (YYYY-MM-DD)')</code> <code>end_date</code> <code>Optional[str]</code> <p>End date for filtering</p> <code>Query(None, description='End date (YYYY-MM-DD)')</code> <code>device_id</code> <code>Optional[str]</code> <p>Device ID filter</p> <code>Query(None, description='Device ID filter')</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Energy consumption data</p> Source code in <code>backend/routes/data_routes.py</code> <pre><code>@router.get(\"/user/energy-data\")\nasync def get_user_energy_data(\n    start_date: Optional[str] = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n    end_date: Optional[str] = Query(None, description = \"End date (YYYY-MM-DD)\"),\n    device_id: Optional[str] = Query(None, description = \"Device ID filter\"),\n    _ = Depends(profile_permission_required(\"can_access_energy_data\"))\n) -&gt; dict:\n    \"\"\"\n    Retrieve energy data for profiles with energy data access permission\n\n    Args:\n        start_date (Optional[str]): Start date for filtering\n        end_date (Optional[str]): End date for filtering\n        device_id (Optional[str]): Device ID filter\n\n    Returns:\n        dict: Energy consumption data\n    \"\"\"\n    #  Similar to existing get_aggregated_data but with profile permission check\n    query = {}\n\n    if start_date and end_date:\n        query[\"timestamp\"] = {\n            \"$gte\": datetime.strptime(start_date, \"%Y-%m-%d\"),\n            \"$lte\": datetime.strptime(end_date, \"%Y-%m-%d\")\n        }\n\n    if device_id:\n        query[\"device_id\"] = device_id\n\n    energy_data = list(energy_collection.find(query, {\"_id\": 0}))\n\n    return {\"data\": energy_data}\n</code></pre>"},{"location":"api/#backend.routes.report_routes","title":"<code>backend.routes.report_routes</code>","text":"<p>This module provides API endpoints for generating energy consumption reports</p> <p>It includes: - An endpoint to generate reports in CSV or PDF format, optionally filtered by a data range - Reports are stored in the <code>generated_reports</code> directory</p>"},{"location":"api/#backend.routes.report_routes.generate_report","title":"<code>backend.routes.report_routes.generate_report(format=Query('csv', enum=['csv', 'pdf']), start_date=Query(None, description='Start date (YYYY-MM-DD)'), end_date=Query(None, description='End date (YYYY-MM-DD)'))</code>  <code>async</code>","text":"<p>Generate an energy consumption report in CSV or PDF format</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>The desired report format, either \"csv\" or \"pdf\"</p> <code>Query('csv', enum=['csv', 'pdf'])</code> <code>start_date</code> <code>str</code> <p>The start date for filtering data (YYYY-MM-DD)</p> <code>Query(None, description='Start date (YYYY-MM-DD)')</code> <code>end_date</code> <code>str</code> <p>The end date for filtering data (YYYY-MM-DD)</p> <code>Query(None, description='End date (YYYY-MM-DD)')</code> <p>Returns:</p> Name Type Description <code>FileResponse</code> <code>FileResponse</code> <p>The generated report file</p> <p>Raises:</p> Type Description <code>HTTPException(400)</code> <p>If an invalid date format is provided</p> <code>HTTPException(404)</code> <p>If no energy data is available for the selected range</p> Source code in <code>backend/routes/report_routes.py</code> <pre><code>@router.post(\"/report\", dependencies = [Depends(role_required(\"admin\"))])\nasync def generate_report(\n        format: str = Query(\"csv\", enum = [\"csv\", \"pdf\"]),\n        start_date: str = Query(None, description = \"Start date (YYYY-MM-DD)\"),\n        end_date: str = Query(None, description = \"End date (YYYY-MM-DD)\")\n) -&gt; FileResponse:\n    \"\"\"\n    Generate an energy consumption report in CSV or PDF format\n\n    Args:\n        format (str): The desired report format, either \"csv\" or \"pdf\"\n        start_date (str, optional): The start date for filtering data (YYYY-MM-DD)\n        end_date (str, optional): The end date for filtering data (YYYY-MM-DD)\n\n    Returns:\n        FileResponse: The generated report file\n\n    Raises:\n        HTTPException (400): If an invalid date format is provided\n        HTTPException (404): If no energy data is available for the selected range\n    \"\"\"\n    try:\n        energy_data = get_energy_data(start_date, end_date)\n    except ValueError as exc:\n        raise HTTPException(status_code = 400, detail = str(exc)) from exc\n\n    if not energy_data:\n        raise HTTPException(status_code = 404, detail = \"No energy data available for the selected range.\")\n\n    timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{REPORTS_DIR}/energy_report_{timestamp}.{format}\"\n\n    if format == \"csv\":\n        # Convert data to a DataFrame &amp; format timestamps\n        # df = pd.DataFrame(energy_data)\n        # df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"]).dt.strftime(\"%Y-%m-%d %H:%M:%S\")  # Format timestamp\n        # df.columns = [\"Device ID\", \"Timestamp\", \"Energy Consumed (kWh)\", \"Location\"]\n        df = pd.DataFrame(energy_data)\n        df.drop(columns=[\"timestamps\"], errors=\"ignore\", inplace=True)  # Drop extra column\n        df.columns = [\"Device ID\", \"Timestamp\", \"Energy Consumed (kWh)\", \"Location\"]\n        df.to_csv(filename, index = False)\n    elif format == \"pdf\":\n        # Create a PDF report with a structure table\n        doc = SimpleDocTemplate(filename, pagesize=letter)\n        elements = []\n\n        # Prepare table data\n        data = [[\"Device ID\", \"Timestamp\", \"Energy Cosumed (kWh)\", \"Location\"]]\n        for entry in energy_data:\n            data.append([\n                str(entry.get(\"device_id\", \"N/A\")),\n                str(entry.get(\"timestamp\", \"\").strftime('%Y-%m-%d %H:%M:%S') if entry.get(\"timestamp\") else \"N/A\"),\n                str(entry.get(\"energy_consumed\", \"N/A\")),\n                str(entry.get(\"location\", \"N/A\"))\n            ])\n\n        # Create &amp; style table\n        table = Table(data)\n        table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, 0), 12),\n            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.whitesmoke, colors.lightgrey])\n        ]))\n\n        elements.append(table)\n        doc.build(elements)\n\n    return FileResponse(\n        path  = os.path.abspath(filename),\n        filename = os.path.basename(filename),\n        media_type = \"application/octet-stream\"\n    )\n</code></pre>"},{"location":"api/#backend.models.device","title":"<code>backend.models.device</code>","text":"<p>This module defines the EnergySummary model for analyzing &amp; reporting energy consumption</p> <p>The EnergySummary model: - Aggregates energy consumption data over specified time periods - Supports reporting &amp; historical data analysis requirements - Enables cost estimation based on energy usage - Facilitates comparisons between current &amp; past usage periods - Provides the data foundation for energy-saving suggestions &amp; insights</p>"},{"location":"api/#backend.models.device.Device","title":"<code>backend.models.device.Device</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing a smart device within the home automation system</p> <p>Tracks device information, current status, &amp; location within the home</p> <p>Used for device control, automation, &amp; energy consumption tracking</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the device</p> <code>name</code> <code>str</code> <p>User-friendly name for the device</p> <code>type</code> <code>str</code> <p>Category of device (e.g., \"light\", \"thermostat\", \"appliance\")</p> <code>room_id</code> <code>Optional[str]</code> <p>ID of the room where the device is located</p> <code>status</code> <code>str</code> <p>Current operational status (\"on\", \"off\", or custom states)</p> <code>is_active</code> <code>bool</code> <p>Whether the device is currently available in the system</p> Source code in <code>backend/models/device.py</code> <pre><code>class Device(BaseModel):\n    \"\"\"\n        Pydantic model representing a smart device within the home automation system\n\n        Tracks device information, current status, &amp; location within the home\n\n        Used for device control, automation, &amp; energy consumption tracking\n\n        Attributes:\n            id (str): Unique identifier for the device\n            name (str): User-friendly name for the device\n            type (str): Category of device (e.g., \"light\", \"thermostat\", \"appliance\")\n            room_id (Optional[str]): ID of the room where the device is located\n            status (str): Current operational status (\"on\", \"off\", or custom states)\n            is_active (bool): Whether the device is currently available in the system\n    \"\"\"\n    id: str\n    name: str\n    type: str\n    room_id: Optional[str]\n    status: str             # \"on\"/\"off\"/custom states\n    is_active: bool = True\n</code></pre>"},{"location":"api/#backend.models.energy_data","title":"<code>backend.models.energy_data</code>","text":"<p>This module defines the EnergyData model used for storing energy consumption records</p> <p>The model: - Represents energy consumption data for a specific device - Includes metadata such as timestamp &amp; location</p>"},{"location":"api/#backend.models.energy_data.EnergyData","title":"<code>backend.models.energy_data.EnergyData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing energy consumption data for a smart device</p> <p>Attributes:</p> Name Type Description <code>device_id</code> <code>str</code> <p>Unique identifier for the device</p> <code>timestamp</code> <code>datetime</code> <p>The date &amp; time of the recorded energy consumption</p> <code>energy_consumed</code> <code>float</code> <p>The amount of energy consumed in kilowatt-hours (kWh)</p> <code>location</code> <code>Optional[str]</code> <p>The optional physical location of the device</p> Source code in <code>backend/models/energy_data.py</code> <pre><code>class EnergyData(BaseModel):\n    \"\"\"\n    Pydantic model representing energy consumption data for a smart device\n\n    Attributes:\n        device_id (str): Unique identifier for the device\n        timestamp (datetime): The date &amp; time of the recorded energy consumption\n        energy_consumed (float): The amount of energy consumed in kilowatt-hours (kWh)\n        location (Optional[str]): The optional physical location of the device\n    \"\"\"\n    device_id: str\n    timestamp: datetime\n    energy_consumed: float          # tracking in kWh (kilowatt hours)\n    location: Optional[str] = None\n</code></pre>"},{"location":"api/#backend.models.energy_summary","title":"<code>backend.models.energy_summary</code>","text":"<p>This module defines the EnergySummary model for analyzing &amp; reporting energy consumption</p> <p>The EnergySummary model: - Aggregates energy consumption data over specified time periods - Supports reporting &amp; historical data analysis requirements - Enables cost estimation based on energy usage - Facilitates comparisons between current &amp; past usage periods - Provides the data foundation for energy-saving suggestions &amp; insights</p>"},{"location":"api/#backend.models.energy_summary.EnergySummary","title":"<code>backend.models.energy_summary.EnergySummary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing aggregated energy usage data for reporting</p> <p>Provides summarized energy consumption data for specific time periods,     enabling users to track trends &amp; compare usage over time</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>ID of the user this summary belongs to</p> <code>period</code> <code>str</code> <p>Time period of the summary (\"daily\", \"weekly\", \"monthly\")</p> <code>start_date</code> <code>datetime</code> <p>Beginning of the summary period</p> <code>end_date</code> <code>datetime</code> <p>End of the summary period</p> <code>total_consumption</code> <code>float</code> <p>Total energy consumed in kWh during the period</p> <code>cost_estimate</code> <code>Optional[float]</code> <p>Estimated cost of energy used</p> <code>comparison_to_previous</code> <code>Optional[float]</code> <p>Percentage change compared to previous period</p> Source code in <code>backend/models/energy_summary.py</code> <pre><code>class EnergySummary(BaseModel):\n    \"\"\"\n    Pydantic model representing aggregated energy usage data for reporting\n\n    Provides summarized energy consumption data for specific time periods,\n        enabling users to track trends &amp; compare usage over time\n\n    Attributes:\n        user_id (str): ID of the user this summary belongs to\n        period (str): Time period of the summary (\"daily\", \"weekly\", \"monthly\")\n        start_date (datetime): Beginning of the summary period\n        end_date (datetime): End of the summary period\n        total_consumption (float): Total energy consumed in kWh during the period\n        cost_estimate (Optional[float]): Estimated cost of energy used\n        comparison_to_previous (Optional[float]): Percentage change compared to previous period\n    \"\"\"\n    user_id: str\n    period: str     # daily, weekly, monthly\n    start_date: datetime\n    end_date: datetime\n    total_consumption: float\n    cost_estimate: Optional[float]\n    comparison_to_previous: Optional[float]     # percentage change\n</code></pre>"},{"location":"api/#backend.models.profile","title":"<code>backend.models.profile</code>","text":"<p>This module defines the Profile model for managing user profiles in the Smart Family Energy Manager</p> <p>The Profile model: - Represents different user types within the system (adult/elderly, child) - Stores accessibility preferences &amp; personalization settings - Manages access control for features like device control &amp; energy data - Supports the admin's ability to create &amp; manage multiple profiles per household</p>"},{"location":"api/#backend.models.profile.Profile","title":"<code>backend.models.profile.Profile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing a user profile in the Smart Family Energy Manager system</p> <p>Profiles are created by an admin &amp; can be customized for different family member     with varying levels of access to system features &amp; data</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>Unique identifier linking this profile to a user account</p> <code>name</code> <code>str</code> <p>The display name for this profile</p> <code>age</code> <code>Optional[int]</code> <p>The age of the profile user, used to tailor experience</p> <code>profile_type</code> <code>str</code> <p>Type of profile - \"adult\", \"elderly\", or \"child\"</p> <code>accessibility_settings</code> <code>Dict</code> <p>Dictionary containing accessibility preferences</p> <code>can_control_devices</code> <code>bool</code> <p>Whether this profile can control smart devices</p> <code>can_access_energy_data</code> <code>bool</code> <p>Whether this profile can view energy consumption data</p> <code>can_manage_notifications</code> <code>bool</code> <p>Whether this profile can manage notification settings</p> Source code in <code>backend/models/profile.py</code> <pre><code>class Profile(BaseModel):\n    '''\n    Pydantic model representing a user profile in the Smart Family Energy Manager system\n\n    Profiles are created by an admin &amp; can be customized for different family member\n        with varying levels of access to system features &amp; data\n\n    Attributes:\n        user_id (str): Unique identifier linking this profile to a user account\n        name (str): The display name for this profile\n        age (Optional[int]): The age of the profile user, used to tailor experience\n        profile_type (str): Type of profile - \"adult\", \"elderly\", or \"child\"\n        accessibility_settings (Dict): Dictionary containing accessibility preferences\n        can_control_devices (bool): Whether this profile can control smart devices\n        can_access_energy_data (bool): Whether this profile can view energy consumption data\n        can_manage_notifications (bool): Whether this profile can manage notification settings\n    '''\n    user_id: str\n    name: str\n    age: Optional[str]\n    profile_type: str       # \"adult\"/\"elderly\"/\"child\"\n    accessibility_settings: dict = {}\n    can_control_devices: bool = False\n    can_access_energy_data: bool = False\n    can_manage_notifications: bool = False\n</code></pre>"},{"location":"api/#backend.models.room","title":"<code>backend.models.room</code>","text":"<p>This module defines the Room model for organizing smart devices by location within the home</p> <p>The Room model: - Provides a way to group devices by physical location - Supports the add/delete room functionality requirement - Enables room-based energy consumption analytics - Helps users organize &amp; manage their smart home more efficiently - Facilitates location-specific automation rules &amp; schedules</p>"},{"location":"api/#backend.models.room.Room","title":"<code>backend.models.room.Room</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing a room or area within the smart home</p> <p>Rooms provide organizational structure for devices &amp; help contextualize     energy usage data by location</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the room</p> <code>name</code> <code>str</code> <p>User-friendly name for the room (e.g., \"Living Room\", \"Kitchen\")</p> <code>created_by</code> <code>str</code> <p>ID of the user who created this room</p> Source code in <code>backend/models/room.py</code> <pre><code>class Room(BaseModel):\n    \"\"\"\n    Pydantic model representing a room or area within the smart home\n\n    Rooms provide organizational structure for devices &amp; help contextualize\n        energy usage data by location\n\n    Attributes:\n        id (str): Unique identifier for the room\n        name (str): User-friendly name for the room (e.g., \"Living Room\", \"Kitchen\")\n        created_by (str): ID of the user who created this room\n    \"\"\"\n    id: str\n    name: str\n    created_by: str     # user_id\n</code></pre>"},{"location":"api/#backend.models.schedule","title":"<code>backend.models.schedule</code>","text":"<p>This module defines the Schedule model for automating device operations within the smart home</p> <p>The Schedule model: - Enables users to set timed operations for connected devices - Supports the scheduling &amp; automation functional requirements - Allows for energy optimization through scheduled device usage - Provides time-based control of devices for convenience &amp; efficiency - Implements the core functionality of device automation based on user-defined schedules</p>"},{"location":"api/#backend.models.schedule.Schedule","title":"<code>backend.models.schedule.Schedule</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model representing an automated schedule for a smart device</p> <p>Allows users to create automated routines for devices to operate at     specified times, supporting energy efficiency &amp; convenience</p> <p>Attributes:</p> Name Type Description <code>device_id</code> <code>str</code> <p>ID of the device to be controlled by this schedule</p> <code>start_time</code> <code>datetime</code> <p>Time when the scheduled operation should begin</p> <code>end_time</code> <code>datetime</code> <p>Time when the scheduled operation should end</p> <code>start_date</code> <code>datetime</code> <p>Date when the schedule becomes active</p> <code>end_date</code> <code>datetime</code> <p>Date when the schedule expires</p> <code>created_by</code> <code>str</code> <p>ID of the user who created this schedule</p> <code>is_active</code> <code>bool</code> <p>Whether this schedule is currently enabled</p> Source code in <code>backend/models/schedule.py</code> <pre><code>class Schedule(BaseModel):\n    \"\"\"\n    Pydantic model representing an automated schedule for a smart device\n\n    Allows users to create automated routines for devices to operate at\n        specified times, supporting energy efficiency &amp; convenience\n\n    Attributes:\n        device_id (str): ID of the device to be controlled by this schedule\n        start_time (datetime): Time when the scheduled operation should begin\n        end_time (datetime): Time when the scheduled operation should end\n        start_date (datetime): Date when the schedule becomes active\n        end_date (datetime): Date when the schedule expires\n        created_by (str): ID of the user who created this schedule\n        is_active (bool): Whether this schedule is currently enabled\n    \"\"\"\n    device_id: str\n    start_time: datetime\n    end_time: datetime\n    start_date: datetime\n    end_date: datetime\n    created_by: str         # user_id\n    is_active: bool = True\n</code></pre>"},{"location":"api/#backend.models.user","title":"<code>backend.models.user</code>","text":"<p>This model defines user-related data models for account creation &amp; response handling</p> <p>It includes: - <code>UserCreate</code>: A model for user registration input with email &amp; password validation - <code>UserResponse</code>: A model for returning user details in API responses</p>"},{"location":"api/#backend.models.user.UserCreate","title":"<code>backend.models.user.UserCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for user registration input</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>EmailStr</code> <p>The user's email address</p> <code>password</code> <code>str</code> <p>The user's password (validated for strength)</p> <code>role</code> <code>Optional[str]</code> <p>The user's role, defaulting to \"user\"</p> Source code in <code>backend/models/user.py</code> <pre><code>class UserCreate(BaseModel):\n    '''\n    Pydantic model for user registration input\n\n    Attributes:\n        email (EmailStr): The user's email address\n        password (str): The user's password (validated for strength)\n        role (Optional[str]): The user's role, defaulting to \"user\"\n    '''\n    email: EmailStr\n    password: str\n    role: Optional[str] = \"user\"    # Default role\n\n    @field_validator(\"password\")\n    @classmethod\n    def validate_password(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the password to ensure it meets security requirements\n\n        Args:\n            value (str): The password provided by the user\n\n        Returns:\n            str: The validated password\n\n        Raises:\n            ValueError: If the password doesn't meet security requirements\n        \"\"\"\n        if len(value) &lt; 8:\n            raise ValueError(\"Password must be at least 8 characters long.\")\n        if not any(char.isdigit() for char in value):\n            raise ValueError(\"Password must contain at least 1 number.\")\n        if not any(char.isalpha() for char in value):\n            raise ValueError(\"Password must contain at least 1 letter.\")\n        if not any(char.islower() for char in value):\n            raise ValueError(\"Password must contain at least 1 lower letter.\")\n        if not any(char.isupper() for char in value):\n            raise ValueError(\"Password must contain at least 1 upper letter.\")\n        if not any(char in '!@#$%^&amp;*()_+-=[]{}|;\\':\",.&lt;&gt;?/' for char in value):\n            raise ValueError(\"Password must contain at least 1 special character.\")\n        return value\n\n    @field_validator(\"email\")\n    @classmethod\n    def validate_email(cls, value: EmailStr) -&gt; EmailStr:\n        \"\"\"\n        Validate the user's email address\n\n        Args:\n            value (EmailStr): The email address provided\n\n        Returns:\n            EmailStr: The validated email\n\n        Raises:\n            ValueError: If the email doesn't contain `@` or a valid domain\n        \"\"\"\n        if not \"@\" in value:\n            raise ValueError(\"Email must contain @.\")\n        if not \".\" in value.split(\"@\")[1]:\n            raise ValueError(\"Email must contain a dot.\")\n        return value\n</code></pre>"},{"location":"api/#backend.models.user.UserCreate.validate_email","title":"<code>backend.models.user.UserCreate.validate_email(value)</code>  <code>classmethod</code>","text":"<p>Validate the user's email address</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>EmailStr</code> <p>The email address provided</p> required <p>Returns:</p> Name Type Description <code>EmailStr</code> <code>EmailStr</code> <p>The validated email</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the email doesn't contain <code>@</code> or a valid domain</p> Source code in <code>backend/models/user.py</code> <pre><code>@field_validator(\"email\")\n@classmethod\ndef validate_email(cls, value: EmailStr) -&gt; EmailStr:\n    \"\"\"\n    Validate the user's email address\n\n    Args:\n        value (EmailStr): The email address provided\n\n    Returns:\n        EmailStr: The validated email\n\n    Raises:\n        ValueError: If the email doesn't contain `@` or a valid domain\n    \"\"\"\n    if not \"@\" in value:\n        raise ValueError(\"Email must contain @.\")\n    if not \".\" in value.split(\"@\")[1]:\n        raise ValueError(\"Email must contain a dot.\")\n    return value\n</code></pre>"},{"location":"api/#backend.models.user.UserCreate.validate_password","title":"<code>backend.models.user.UserCreate.validate_password(value)</code>  <code>classmethod</code>","text":"<p>Validate the password to ensure it meets security requirements</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The password provided by the user</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated password</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the password doesn't meet security requirements</p> Source code in <code>backend/models/user.py</code> <pre><code>@field_validator(\"password\")\n@classmethod\ndef validate_password(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the password to ensure it meets security requirements\n\n    Args:\n        value (str): The password provided by the user\n\n    Returns:\n        str: The validated password\n\n    Raises:\n        ValueError: If the password doesn't meet security requirements\n    \"\"\"\n    if len(value) &lt; 8:\n        raise ValueError(\"Password must be at least 8 characters long.\")\n    if not any(char.isdigit() for char in value):\n        raise ValueError(\"Password must contain at least 1 number.\")\n    if not any(char.isalpha() for char in value):\n        raise ValueError(\"Password must contain at least 1 letter.\")\n    if not any(char.islower() for char in value):\n        raise ValueError(\"Password must contain at least 1 lower letter.\")\n    if not any(char.isupper() for char in value):\n        raise ValueError(\"Password must contain at least 1 upper letter.\")\n    if not any(char in '!@#$%^&amp;*()_+-=[]{}|;\\':\",.&lt;&gt;?/' for char in value):\n        raise ValueError(\"Password must contain at least 1 special character.\")\n    return value\n</code></pre>"},{"location":"api/#backend.models.user.UserResponse","title":"<code>backend.models.user.UserResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for user response data</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the user</p> <code>role</code> <code>str</code> <p>The assigned role of the user</p> <code>email</code> <code>EmailStr</code> <p>The user's email address</p> <code>is_verified</code> <code>bool</code> <p>Indicates whether the user's email address is verified (defaults to False)</p> <code>created_at</code> <code>Optional[datetime]</code> <p>Timestamp of the user account creation</p> Source code in <code>backend/models/user.py</code> <pre><code>class UserResponse(BaseModel):\n    \"\"\"\n    Pydantic model for user response data\n\n    Attributes:\n        id (str): Unique identifier for the user\n        role (str): The assigned role of the user\n        email (EmailStr): The user's email address\n        is_verified (bool): Indicates whether the user's email address is verified (defaults to False)\n        created_at (Optional[datetime]): Timestamp of the user account creation\n    \"\"\"\n    id: str\n    role: str\n    email: EmailStr\n    is_verified: bool = False\n    created_at: Optional[datetime]\n\n    model_config = ConfigDict(from_attributes = True)\n</code></pre>"},{"location":"api/#backend.db.database","title":"<code>backend.db.database</code>","text":"<p>This module handles MongoDB database connections &amp; operations</p> <p>It provides: - Initialization of MongoDB collections &amp; indexes - Functions to fetch energy consumption data with optional filtering</p>"},{"location":"api/#backend.db.database.get_energy_data","title":"<code>backend.db.database.get_energy_data(start_date=None, end_date=None)</code>","text":"<p>Fetch energy data consumption from MongoDB with optional date filtering</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Start date in <code>YYYY-MM-DD</code> format</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date in <code>YYYY-MM-DD</code> format</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of energy consumption records</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided date format is incorrect</p> Source code in <code>backend/db/database.py</code> <pre><code>def get_energy_data(start_date: Optional[str] = None, end_date: Optional[str] = None) -&gt; List[Dict]:\n    \"\"\"\n    Fetch energy data consumption from MongoDB with optional date filtering\n\n    Args:\n        start_date (str, optional): Start date in `YYYY-MM-DD` format\n        end_date (str, optional): End date in `YYYY-MM-DD` format\n\n    Returns:\n        List[Dict]: A list of energy consumption records\n\n    Raises:\n        ValueError: If the provided date format is incorrect\n    \"\"\"\n    query = {}\n\n    if start_date and end_date:\n        try:\n            start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n            end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n            query[\"timestamp\"] = {\"$gte\": start_dt, \"$lte\": end_dt}\n        except ValueError as exc:\n            raise ValueError(\"Invalid date format. Use `YYYY-MM-DD`.\") from exc\n\n    energy_data = list(energy_collection.find(query, {\"_id\": 0}))   # Exclude MongoDB _id field\n\n    return energy_data\n</code></pre>"},{"location":"api/#backend.db.database.init_db","title":"<code>backend.db.database.init_db()</code>  <code>async</code>","text":"<p>Initialize the database by creating necessary indexes</p> <p>This function ensures: - Unique email constraint for users - Indexes on <code>device_id</code> &amp; <code>timestamp</code> in the energy collection for optimized queries</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is an error during database initialization</p> Source code in <code>backend/db/database.py</code> <pre><code>async def init_db():\n    \"\"\"\n    Initialize the database by creating necessary indexes\n\n    This function ensures:\n    - Unique email constraint for users\n    - Indexes on `device_id` &amp; `timestamp` in the energy collection for optimized queries\n\n    Raises:\n        RuntimeError: If there is an error during database initialization\n    \"\"\"\n    try:\n        # User collection indexes\n        users_collection.create_index(\"email\", unique = True)\n\n        # Energy data collection indexes\n        energy_collection.create_index(\"device_id\")\n        energy_collection.create_index(\"timestamp\")\n        energy_collection.create_index([(\"device_id\", 1), (\"timestamp\", 1)])\n        energy_collection.create_index(\"location\")\n\n        # Device collection indexes\n        devices_collection.create_index(\"id\", unique=True)\n        devices_collection.create_index(\"room_id\")\n        devices_collection.create_index(\"type\")\n\n        # Profile collection indexes\n        profiles_collection.create_index(\"user_id\")\n        profiles_collection.create_index([(\"user_id\", 1), (\"name\", 1)], unique=True)\n\n        # Room collection indexes\n        rooms_collection.create_index(\"id\", unique=True)\n        rooms_collection.create_index(\"created_by\")\n\n        # Schedule collection indexes\n        schedules_collection.create_index(\"device_id\")\n        schedules_collection.create_index(\"created_by\")\n        schedules_collection.create_index(\"start_date\")\n        schedules_collection.create_index(\"end_date\")\n\n        # Energy summary collection indexes\n        summary_collection.create_index(\"user_id\")\n        summary_collection.create_index([(\"user_id\", 1), (\"period\", 1), (\"start_date\", 1)], unique=True)\n\n        logger.info(\"Database initialized successfully with all collections and indexes.\")\n\n        print(\"Database initialized successfully.\")\n    except Exception as e:\n        raise RuntimeError(f\"Error during database initialization: {e}\") from e\n</code></pre>"},{"location":"api/#backend.core.config","title":"<code>backend.core.config</code>","text":""},{"location":"api/#backend.core.security","title":"<code>backend.core.security</code>","text":"<p>This module implements security features</p> <p>Features include: - Password hashing - JWT token creation &amp; verification - Role-based access control</p>"},{"location":"api/#backend.core.security.create_access_token","title":"<code>backend.core.security.create_access_token(data, expires_delta=None)</code>","text":"<p>Create a JWT token with an expiration time</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The payload to encode in the token</p> required <code>expires_delta</code> <code>Optional[timedelta]</code> <p>The expiration time delta Defaults to <code>ACCESS_TOKEN_EXPIRE_MINUTES</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded JWT token</p> Source code in <code>backend/core/security.py</code> <pre><code>def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -&gt; str:\n    \"\"\"\n    Create a JWT token with an expiration time\n\n    Args:\n        data (dict): The payload to encode in the token\n        expires_delta (Optional[timedelta], optional): The expiration time delta\n            Defaults to `ACCESS_TOKEN_EXPIRE_MINUTES`\n\n    Returns:\n        str: The encoded JWT token\n    \"\"\"\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes = ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM)\n</code></pre>"},{"location":"api/#backend.core.security.get_current_user","title":"<code>backend.core.security.get_current_user(token=Depends(oauth2_scheme))</code>","text":"<p>Extract &amp; validate the current user's JWT token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The OAuth2 token obtained from authentication</p> <code>Depends(oauth2_scheme)</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The decoded token payload</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the token is invalid or missing required fields</p> Source code in <code>backend/core/security.py</code> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)) -&gt; dict:\n    \"\"\"\n    Extract &amp; validate the current user's JWT token\n\n    Args:\n        token (str): The OAuth2 token obtained from authentication\n\n    Returns:\n        dict: The decoded token payload\n\n    Raises:\n        HTTPException: If the token is invalid or missing required fields\n    \"\"\"\n    payload = verify_access_token(token)\n    if not payload or \"role\" not in payload:\n        raise HTTPException(status_code = status.HTTP_401_UNAUTHORIZED, detail = \"Invalid token\")\n    return payload\n</code></pre>"},{"location":"api/#backend.core.security.hash_password","title":"<code>backend.core.security.hash_password(password)</code>","text":"<p>Hash a plain-text password using bcrypt</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to hash</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hashed password</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs during hashing</p> Source code in <code>backend/core/security.py</code> <pre><code>def hash_password(password: str) -&gt; str:\n    \"\"\"\n    Hash a plain-text password using bcrypt\n\n    Args:\n        password (str): The password to hash\n\n    Returns:\n        str: The hashed password\n\n    Raises:\n        ValueError: If an error occurs during hashing\n    \"\"\"\n    try:\n        return pwd_context.hash(password)\n    except Exception as e:\n        raise ValueError(f\"Error hashing password: {e}\") from e\n</code></pre>"},{"location":"api/#backend.core.security.needs_rehash","title":"<code>backend.core.security.needs_rehash(hashed_password)</code>","text":"<p>Check if a stored hashed password required rehashing</p> <p>Parameters:</p> Name Type Description Default <code>hashed_password</code> <code>str</code> <p>The existing hashed password</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if rehashing is required &amp; False if otherwise</p> Source code in <code>backend/core/security.py</code> <pre><code>def needs_rehash(hashed_password: str) -&gt; bool:\n    \"\"\"\n    Check if a stored hashed password required rehashing\n\n    Args:\n        hashed_password (str): The existing hashed password\n\n    Returns:\n        bool: True if rehashing is required &amp; False if otherwise\n    \"\"\"\n    return pwd_context.needs_update(hashed_password)\n</code></pre>"},{"location":"api/#backend.core.security.role_required","title":"<code>backend.core.security.role_required(required_role)</code>","text":"<p>Dependency function to check to enforce role-based access control</p> <p>Parameters:</p> Name Type Description Default <code>required_role</code> <code>str</code> <p>The required user role</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user lacks the required role</p> Source code in <code>backend/core/security.py</code> <pre><code>def role_required(required_role: str):\n    \"\"\"\n    Dependency function to check to enforce role-based access control\n\n    Args:\n        required_role (str): The required user role\n\n    Raises:\n        HTTPException: If the user lacks the required role\n    \"\"\"\n    def role_checker(current_user: dict = Depends(get_current_user)):\n        if current_user.get(\"role\") != required_role:\n            raise HTTPException(\n                status_code = status.HTTP_403_FORBIDDEN,\n                detail = f\"Permission denied: {required_role} role required\"\n            )\n        return current_user\n    return role_checker\n</code></pre>"},{"location":"api/#backend.core.security.verify_access_token","title":"<code>backend.core.security.verify_access_token(token)</code>","text":"<p>Verify &amp; decode a JWT access token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token to verify</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: The decoded token payload if valid, otherwise None</p> Source code in <code>backend/core/security.py</code> <pre><code>def verify_access_token(token: str) -&gt; Optional[dict]:\n    \"\"\"\n    Verify &amp; decode a JWT access token\n\n    Args:\n        token (str): The JWT token to verify\n\n    Returns:\n        Optional[dict]: The decoded token payload if valid, otherwise None\n    \"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms = [ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n</code></pre>"},{"location":"api/#backend.core.security.verify_password","title":"<code>backend.core.security.verify_password(plain_password, hashed_password)</code>","text":"<p>Verify a plain-text password against a hashed password</p> <p>Parameters:</p> Name Type Description Default <code>plain_password</code> <code>str</code> <p>The input password</p> required <code>hashed_password</code> <code>str</code> <p>The stored hashed password</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the password matches &amp; False if otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs during verification</p> Source code in <code>backend/core/security.py</code> <pre><code>def verify_password(plain_password: str, hashed_password: str) -&gt; bool:\n    \"\"\"\n    Verify a plain-text password against a hashed password\n\n    Args:\n        plain_password (str): The input password\n        hashed_password (str): The stored hashed password\n\n    Returns:\n        bool: True if the password matches &amp; False if otherwise\n\n    Raises:\n        ValueError: If an error occurs during verification\n    \"\"\"\n    try:\n        return pwd_context.verify(plain_password, hashed_password)\n    except Exception as e:\n        raise ValueError(f\"Error verifying password: {e}\") from e\n</code></pre>"}]}